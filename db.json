{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"dc0f50bf546bd330fafe2279f40cfb5b734522b6","modified":1614692925550},{"_id":"source/_posts/C-1.md","hash":"fd064879ad1662a382684c09c831f31bcbb701d9","modified":1615389082681},{"_id":"source/_posts/Flypy一键部署.md","hash":"f5ae8ab59a10cc5ef1cc16db4a503482cc28f776","modified":1615389087677},{"_id":"source/_posts/Linux控制电脑风扇.md","hash":"007b670bfc391eec6c3393c46f63604c969609d4","modified":1615389092313},{"_id":"source/_posts/SPI Flash Modes.md","hash":"677323a80ab3990eb31aab8ac0b39fe855124122","modified":1615389126950},{"_id":"source/_posts/memmove.md","hash":"5556c787351e759fa29f0b169b05f10592158584","modified":1615389097952},{"_id":"source/_posts/pointer_and_index.md","hash":"742d2277e5dcf78886efa007c2264d2085295a48","modified":1615389107093},{"_id":"source/_posts/利用Docker搭建Samba服务.md","hash":"2f03a2cdd636a2ff94c9cdbaf56c82cb1d82c918","modified":1615389130891},{"_id":"source/_posts/玩HASS一年的故事 (一).md","hash":"a2d3048f9f5191809791ddadfe1267d359a18bac","modified":1615389198663},{"_id":"source/_posts/译：UEFI 启动真正做了什么.md","hash":"982ada169ea0e43a9d4767f5aceeca156ca93b45","modified":1615389142405},{"_id":"source/_posts/路由器通过锐捷认证.md","hash":"1596226f65aee9b629a61054425a1f339c4ed81f","modified":1615389145925},{"_id":"source/_posts/软件测试复习.md","hash":"c47ad65fc6a9a5ce912032f82db59a7b4fcd4232","modified":1615389153900},{"_id":"source/categories/index.md","hash":"26ef7adb8247e27cc014641fcf3fcdf522e7723e","modified":1614692925550},{"_id":"source/images/avatar.jpg","hash":"663bb189beefc2e711bde4f17a8ca7e30e435e5c","modified":1538138582330},{"_id":"source/tags/index.md","hash":"a7cf1976928d5fa27f32a159e6007d8c6e5ca1e6","modified":1614692925550},{"_id":"source/whoami/index.md","hash":"fb5312559642a6eea6b09d7334f681554571afb9","modified":1614692925550},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1614692925554},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1614692925554},{"_id":"themes/next/.gitignore","hash":"4600f2b61b2fe0d61f824bda9aa2b5d072f0e635","modified":1614692925554},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1614692925554},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1614692925554},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1614692925554},{"_id":"themes/next/_vendors.yml","hash":"5b895f0254eac45413efcebc2f8b64f1e220530f","modified":1614692925554},{"_id":"themes/next/README.md","hash":"de109b73e09826f6bccceae60c618739a794f8f7","modified":1614692925554},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1614692925554},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1614692925554},{"_id":"themes/next/package.json","hash":"7f470d58fb0b875a78446801ad7aafdceb687981","modified":1614692925554},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1614692925558},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1614692925558},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1614692925558},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1614692925558},{"_id":"themes/next/languages/ar.yml","hash":"7a62243ec54196e3d1bea7364f05aded490bc234","modified":1614692925558},{"_id":"themes/next/languages/de.yml","hash":"dc448f724c7d436233e9567711a09e0d56e60e3b","modified":1614692925558},{"_id":"themes/next/languages/default.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1614692925558},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1614692925558},{"_id":"themes/next/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1614692925558},{"_id":"themes/next/languages/es.yml","hash":"c3506dfaa771e827ae6adb322477c6e835cd0f09","modified":1614692925558},{"_id":"themes/next/languages/fa.yml","hash":"649823297167b902455c0aec8ddebb462df71c7d","modified":1614692925558},{"_id":"themes/next/_config.yml","hash":"d59bd78fe9199821786bf4970ee11fe8ce8aff81","modified":1615389287186},{"_id":"themes/next/languages/fr.yml","hash":"8ddfe98e7847ee8f1eaba9119f9fbdc42d7ec120","modified":1614692925558},{"_id":"themes/next/languages/id.yml","hash":"ac018805190bc4bdc06091f5a6444e612fc700b0","modified":1614692925558},{"_id":"themes/next/languages/it.yml","hash":"82a93c32b3fcf6517441cdc73f75bc6173beb392","modified":1614692925558},{"_id":"themes/next/languages/ko.yml","hash":"8342df2f4190ba4ee004b70d1d6ccd341033dbe7","modified":1614692925558},{"_id":"themes/next/languages/ja.yml","hash":"99f6f84f5cb6631b7ae0b5594af2ea2940c3558e","modified":1614692925558},{"_id":"themes/next/languages/pt-BR.yml","hash":"0863899aca1fa0b767fc337116a310815b4fd175","modified":1614692925558},{"_id":"themes/next/languages/nl.yml","hash":"0d3b56613197cb190900311507535db41daec7d4","modified":1614692925558},{"_id":"themes/next/languages/pt.yml","hash":"e0e2675261e2e80f7ce7d19c945c08217b068d81","modified":1614692925558},{"_id":"themes/next/languages/ru.yml","hash":"fdf5c623890db24cb56ab5ffe0c49db3542477c8","modified":1614692925558},{"_id":"themes/next/languages/si.yml","hash":"f7918a1b1400d7c9e86fb6b75ef5a45eac6798f4","modified":1614692925558},{"_id":"themes/next/languages/tr.yml","hash":"54de3d8d85e3c7b14b163c3d322411b7301a09b3","modified":1614692925558},{"_id":"themes/next/languages/zh-HK.yml","hash":"38b99be8cea1cfd79f36deca13be665dedfad9c5","modified":1614692925558},{"_id":"themes/next/languages/vi.yml","hash":"1f9657b58e11db21f93eb895c90123b8f91751a7","modified":1614692925558},{"_id":"themes/next/languages/zh-CN.yml","hash":"6f7c742316c96d5b71da50fddfb060ff7ec1ea99","modified":1614692925558},{"_id":"themes/next/languages/uk.yml","hash":"1c9a0b8d8160c77cc62064207d57f460f365cae9","modified":1614692925558},{"_id":"themes/next/languages/zh-TW.yml","hash":"8d6f8d90aedcc5c844da93e196bfde0c0161385b","modified":1614692925558},{"_id":"themes/next/layout/_layout.njk","hash":"6915e19058b4b4e2b71707cb5ac6c936ef075e89","modified":1614692925550},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1614692925550},{"_id":"themes/next/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1614692925550},{"_id":"themes/next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1614692925554},{"_id":"themes/next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1614692925550},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1614692925554},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1614692925554},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1614692925558},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1614692925558},{"_id":"themes/next/docs/zh-CN/README.md","hash":"9abd8473985f2bf1557b1aac31b436c92d5450a7","modified":1614692925558},{"_id":"themes/next/docs/ru/README.md","hash":"63df0665005063108e1bc19df3cf8c4e46facb95","modified":1614692925558},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1614692925550},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"cbf838ca59646f128c9111bb28921c1d04d8dcaf","modified":1614692925550},{"_id":"themes/next/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1614692925550},{"_id":"themes/next/layout/_partials/footer.njk","hash":"d16fdaf94d66efc0242b0c26ed539017e3b4f795","modified":1614692925550},{"_id":"themes/next/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1614692925550},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"dfd91d64ebc06b5b139ee97424f4f93e66938e34","modified":1614692925550},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1614692925550},{"_id":"themes/next/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1614692925550},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6f0433940680c0f9db37542ca36f76e4bb1c1d50","modified":1614692925550},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1614692925550},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/index.njk","hash":"467b45a4912369bcba77908151e76a3f3ad0fed2","modified":1614692925550},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1614692925550},{"_id":"themes/next/layout/_third-party/nprogress.njk","hash":"271139c3896a6d294f46f767cb21b2e848050841","modified":1614692925550},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1614692925550},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1614692925550},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1614692925554},{"_id":"themes/next/scripts/filters/locals.js","hash":"374c9211b3b6a5b2ad31f1bea69a22f2727f633a","modified":1614692925554},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1614692925554},{"_id":"themes/next/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1614692925554},{"_id":"themes/next/scripts/filters/post.js","hash":"42a9b81c5449afa9d67770604478168333c93804","modified":1614692925554},{"_id":"themes/next/scripts/helpers/engine.js","hash":"0208f17281a1afe3da1298dd52350eb838098349","modified":1614692925554},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1614692925554},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"413c51fa3caa87fe95d1d8f95e6023f096515632","modified":1614692925554},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1614692925554},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1614692925554},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1614692925554},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1614692925554},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1614692925554},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1614692925554},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1614692925558},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1614692925558},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1614692925558},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1614692925558},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1614692925558},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1614692925558},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1614692925558},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1614692925558},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1614692925558},{"_id":"themes/next/source/css/_mixins.styl","hash":"6bca0a5dc96fea392a0da53e0566ec2a113ec382","modified":1614692925558},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1614692925558},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1614692925558},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1614692925558},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1614692925558},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1614692925558},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1614692925558},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1614692925558},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1614692925558},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1614692925558},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1614692925558},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1614692925558},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1614692925558},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1614692925558},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1614692925558},{"_id":"themes/next/source/js/algolia-search.js","hash":"a360423984cdd915d04365c51bcab440e52d7223","modified":1614692925558},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1614692925558},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1614692925558},{"_id":"themes/next/source/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1614692925558},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1614692925554},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1614692925554},{"_id":"themes/next/source/js/local-search.js","hash":"da2051e7cab184ae4aa64457c5db7476b4645fdc","modified":1614692925558},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1614692925554},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1614692925554},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1614692925554},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1614692925554},{"_id":"themes/next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1614692925554},{"_id":"themes/next/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1614692925554},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1614692925554},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1614692925554},{"_id":"themes/next/source/js/utils.js","hash":"fcb84304fc3ba06f8c4f840fe1e0843339e0899d","modified":1614692925558},{"_id":"themes/next/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1614692925554},{"_id":"themes/next/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1614692925554},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1614692925554},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1614692925554},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1614692925554},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1614692925554},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1614692925554},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1614692925550},{"_id":"themes/next/source/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1614692925558},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"8f6521714044676e15d924da387b2aef45fc8fe6","modified":1614692925550},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1614692925550},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1614692925550},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1614692925550},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1614692925550},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1614692925550},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1614692925550},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1614692925550},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1614692925550},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1614692925550},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1614692925550},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1614692925550},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1614692925550},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1614692925550},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"1410fad73e0a08a45166e4a055ba150fd06e8636","modified":1614692925550},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1614692925550},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1614692925550},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1614692925550},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1614692925550},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1614692925550},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1614692925550},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"c419158e19805e2db614a5f5651e3e534e4a5e4e","modified":1614692925550},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"089e05126e7e4033eff90a26f946c419f2a1e87a","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"c1bf0753fc4bc5f21d61eaffbcc915a462c7d830","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"7a07bbfb09ddf70b919f0ebe1b00942c96152389","modified":1614692925550},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1614692925550},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"47a982aec8830c2f9711b2aff59ff83f09deb09e","modified":1614692925550},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"f4fd63b9f9230dadd1190f79d59313751925ed90","modified":1614692925550},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1614692925550},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1614692925550},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"0ff61346dc1327054ea2c211ba6fb654cdcdfd8d","modified":1614692925550},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1614692925550},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1614692925550},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"b6241ebbb091ef18b3d06cba08ac2e04e3f67a7d","modified":1614692925550},{"_id":"themes/next/scripts/events/lib/config.js","hash":"09b58494e9d9d25542d1d218f2d0ffc4d2da9f30","modified":1614692925554},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"811a3ad58c0a15550100bdc199bef8add1ad526c","modified":1614692925550},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1614692925554},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1614692925554},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"d1ecc44f9f6e236bf910e36150767d36be4658b2","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"ecc93ba67af26b6715fc75001fa0c3131b726241","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"cc1e2d5921c6990f94f3cf11b1ff7533a21da9b7","modified":1614692925554},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"32a1d9ad50621a78d0243e176c8b05ff7866fd5b","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7c0533bac4400689a0d5ab3a188ce42b9375de46","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"60be56c9ba590e5bcb80d1607ca7eeedde9fdfaa","modified":1614692925554},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1614692925554},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1614692925558},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1614692925558},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1614692925558},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1614692925562},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1614692925558},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9d15d0d6a58b1df74827288f117af22b4b6aafe5","modified":1614692925558},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ece860218125bdb2578f373ed4f5040c9670e4b1","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"3c7ae405dd30b9b46494a6b9a6cb1b7ec6138ba9","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1614692925562},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"9f88d350df8115d26c6adbc2025a27ef9a42d7ff","modified":1614692925558},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"db5ddaa8fd2101b0fd7108ce4bbcb9f0649fa223","modified":1614692925558},{"_id":"themes/next/source/css/_variables/base.styl","hash":"32a1b73944561655087d80f025208a84e012b3cf","modified":1615388518446},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1614692925558},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"41cba8c4c5637a6b8f1b62e67673b33676f5d734","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1614692925562},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1614692925558},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1614692925562},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"87e163de866938c668ec33e6ff8972b7a968e0af","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"dc68f16eceaa006e9735d7ff7821af7f4ef50979","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1614692925558},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"2d337a12c5c668ee64447bda5a9ed64eaed5b29e","modified":1614692925558},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"967021e5483495bdefac9e0b3e1c84c366c657fd","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"b1181c5f12a70b8bf710586fcb0d7959841ee512","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"7102f8e819b62cf7d121fd063dc663fd068feaa6","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"b457756758f0632767e8a560e3033059cbe4a67b","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"83c6588c51cd418336f4945813410a100ddfe2a4","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1614692925562},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"bf88d9c585d7b00463c46352402cfea415c29493","modified":1614692925562},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"d6d60f02b5e9f89dbfce180b3884030898022664","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"cf194bea1c9e67fde871a04de3bc81df72c54277","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"d180871d4440090241fc988736c1f3a7efb4b1ba","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"ab715dbf2b98bfeb5e7b7c43e92e5c02496cc2ea","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"6394340c28a21f6aa90e786f3bfe24fb26595653","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1614692925558},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"69eb1c282a8fd5dbab606cc09c34c5dc8e44e753","modified":1614692925558},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"08e79881d58d01afab6dbed37ab4f52356564d7e","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"79ffcf92771cd48f4a686f9d8d7d610f39e9fc1f","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"f53e6c12bd4805888f696386d00668f23cd335e7","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1614692925562},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"50b00218e854200c4ec0573a841e226d49c45cba","modified":1614692925562},{"_id":"public/categories/index.html","hash":"a8a35431243c5632c2c00a59670afe1fa569ab44","modified":1615389295285},{"_id":"public/tags/index.html","hash":"1438c97063cc64f88567d548d2ad07c5c19cc29d","modified":1615389295285},{"_id":"public/whoami/index.html","hash":"72b3addc39de2a1e69b29b70972c658274bd1594","modified":1615389295285},{"_id":"public/archives/page/2/index.html","hash":"dc3c1c1a545bba74bee6d700090f4f02a4d03e3d","modified":1615389295285},{"_id":"public/archives/2018/index.html","hash":"e1877848136d88eafb7c2e7e614fc446fce1a214","modified":1615389295285},{"_id":"public/archives/2018/12/index.html","hash":"2f4a154c60afc3e67114e90c46505ba01f6f018f","modified":1615389295285},{"_id":"public/archives/2019/index.html","hash":"6f14ef4e05711bca118cd8dfa5396fc579a3fe3c","modified":1615389295285},{"_id":"public/archives/2019/01/index.html","hash":"71b7fcc2ee8704bfd827ca880cf2e64b20950612","modified":1615389295285},{"_id":"public/archives/2019/03/index.html","hash":"9d79dc7cbe2d1c8da744db04a247afe274832c36","modified":1615389295285},{"_id":"public/archives/2020/index.html","hash":"cab9aa9b2f637a0010081c09b61bc28d45436c70","modified":1615389295285},{"_id":"public/archives/2020/09/index.html","hash":"d872cd54aa2d71ca23f45e1cbe8fb4dd6f2105cf","modified":1615389295285},{"_id":"public/archives/2020/12/index.html","hash":"1c4b447b689d3820d467200f496df95059c4bf34","modified":1615389295285},{"_id":"public/archives/2021/index.html","hash":"86b9ae70b7c4b91ca4411169eee18bf6897b2739","modified":1615389295285},{"_id":"public/archives/2021/01/index.html","hash":"5a34170c439e837e8952190ed99505bdd92c6bfe","modified":1615389295285},{"_id":"public/categories/C/index.html","hash":"4740cc9a60f410241b02c78f0c7ee13c95b53701","modified":1615389295285},{"_id":"public/categories/Linux/index.html","hash":"a377c96ff9cfbf8cfcf432ac7d33b35fb0213fdc","modified":1615389295285},{"_id":"public/categories/ESP8266-嵌入式/index.html","hash":"27e178237836797d76bd7ef3720ec3843d0af041","modified":1615389295285},{"_id":"public/categories/面试题记录/index.html","hash":"b635c8bf1489e0b01ee797227ff1546cda648452","modified":1615389295285},{"_id":"public/categories/故事/index.html","hash":"02c2c7d5b7be8ef5c5886c2854562d8a56b9ff9a","modified":1615389295285},{"_id":"public/categories/操作系统/index.html","hash":"e4a5ae6d4bb26dd166b3974ee6627073138b388e","modified":1615389295285},{"_id":"public/categories/路由器/index.html","hash":"52deb064b1b0b2abda7580d259bbccd2feaf3a80","modified":1615389295285},{"_id":"public/categories/学习资料/index.html","hash":"02dc020865a474d24b584294d5a7929cc6f32f93","modified":1615389295285},{"_id":"public/page/2/index.html","hash":"f475a211193210b22f4f9d378b78d3cdae3516d1","modified":1615389295285},{"_id":"public/tags/UEFI-BOOT/index.html","hash":"6b4198b204ddcdc879f63dd5850fbcf0fc8d4366","modified":1615389295285},{"_id":"public/2021/01/01/SPI Flash Modes/index.html","hash":"b0a9715ff396c01967ce0aa0ba01f7e0a617e304","modified":1615389295285},{"_id":"public/2020/12/21/memmove/index.html","hash":"e2498759785d196c7c201da26c93ce65242887a4","modified":1615389295285},{"_id":"public/2020/12/20/pointer_and_index/index.html","hash":"31a20e19b157776fdd1647f70fc1d6850257c7b2","modified":1615389295285},{"_id":"public/2020/12/20/C-1/index.html","hash":"d9ea803262415b076a4c368a5f7f56df7bd39891","modified":1615389295285},{"_id":"public/2020/09/04/译：UEFI 启动真正做了什么/index.html","hash":"2511fe507bf694b2810a4846b82e6270c714c034","modified":1615389295285},{"_id":"public/2019/03/17/利用Docker搭建Samba服务/index.html","hash":"13597b6b1d5d6a9dd671649fc7c361f14f9475d5","modified":1615389295285},{"_id":"public/2019/01/05/软件测试复习/index.html","hash":"4fe30371728067536c0d75603a835d7c0fa059b9","modified":1615389295285},{"_id":"public/2019/01/01/Flypy一键部署/index.html","hash":"1aa7568af4cdf02fd87cbed1eaef038952f499fb","modified":1615389295285},{"_id":"public/2018/12/19/Linux控制电脑风扇/index.html","hash":"e3a1340bc8b9035a80d7b0557109407d121d5062","modified":1615389295285},{"_id":"public/2018/12/19/玩HASS一年的故事 (一)/index.html","hash":"00e9fa305253386f489ab027ca6454262e699479","modified":1615389295285},{"_id":"public/2018/12/19/路由器通过锐捷认证/index.html","hash":"7e459fff643e05531dec22cc15728514e91561e8","modified":1615389295285},{"_id":"public/archives/index.html","hash":"68af389e63b3db1b92dfe4afd90d6c3e5ed6804e","modified":1615389295285},{"_id":"public/index.html","hash":"314ea470c3c9b8c4091a6dd1623bd24cf782db83","modified":1615389295285},{"_id":"public/CNAME","hash":"dc0f50bf546bd330fafe2279f40cfb5b734522b6","modified":1615389295285},{"_id":"public/images/avatar.jpg","hash":"663bb189beefc2e711bde4f17a8ca7e30e435e5c","modified":1615389295285},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1615389295285},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1615389295285},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1615389295285},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1615389295285},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1615389295285},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1615389295285},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1615389295285},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1615389295285},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1615389295285},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1615389295285},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1615389295285},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1615389295285},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1615389295285},{"_id":"public/js/algolia-search.js","hash":"a360423984cdd915d04365c51bcab440e52d7223","modified":1615389295285},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1615389295285},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1615389295285},{"_id":"public/js/local-search.js","hash":"da2051e7cab184ae4aa64457c5db7476b4645fdc","modified":1615389295285},{"_id":"public/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1615389295285},{"_id":"public/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1615389295285},{"_id":"public/js/utils.js","hash":"fcb84304fc3ba06f8c4f840fe1e0843339e0899d","modified":1615389295285},{"_id":"public/js/schemes/muse.js","hash":"9d15d0d6a58b1df74827288f117af22b4b6aafe5","modified":1615389295285},{"_id":"public/css/main.css","hash":"10c0451ea3940f4b09cd93a5168358b07b75473a","modified":1615389295285}],"Category":[{"name":"C","_id":"ckm3l2tr30004a5jxfdrx75om"},{"name":"Linux","_id":"ckm3l2tr90009a5jxgmfl90zt"},{"name":"ESP8266 嵌入式","_id":"ckm3l2trh000ha5jxftf3dnko"},{"name":"面试题记录","_id":"ckm3l2trl000ma5jx06n6gqur"},{"name":"故事","_id":"ckm3l2trn000qa5jx1u370iza"},{"name":"操作系统","_id":"ckm3l2tro000sa5jxfm0e6udv"},{"name":"路由器","_id":"ckm3l2trp000ua5jx586egxjw"},{"name":"学习资料","_id":"ckm3l2trs000ya5jxb3u10ezt"}],"Data":[],"Page":[{"title":"categories","date":"2018-12-18T18:39:28.000Z","type":"categories","comments":1,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-12-19 02:39:28\ntype: \"categories\"\ncomments: true\n---\n","updated":"2021-03-02T13:48:45.550Z","path":"categories/index.html","layout":"page","_id":"ckm3l2tqt0000a5jx9c5j1jm7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-09-04T08:03:12.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-09-04 16:03:12\n---\n","updated":"2021-03-02T13:48:45.550Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckm3l2tr00002a5jx7y6e2xpi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Whoami","date":"2020-09-03T16:00:00.000Z","_content":"<div class=\"my-links\">\n  <a class=\"gradient-text\" href=\"https://github.com/Caffreyfans\" target=\"_blank\" rel=\"noopener\"><span class=\" iconfont icon-github\"></span></a>\n</div>\n\n<style>\n  .my-links {display: flex; align-content: flex-start; margin-top: 30px;}\n  .my-links a {display: flex; color: #000; padding: 2px 10px;border-bottom:none !important;}\n  .my-links a span {font-size: 28px;}\n</style>\n\n#### 关于我 Who am I\n\n<img src=\"/img/nLtSiD.png\" style=\"height: 50px; width: 50px; border-radius: 50%; margin-bottom: 15px\" />\n\n欢迎来到我的博客, 我是<b style=\"color: #42d2ca\"> **Caffreyfans** </b>, \n一个从事 Linux 底层开发的工程师（干系统定制，安装占多,感觉自己更像运维）。代码写的越来越少了，目前干着不是一份特别喜欢的工作，期待自己慢慢升级打怪，成为一个 IOT 开发人员。\n\n追求新奇，追求热爱，愿为所爱而奋斗。喜欢一个高效、富有创新的团队，立志打造一款让自己骄傲的产品。\n\n热爱户外旅游和朋友交际，生活和工作平衡，有节奏感的人生。\n——————\n\n#### 开源项目 Open Source Projects\n\n- [IRbaby](https://github.com/Caffreyfans/IRbaby) 一 基于 ESP8266 的万能红外遥控方案\n- [baidu_face](https://github.com/Caffreyfans/baidu_face) 一 HomeAssistant 百度人脸识别插件\n\n#### 开发装备 Development Gears\n\n+ 硬件：自组台式 PC\n+ 系统：Windows 10 专业版/Ubuntu 18.04 TLS\n+ 编辑器：[vscode](https://code.visualstudio.com/)\n+ Shell：[zsh](https://github.com/ohmyzsh/ohmyzsh)\n+ 浏览器：[Chrome](https://www.google.com/chrome/browser/desktop/index.html)\n+ 虚拟机：[VirtualBox](https://www.virtualbox.org/)\n+ VPS: [BandwagongHOST](https://bandwagonhost.com/)\n\n#### 感谢\n感谢 [Hexo](https://hexo.io/zh-cn/index.html) 这么棒的框架和 [obsidian](https://github.com/TriDiamond/hexo-theme-obsidian) 这么棒的主题。\n","source":"whoami/index.md","raw":"---\ntitle: Whoami\ndate: 2020-09-04\n---\n<div class=\"my-links\">\n  <a class=\"gradient-text\" href=\"https://github.com/Caffreyfans\" target=\"_blank\" rel=\"noopener\"><span class=\" iconfont icon-github\"></span></a>\n</div>\n\n<style>\n  .my-links {display: flex; align-content: flex-start; margin-top: 30px;}\n  .my-links a {display: flex; color: #000; padding: 2px 10px;border-bottom:none !important;}\n  .my-links a span {font-size: 28px;}\n</style>\n\n#### 关于我 Who am I\n\n<img src=\"/img/nLtSiD.png\" style=\"height: 50px; width: 50px; border-radius: 50%; margin-bottom: 15px\" />\n\n欢迎来到我的博客, 我是<b style=\"color: #42d2ca\"> **Caffreyfans** </b>, \n一个从事 Linux 底层开发的工程师（干系统定制，安装占多,感觉自己更像运维）。代码写的越来越少了，目前干着不是一份特别喜欢的工作，期待自己慢慢升级打怪，成为一个 IOT 开发人员。\n\n追求新奇，追求热爱，愿为所爱而奋斗。喜欢一个高效、富有创新的团队，立志打造一款让自己骄傲的产品。\n\n热爱户外旅游和朋友交际，生活和工作平衡，有节奏感的人生。\n——————\n\n#### 开源项目 Open Source Projects\n\n- [IRbaby](https://github.com/Caffreyfans/IRbaby) 一 基于 ESP8266 的万能红外遥控方案\n- [baidu_face](https://github.com/Caffreyfans/baidu_face) 一 HomeAssistant 百度人脸识别插件\n\n#### 开发装备 Development Gears\n\n+ 硬件：自组台式 PC\n+ 系统：Windows 10 专业版/Ubuntu 18.04 TLS\n+ 编辑器：[vscode](https://code.visualstudio.com/)\n+ Shell：[zsh](https://github.com/ohmyzsh/ohmyzsh)\n+ 浏览器：[Chrome](https://www.google.com/chrome/browser/desktop/index.html)\n+ 虚拟机：[VirtualBox](https://www.virtualbox.org/)\n+ VPS: [BandwagongHOST](https://bandwagonhost.com/)\n\n#### 感谢\n感谢 [Hexo](https://hexo.io/zh-cn/index.html) 这么棒的框架和 [obsidian](https://github.com/TriDiamond/hexo-theme-obsidian) 这么棒的主题。\n","updated":"2021-03-02T13:48:45.550Z","path":"whoami/index.html","comments":1,"layout":"page","_id":"ckm3l2tr50005a5jxgdqe1m2g","content":"<div class=\"my-links\">\n  <a class=\"gradient-text\" href=\"https://github.com/Caffreyfans\" target=\"_blank\" rel=\"noopener\"><span class=\" iconfont icon-github\"></span></a>\n</div>\n\n<style>\n  .my-links {display: flex; align-content: flex-start; margin-top: 30px;}\n  .my-links a {display: flex; color: #000; padding: 2px 10px;border-bottom:none !important;}\n  .my-links a span {font-size: 28px;}\n</style>\n\n<h4 id=\"关于我-Who-am-I\"><a href=\"#关于我-Who-am-I\" class=\"headerlink\" title=\"关于我 Who am I\"></a>关于我 Who am I</h4><img src=\"/img/nLtSiD.png\" style=\"height: 50px; width: 50px; border-radius: 50%; margin-bottom: 15px\" />\n\n<p>欢迎来到我的博客, 我是<b style=\"color: #42d2ca\"> <strong>Caffreyfans</strong> </b>,<br>一个从事 Linux 底层开发的工程师（干系统定制，安装占多,感觉自己更像运维）。代码写的越来越少了，目前干着不是一份特别喜欢的工作，期待自己慢慢升级打怪，成为一个 IOT 开发人员。</p>\n<p>追求新奇，追求热爱，愿为所爱而奋斗。喜欢一个高效、富有创新的团队，立志打造一款让自己骄傲的产品。</p>\n<p>热爱户外旅游和朋友交际，生活和工作平衡，有节奏感的人生。<br>——————</p>\n<h4 id=\"开源项目-Open-Source-Projects\"><a href=\"#开源项目-Open-Source-Projects\" class=\"headerlink\" title=\"开源项目 Open Source Projects\"></a>开源项目 Open Source Projects</h4><ul>\n<li><a href=\"https://github.com/Caffreyfans/IRbaby\">IRbaby</a> 一 基于 ESP8266 的万能红外遥控方案</li>\n<li><a href=\"https://github.com/Caffreyfans/baidu_face\">baidu_face</a> 一 HomeAssistant 百度人脸识别插件</li>\n</ul>\n<h4 id=\"开发装备-Development-Gears\"><a href=\"#开发装备-Development-Gears\" class=\"headerlink\" title=\"开发装备 Development Gears\"></a>开发装备 Development Gears</h4><ul>\n<li>硬件：自组台式 PC</li>\n<li>系统：Windows 10 专业版/Ubuntu 18.04 TLS</li>\n<li>编辑器：<a href=\"https://code.visualstudio.com/\">vscode</a></li>\n<li>Shell：<a href=\"https://github.com/ohmyzsh/ohmyzsh\">zsh</a></li>\n<li>浏览器：<a href=\"https://www.google.com/chrome/browser/desktop/index.html\">Chrome</a></li>\n<li>虚拟机：<a href=\"https://www.virtualbox.org/\">VirtualBox</a></li>\n<li>VPS: <a href=\"https://bandwagonhost.com/\">BandwagongHOST</a></li>\n</ul>\n<h4 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h4><p>感谢 <a href=\"https://hexo.io/zh-cn/index.html\">Hexo</a> 这么棒的框架和 <a href=\"https://github.com/TriDiamond/hexo-theme-obsidian\">obsidian</a> 这么棒的主题。</p>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"my-links\">\n  <a class=\"gradient-text\" href=\"https://github.com/Caffreyfans\" target=\"_blank\" rel=\"noopener\"><span class=\" iconfont icon-github\"></span></a>\n</div>\n\n<style>\n  .my-links {display: flex; align-content: flex-start; margin-top: 30px;}\n  .my-links a {display: flex; color: #000; padding: 2px 10px;border-bottom:none !important;}\n  .my-links a span {font-size: 28px;}\n</style>\n\n<h4 id=\"关于我-Who-am-I\"><a href=\"#关于我-Who-am-I\" class=\"headerlink\" title=\"关于我 Who am I\"></a>关于我 Who am I</h4><img src=\"/img/nLtSiD.png\" style=\"height: 50px; width: 50px; border-radius: 50%; margin-bottom: 15px\" />\n\n<p>欢迎来到我的博客, 我是<b style=\"color: #42d2ca\"> <strong>Caffreyfans</strong> </b>,<br>一个从事 Linux 底层开发的工程师（干系统定制，安装占多,感觉自己更像运维）。代码写的越来越少了，目前干着不是一份特别喜欢的工作，期待自己慢慢升级打怪，成为一个 IOT 开发人员。</p>\n<p>追求新奇，追求热爱，愿为所爱而奋斗。喜欢一个高效、富有创新的团队，立志打造一款让自己骄傲的产品。</p>\n<p>热爱户外旅游和朋友交际，生活和工作平衡，有节奏感的人生。<br>——————</p>\n<h4 id=\"开源项目-Open-Source-Projects\"><a href=\"#开源项目-Open-Source-Projects\" class=\"headerlink\" title=\"开源项目 Open Source Projects\"></a>开源项目 Open Source Projects</h4><ul>\n<li><a href=\"https://github.com/Caffreyfans/IRbaby\">IRbaby</a> 一 基于 ESP8266 的万能红外遥控方案</li>\n<li><a href=\"https://github.com/Caffreyfans/baidu_face\">baidu_face</a> 一 HomeAssistant 百度人脸识别插件</li>\n</ul>\n<h4 id=\"开发装备-Development-Gears\"><a href=\"#开发装备-Development-Gears\" class=\"headerlink\" title=\"开发装备 Development Gears\"></a>开发装备 Development Gears</h4><ul>\n<li>硬件：自组台式 PC</li>\n<li>系统：Windows 10 专业版/Ubuntu 18.04 TLS</li>\n<li>编辑器：<a href=\"https://code.visualstudio.com/\">vscode</a></li>\n<li>Shell：<a href=\"https://github.com/ohmyzsh/ohmyzsh\">zsh</a></li>\n<li>浏览器：<a href=\"https://www.google.com/chrome/browser/desktop/index.html\">Chrome</a></li>\n<li>虚拟机：<a href=\"https://www.virtualbox.org/\">VirtualBox</a></li>\n<li>VPS: <a href=\"https://bandwagonhost.com/\">BandwagongHOST</a></li>\n</ul>\n<h4 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h4><p>感谢 <a href=\"https://hexo.io/zh-cn/index.html\">Hexo</a> 这么棒的框架和 <a href=\"https://github.com/TriDiamond/hexo-theme-obsidian\">obsidian</a> 这么棒的主题。</p>\n"}],"Post":[{"title":"如何将变量中的值以二进制形式打印出来","date":"2020-12-19T16:00:00.000Z","_content":"## 如何将变量中的值以二进制形式打印出来\n先看源码：\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nconst char *uint64_to_binary(int n)\n{\n    static char str[33];\n    str[0] = '\\0';\n\n    for (unsigned i = 0xffffffff / 2 + 1; i > 0; i >>= 1) {\n        strcat(str, ((n & i) == i) ? \"1\" : \"0\");\n    }\n    return str;\n}\n\nint main()\n{\n    printf(\"%s\\n\", uint64_to_binary(1));\n    return 0;\n}\n```\n<!--more-->\n要打印出每个位的核心思想就是一个位一个位的去比较，如何该位为 1 就记录为 \"1\"，如果该位为 0 就记录为 \"0\"，比较一次记录一次。最后输出字符串中的结果。\n\n`0xffffffff / 2 + 1` 就是将内存中最高位置为 1 其他位置为 0。如果电脑是小端处理器（数据低字节保存在内存的低地址中），那么内存中存储的应该就是 `10000000 00000000 00000000 00000000`，每一次循环就把该数右移一位，内存上体现的就是 1 在一格一格的向右移动。假如我们要输出的数它在内存中实际存储是这个样子 `00000000 00000000 00000000 11111111`。\n\n第 1 次循环:\n`10000000 00000000 00000000 00000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000` 所以 str = \"0\"。\n\n第 2 次循环：\n`01000000 00000000 00000000 00000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000`\n所以 str = \"00\"\n\n......\n\n第 25 次循环：\n`00000000 00000000 00000000 10000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000`\n所以 str = \"0000000000000000000000001\"\n......\n\n这样就把内存中每个位的值打印出来了。如果要打印的是 1 个字节的变量，就得将 `0xffffffff` 修改成 `0xff`。\n\n### 引申\n\n打印变量在内存的每个位是直观了解其在内存分布的方式，其实了解一个变量在内存中是怎么存储的，有利于我们解决异构 CPU 跨字节交互数据的问题。比如一台英特尔 CPU 的电脑（小端处理器）往一个 ESP32（大端处理器）上发送一个 4 字节的整型变量。电脑将 `unsigned int a = 255`, 内存中的数据(`0x000000ff`）直接发到 ESP32 上，ESP32 收到数据后直接内存拷贝到ESP32 中的 `unsigned int b` 变量上，则 b 的数值就为 `4278190080`，这样就很有可能造成程序运行错误。特别是这种跨平台跨字节交互数据的情况应该特别小心，做个大小端转换就没事了。说的容易，但是理解数据在内存中实际的存储情况才是关键。","source":"_posts/C-1.md","raw":"---\ntitle: 如何将变量中的值以二进制形式打印出来\ndate: 2020-12-20\ncategories: C\n---\n## 如何将变量中的值以二进制形式打印出来\n先看源码：\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nconst char *uint64_to_binary(int n)\n{\n    static char str[33];\n    str[0] = '\\0';\n\n    for (unsigned i = 0xffffffff / 2 + 1; i > 0; i >>= 1) {\n        strcat(str, ((n & i) == i) ? \"1\" : \"0\");\n    }\n    return str;\n}\n\nint main()\n{\n    printf(\"%s\\n\", uint64_to_binary(1));\n    return 0;\n}\n```\n<!--more-->\n要打印出每个位的核心思想就是一个位一个位的去比较，如何该位为 1 就记录为 \"1\"，如果该位为 0 就记录为 \"0\"，比较一次记录一次。最后输出字符串中的结果。\n\n`0xffffffff / 2 + 1` 就是将内存中最高位置为 1 其他位置为 0。如果电脑是小端处理器（数据低字节保存在内存的低地址中），那么内存中存储的应该就是 `10000000 00000000 00000000 00000000`，每一次循环就把该数右移一位，内存上体现的就是 1 在一格一格的向右移动。假如我们要输出的数它在内存中实际存储是这个样子 `00000000 00000000 00000000 11111111`。\n\n第 1 次循环:\n`10000000 00000000 00000000 00000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000` 所以 str = \"0\"。\n\n第 2 次循环：\n`01000000 00000000 00000000 00000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000`\n所以 str = \"00\"\n\n......\n\n第 25 次循环：\n`00000000 00000000 00000000 10000000` & `00000000 00000000 00000000 11111111` = `00000000 00000000 00000000 00000000`\n所以 str = \"0000000000000000000000001\"\n......\n\n这样就把内存中每个位的值打印出来了。如果要打印的是 1 个字节的变量，就得将 `0xffffffff` 修改成 `0xff`。\n\n### 引申\n\n打印变量在内存的每个位是直观了解其在内存分布的方式，其实了解一个变量在内存中是怎么存储的，有利于我们解决异构 CPU 跨字节交互数据的问题。比如一台英特尔 CPU 的电脑（小端处理器）往一个 ESP32（大端处理器）上发送一个 4 字节的整型变量。电脑将 `unsigned int a = 255`, 内存中的数据(`0x000000ff`）直接发到 ESP32 上，ESP32 收到数据后直接内存拷贝到ESP32 中的 `unsigned int b` 变量上，则 b 的数值就为 `4278190080`，这样就很有可能造成程序运行错误。特别是这种跨平台跨字节交互数据的情况应该特别小心，做个大小端转换就没事了。说的容易，但是理解数据在内存中实际的存储情况才是关键。","slug":"C-1","published":1,"updated":"2021-03-10T15:11:22.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tqw0001a5jx3e9n8mix","content":"<h2 id=\"如何将变量中的值以二进制形式打印出来\"><a href=\"#如何将变量中的值以二进制形式打印出来\" class=\"headerlink\" title=\"如何将变量中的值以二进制形式打印出来\"></a>如何将变量中的值以二进制形式打印出来</h2><p>先看源码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">uint64_to_binary</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">33</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    str<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0xffffffff</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"1\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">uint64_to_binary</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<span id=\"more\"></span>\n<p>要打印出每个位的核心思想就是一个位一个位的去比较，如何该位为 1 就记录为 “1”，如果该位为 0 就记录为 “0”，比较一次记录一次。最后输出字符串中的结果。</p>\n<p><code>0xffffffff / 2 + 1</code> 就是将内存中最高位置为 1 其他位置为 0。如果电脑是小端处理器（数据低字节保存在内存的低地址中），那么内存中存储的应该就是 <code>10000000 00000000 00000000 00000000</code>，每一次循环就把该数右移一位，内存上体现的就是 1 在一格一格的向右移动。假如我们要输出的数它在内存中实际存储是这个样子 <code>00000000 00000000 00000000 11111111</code>。</p>\n<p>第 1 次循环:<br><code>10000000 00000000 00000000 00000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code> 所以 str = “0”。</p>\n<p>第 2 次循环：<br><code>01000000 00000000 00000000 00000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code><br>所以 str = “00”</p>\n<p>……</p>\n<p>第 25 次循环：<br><code>00000000 00000000 00000000 10000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code><br>所以 str = “0000000000000000000000001”<br>……</p>\n<p>这样就把内存中每个位的值打印出来了。如果要打印的是 1 个字节的变量，就得将 <code>0xffffffff</code> 修改成 <code>0xff</code>。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>打印变量在内存的每个位是直观了解其在内存分布的方式，其实了解一个变量在内存中是怎么存储的，有利于我们解决异构 CPU 跨字节交互数据的问题。比如一台英特尔 CPU 的电脑（小端处理器）往一个 ESP32（大端处理器）上发送一个 4 字节的整型变量。电脑将 <code>unsigned int a = 255</code>, 内存中的数据(<code>0x000000ff</code>）直接发到 ESP32 上，ESP32 收到数据后直接内存拷贝到ESP32 中的 <code>unsigned int b</code> 变量上，则 b 的数值就为 <code>4278190080</code>，这样就很有可能造成程序运行错误。特别是这种跨平台跨字节交互数据的情况应该特别小心，做个大小端转换就没事了。说的容易，但是理解数据在内存中实际的存储情况才是关键。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何将变量中的值以二进制形式打印出来\"><a href=\"#如何将变量中的值以二进制形式打印出来\" class=\"headerlink\" title=\"如何将变量中的值以二进制形式打印出来\"></a>如何将变量中的值以二进制形式打印出来</h2><p>先看源码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">uint64_to_binary</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">33</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    str<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0xffffffff</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"1\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">uint64_to_binary</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","more":"<p>要打印出每个位的核心思想就是一个位一个位的去比较，如何该位为 1 就记录为 “1”，如果该位为 0 就记录为 “0”，比较一次记录一次。最后输出字符串中的结果。</p>\n<p><code>0xffffffff / 2 + 1</code> 就是将内存中最高位置为 1 其他位置为 0。如果电脑是小端处理器（数据低字节保存在内存的低地址中），那么内存中存储的应该就是 <code>10000000 00000000 00000000 00000000</code>，每一次循环就把该数右移一位，内存上体现的就是 1 在一格一格的向右移动。假如我们要输出的数它在内存中实际存储是这个样子 <code>00000000 00000000 00000000 11111111</code>。</p>\n<p>第 1 次循环:<br><code>10000000 00000000 00000000 00000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code> 所以 str = “0”。</p>\n<p>第 2 次循环：<br><code>01000000 00000000 00000000 00000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code><br>所以 str = “00”</p>\n<p>……</p>\n<p>第 25 次循环：<br><code>00000000 00000000 00000000 10000000</code> &amp; <code>00000000 00000000 00000000 11111111</code> = <code>00000000 00000000 00000000 00000000</code><br>所以 str = “0000000000000000000000001”<br>……</p>\n<p>这样就把内存中每个位的值打印出来了。如果要打印的是 1 个字节的变量，就得将 <code>0xffffffff</code> 修改成 <code>0xff</code>。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>打印变量在内存的每个位是直观了解其在内存分布的方式，其实了解一个变量在内存中是怎么存储的，有利于我们解决异构 CPU 跨字节交互数据的问题。比如一台英特尔 CPU 的电脑（小端处理器）往一个 ESP32（大端处理器）上发送一个 4 字节的整型变量。电脑将 <code>unsigned int a = 255</code>, 内存中的数据(<code>0x000000ff</code>）直接发到 ESP32 上，ESP32 收到数据后直接内存拷贝到ESP32 中的 <code>unsigned int b</code> 变量上，则 b 的数值就为 <code>4278190080</code>，这样就很有可能造成程序运行错误。特别是这种跨平台跨字节交互数据的情况应该特别小心，做个大小端转换就没事了。说的容易，但是理解数据在内存中实际的存储情况才是关键。</p>"},{"title":"一键部署小鹤音形方案","date":"2018-12-31T16:00:00.000Z","_content":"### 部署原理\n1. 安装 Fcitx 输入框架\n2. 安装 Rime 输入法\n3. 部署音形方案\n\n**Fcitx** (Flexible Input Method Framework) ──即小企鹅输入法，它是一个以 **GPL** 方式发布的输入法平台,可以通过安装引擎支持多种输入法，支持简入繁出，是在 Linux 操作系统中常用的中文输入法。它的优点是，短小精悍、跟程序的兼容性比较好。\n\n<!--more-->\n**Rime** 是一种中文输入法引擎是一种被广泛支持的输入法。**Rime** 输入法引擎可以被用在 **IBus** 和 **Fcitx** 输入框架下。\n\n这也就是说小鹤音形只是一种输入法方案，并不是输入法。我们可以将这个方案挂接在 **Rime** 输入法下。**ibus-rime** 和 **fcitx-rime** 都可以部署音形方案。\n\n该脚本就是在 **fcitx-rime** 这种模式下部署的小鹤音形方案。\n\n### 演示\n![example](https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/example.gif)\n\n### 手动安装演示\n[bilibili](https://bilibili.com/video/av46403021)\n\n### 安装\n该一键安装脚本只适用于 Debian、Ubuntu、Centos 系统。\n直接在终端下执行以下命令就是了。该项目地址 [github](https://github.com/Caffreyfans/flypy-install)\n\n```bash\nwget -O install.sh https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/install.sh && sudo chmod +x install.sh && ./install.sh\n```\n","source":"_posts/Flypy一键部署.md","raw":"---\ntitle: 一键部署小鹤音形方案\ndate: 2019-01-01\ncategories: Linux\n\n---\n### 部署原理\n1. 安装 Fcitx 输入框架\n2. 安装 Rime 输入法\n3. 部署音形方案\n\n**Fcitx** (Flexible Input Method Framework) ──即小企鹅输入法，它是一个以 **GPL** 方式发布的输入法平台,可以通过安装引擎支持多种输入法，支持简入繁出，是在 Linux 操作系统中常用的中文输入法。它的优点是，短小精悍、跟程序的兼容性比较好。\n\n<!--more-->\n**Rime** 是一种中文输入法引擎是一种被广泛支持的输入法。**Rime** 输入法引擎可以被用在 **IBus** 和 **Fcitx** 输入框架下。\n\n这也就是说小鹤音形只是一种输入法方案，并不是输入法。我们可以将这个方案挂接在 **Rime** 输入法下。**ibus-rime** 和 **fcitx-rime** 都可以部署音形方案。\n\n该脚本就是在 **fcitx-rime** 这种模式下部署的小鹤音形方案。\n\n### 演示\n![example](https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/example.gif)\n\n### 手动安装演示\n[bilibili](https://bilibili.com/video/av46403021)\n\n### 安装\n该一键安装脚本只适用于 Debian、Ubuntu、Centos 系统。\n直接在终端下执行以下命令就是了。该项目地址 [github](https://github.com/Caffreyfans/flypy-install)\n\n```bash\nwget -O install.sh https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/install.sh && sudo chmod +x install.sh && ./install.sh\n```\n","slug":"Flypy一键部署","published":1,"updated":"2021-03-10T15:11:27.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tr10003a5jx67ut4e9h","content":"<h3 id=\"部署原理\"><a href=\"#部署原理\" class=\"headerlink\" title=\"部署原理\"></a>部署原理</h3><ol>\n<li>安装 Fcitx 输入框架</li>\n<li>安装 Rime 输入法</li>\n<li>部署音形方案</li>\n</ol>\n<p><strong>Fcitx</strong> (Flexible Input Method Framework) ──即小企鹅输入法，它是一个以 <strong>GPL</strong> 方式发布的输入法平台,可以通过安装引擎支持多种输入法，支持简入繁出，是在 Linux 操作系统中常用的中文输入法。它的优点是，短小精悍、跟程序的兼容性比较好。</p>\n<span id=\"more\"></span>\n<p><strong>Rime</strong> 是一种中文输入法引擎是一种被广泛支持的输入法。<strong>Rime</strong> 输入法引擎可以被用在 <strong>IBus</strong> 和 <strong>Fcitx</strong> 输入框架下。</p>\n<p>这也就是说小鹤音形只是一种输入法方案，并不是输入法。我们可以将这个方案挂接在 <strong>Rime</strong> 输入法下。<strong>ibus-rime</strong> 和 <strong>fcitx-rime</strong> 都可以部署音形方案。</p>\n<p>该脚本就是在 <strong>fcitx-rime</strong> 这种模式下部署的小鹤音形方案。</p>\n<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3><p><img src=\"https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/example.gif\" alt=\"example\"></p>\n<h3 id=\"手动安装演示\"><a href=\"#手动安装演示\" class=\"headerlink\" title=\"手动安装演示\"></a>手动安装演示</h3><p><a href=\"https://bilibili.com/video/av46403021\">bilibili</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>该一键安装脚本只适用于 Debian、Ubuntu、Centos 系统。<br>直接在终端下执行以下命令就是了。该项目地址 <a href=\"https://github.com/Caffreyfans/flypy-install\">github</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> -O install.sh https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/install.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x install.sh <span class=\"token operator\">&amp;&amp;</span> ./install.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"部署原理\"><a href=\"#部署原理\" class=\"headerlink\" title=\"部署原理\"></a>部署原理</h3><ol>\n<li>安装 Fcitx 输入框架</li>\n<li>安装 Rime 输入法</li>\n<li>部署音形方案</li>\n</ol>\n<p><strong>Fcitx</strong> (Flexible Input Method Framework) ──即小企鹅输入法，它是一个以 <strong>GPL</strong> 方式发布的输入法平台,可以通过安装引擎支持多种输入法，支持简入繁出，是在 Linux 操作系统中常用的中文输入法。它的优点是，短小精悍、跟程序的兼容性比较好。</p>","more":"<p><strong>Rime</strong> 是一种中文输入法引擎是一种被广泛支持的输入法。<strong>Rime</strong> 输入法引擎可以被用在 <strong>IBus</strong> 和 <strong>Fcitx</strong> 输入框架下。</p>\n<p>这也就是说小鹤音形只是一种输入法方案，并不是输入法。我们可以将这个方案挂接在 <strong>Rime</strong> 输入法下。<strong>ibus-rime</strong> 和 <strong>fcitx-rime</strong> 都可以部署音形方案。</p>\n<p>该脚本就是在 <strong>fcitx-rime</strong> 这种模式下部署的小鹤音形方案。</p>\n<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3><p><img src=\"https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/example.gif\" alt=\"example\"></p>\n<h3 id=\"手动安装演示\"><a href=\"#手动安装演示\" class=\"headerlink\" title=\"手动安装演示\"></a>手动安装演示</h3><p><a href=\"https://bilibili.com/video/av46403021\">bilibili</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>该一键安装脚本只适用于 Debian、Ubuntu、Centos 系统。<br>直接在终端下执行以下命令就是了。该项目地址 <a href=\"https://github.com/Caffreyfans/flypy-install\">github</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> -O install.sh https://raw.githubusercontent.com/Caffreyfans/flypy-install/master/install.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x install.sh <span class=\"token operator\">&amp;&amp;</span> ./install.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>"},{"title":"Linux 系统下手动控制电脑风扇","date":"2018-12-18T16:00:00.000Z","_content":"\n## 命令控制简单方便\n笔记本风扇的轴承坏了，导致电脑运行时声音特别大。所以我到处在网上找资料看能不能通过手动的方法来限制风扇的转速，皇天不负有心人我还是找到了文档。风扇应该是I2C控制的，这样主板可以控制风扇的转速，风扇的转速也可以反馈到电脑。\n我们需要先找到风扇控制在 **Linux** 下的位置。我们只需要通过安装一个很小的工具就可以检测我们的电脑风扇了位置了。\n\n```bash\nsudo apt-get install lm-sensors fancontrol -y # 安装 lm-sensors fancontrol\n```\n<!--more-->\n这里讲解一下 **lm-sensors** 与 **fancontrol** 这两个工具的作用。\n\n| 工具包名 | 使用命令 | 作用 |\n| --- | --- | --- |\n| lm-sensors | sensors | 查看硬件温度 |\n| fancontrol | pwmconfig | 查找风扇位置 |\n\n安装好工具包之后我们首先通过\n```bash\nsudo pwmconfig\n```\n来找到我们风扇的位置，如果你是第一次使用它会询问你，输入 `y`  确认一下就行了。看一下执行结果\n\n| sudo pwmconfig | sensors |\n| --- | --- |\n| ![1](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/1.jpg) | ![2](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/2.jpg) |\n\n从 `sudo pwmconfig` 的执行结果来看，`Found the following PWM controls:` `hwmon3/pwm1` 那么就说明风扇的控制文件位置在 `hwmon3/pwm1` 了，那么我们直接在这个文件里直接填入控制值就可以实现手动控制电脑风扇了。\n```bash\necho 50 > /etc/class/hwmon/hwmon3/pwm1\n```\n\n风扇的转速通过 **PWM** 控制，也就是脉冲宽度调制。可以这样理解在一个周期内，高电平所占的时间长那么风扇就会转的更快，**PWM** 值可以取 0~255 之间的整数，0 就代表停止，255就代表最大转速。比如我这里查到我风扇对应的控制文件位置是 /hwmon3/pwm1，那么你就可以通过修改 **/sys/class/hwmon/hwmon3/pwm1** 文件里面的数值来改变风扇的转速了，这种办法只是暂时有效，一旦用户休眠或则注销，又得重新设置了。所以如果你想开机就让风扇转速受到控制你还得写个脚本再把它做成服务，然后让它开机执行。\n\n其实最好的解决风扇的问题就是换个风扇。换个笔记本风扇不难，去网上自己买个笔记本风扇就几十块钱，把笔记本拆开自己就换了用不了多就，要不然就找外面修理店的人帮你换。对于一般的笔记本来说超过 **50** 就算坑你了，自己可以在网上先看看你那种机型的风扇值多少。","source":"_posts/Linux控制电脑风扇.md","raw":"---\ntitle: Linux 系统下手动控制电脑风扇\ndate: 2018-12-19\ncategories: Linux\n---\n\n## 命令控制简单方便\n笔记本风扇的轴承坏了，导致电脑运行时声音特别大。所以我到处在网上找资料看能不能通过手动的方法来限制风扇的转速，皇天不负有心人我还是找到了文档。风扇应该是I2C控制的，这样主板可以控制风扇的转速，风扇的转速也可以反馈到电脑。\n我们需要先找到风扇控制在 **Linux** 下的位置。我们只需要通过安装一个很小的工具就可以检测我们的电脑风扇了位置了。\n\n```bash\nsudo apt-get install lm-sensors fancontrol -y # 安装 lm-sensors fancontrol\n```\n<!--more-->\n这里讲解一下 **lm-sensors** 与 **fancontrol** 这两个工具的作用。\n\n| 工具包名 | 使用命令 | 作用 |\n| --- | --- | --- |\n| lm-sensors | sensors | 查看硬件温度 |\n| fancontrol | pwmconfig | 查找风扇位置 |\n\n安装好工具包之后我们首先通过\n```bash\nsudo pwmconfig\n```\n来找到我们风扇的位置，如果你是第一次使用它会询问你，输入 `y`  确认一下就行了。看一下执行结果\n\n| sudo pwmconfig | sensors |\n| --- | --- |\n| ![1](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/1.jpg) | ![2](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/2.jpg) |\n\n从 `sudo pwmconfig` 的执行结果来看，`Found the following PWM controls:` `hwmon3/pwm1` 那么就说明风扇的控制文件位置在 `hwmon3/pwm1` 了，那么我们直接在这个文件里直接填入控制值就可以实现手动控制电脑风扇了。\n```bash\necho 50 > /etc/class/hwmon/hwmon3/pwm1\n```\n\n风扇的转速通过 **PWM** 控制，也就是脉冲宽度调制。可以这样理解在一个周期内，高电平所占的时间长那么风扇就会转的更快，**PWM** 值可以取 0~255 之间的整数，0 就代表停止，255就代表最大转速。比如我这里查到我风扇对应的控制文件位置是 /hwmon3/pwm1，那么你就可以通过修改 **/sys/class/hwmon/hwmon3/pwm1** 文件里面的数值来改变风扇的转速了，这种办法只是暂时有效，一旦用户休眠或则注销，又得重新设置了。所以如果你想开机就让风扇转速受到控制你还得写个脚本再把它做成服务，然后让它开机执行。\n\n其实最好的解决风扇的问题就是换个风扇。换个笔记本风扇不难，去网上自己买个笔记本风扇就几十块钱，把笔记本拆开自己就换了用不了多就，要不然就找外面修理店的人帮你换。对于一般的笔记本来说超过 **50** 就算坑你了，自己可以在网上先看看你那种机型的风扇值多少。","slug":"Linux控制电脑风扇","published":1,"updated":"2021-03-10T15:11:32.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tr50006a5jx2mgcf20e","content":"<h2 id=\"命令控制简单方便\"><a href=\"#命令控制简单方便\" class=\"headerlink\" title=\"命令控制简单方便\"></a>命令控制简单方便</h2><p>笔记本风扇的轴承坏了，导致电脑运行时声音特别大。所以我到处在网上找资料看能不能通过手动的方法来限制风扇的转速，皇天不负有心人我还是找到了文档。风扇应该是I2C控制的，这样主板可以控制风扇的转速，风扇的转速也可以反馈到电脑。<br>我们需要先找到风扇控制在 <strong>Linux</strong> 下的位置。我们只需要通过安装一个很小的工具就可以检测我们的电脑风扇了位置了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lm-sensors fancontrol -y <span class=\"token comment\"># 安装 lm-sensors fancontrol</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<span id=\"more\"></span>\n<p>这里讲解一下 <strong>lm-sensors</strong> 与 <strong>fancontrol</strong> 这两个工具的作用。</p>\n<table>\n<thead>\n<tr>\n<th>工具包名</th>\n<th>使用命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lm-sensors</td>\n<td>sensors</td>\n<td>查看硬件温度</td>\n</tr>\n<tr>\n<td>fancontrol</td>\n<td>pwmconfig</td>\n<td>查找风扇位置</td>\n</tr>\n</tbody></table>\n<p>安装好工具包之后我们首先通过</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> pwmconfig<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>来找到我们风扇的位置，如果你是第一次使用它会询问你，输入 <code>y</code>  确认一下就行了。看一下执行结果</p>\n<table>\n<thead>\n<tr>\n<th>sudo pwmconfig</th>\n<th>sensors</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/1.jpg\" alt=\"1\"></td>\n<td><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/2.jpg\" alt=\"2\"></td>\n</tr>\n</tbody></table>\n<p>从 <code>sudo pwmconfig</code> 的执行结果来看，<code>Found the following PWM controls:</code> <code>hwmon3/pwm1</code> 那么就说明风扇的控制文件位置在 <code>hwmon3/pwm1</code> 了，那么我们直接在这个文件里直接填入控制值就可以实现手动控制电脑风扇了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">50</span> <span class=\"token operator\">></span> /etc/class/hwmon/hwmon3/pwm1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>风扇的转速通过 <strong>PWM</strong> 控制，也就是脉冲宽度调制。可以这样理解在一个周期内，高电平所占的时间长那么风扇就会转的更快，<strong>PWM</strong> 值可以取 0~255 之间的整数，0 就代表停止，255就代表最大转速。比如我这里查到我风扇对应的控制文件位置是 /hwmon3/pwm1，那么你就可以通过修改 <strong>/sys/class/hwmon/hwmon3/pwm1</strong> 文件里面的数值来改变风扇的转速了，这种办法只是暂时有效，一旦用户休眠或则注销，又得重新设置了。所以如果你想开机就让风扇转速受到控制你还得写个脚本再把它做成服务，然后让它开机执行。</p>\n<p>其实最好的解决风扇的问题就是换个风扇。换个笔记本风扇不难，去网上自己买个笔记本风扇就几十块钱，把笔记本拆开自己就换了用不了多就，要不然就找外面修理店的人帮你换。对于一般的笔记本来说超过 <strong>50</strong> 就算坑你了，自己可以在网上先看看你那种机型的风扇值多少。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"命令控制简单方便\"><a href=\"#命令控制简单方便\" class=\"headerlink\" title=\"命令控制简单方便\"></a>命令控制简单方便</h2><p>笔记本风扇的轴承坏了，导致电脑运行时声音特别大。所以我到处在网上找资料看能不能通过手动的方法来限制风扇的转速，皇天不负有心人我还是找到了文档。风扇应该是I2C控制的，这样主板可以控制风扇的转速，风扇的转速也可以反馈到电脑。<br>我们需要先找到风扇控制在 <strong>Linux</strong> 下的位置。我们只需要通过安装一个很小的工具就可以检测我们的电脑风扇了位置了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lm-sensors fancontrol -y <span class=\"token comment\"># 安装 lm-sensors fancontrol</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>","more":"<p>这里讲解一下 <strong>lm-sensors</strong> 与 <strong>fancontrol</strong> 这两个工具的作用。</p>\n<table>\n<thead>\n<tr>\n<th>工具包名</th>\n<th>使用命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lm-sensors</td>\n<td>sensors</td>\n<td>查看硬件温度</td>\n</tr>\n<tr>\n<td>fancontrol</td>\n<td>pwmconfig</td>\n<td>查找风扇位置</td>\n</tr>\n</tbody></table>\n<p>安装好工具包之后我们首先通过</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> pwmconfig<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>来找到我们风扇的位置，如果你是第一次使用它会询问你，输入 <code>y</code>  确认一下就行了。看一下执行结果</p>\n<table>\n<thead>\n<tr>\n<th>sudo pwmconfig</th>\n<th>sensors</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/1.jpg\" alt=\"1\"></td>\n<td><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_2/2.jpg\" alt=\"2\"></td>\n</tr>\n</tbody></table>\n<p>从 <code>sudo pwmconfig</code> 的执行结果来看，<code>Found the following PWM controls:</code> <code>hwmon3/pwm1</code> 那么就说明风扇的控制文件位置在 <code>hwmon3/pwm1</code> 了，那么我们直接在这个文件里直接填入控制值就可以实现手动控制电脑风扇了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">50</span> <span class=\"token operator\">></span> /etc/class/hwmon/hwmon3/pwm1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>风扇的转速通过 <strong>PWM</strong> 控制，也就是脉冲宽度调制。可以这样理解在一个周期内，高电平所占的时间长那么风扇就会转的更快，<strong>PWM</strong> 值可以取 0~255 之间的整数，0 就代表停止，255就代表最大转速。比如我这里查到我风扇对应的控制文件位置是 /hwmon3/pwm1，那么你就可以通过修改 <strong>/sys/class/hwmon/hwmon3/pwm1</strong> 文件里面的数值来改变风扇的转速了，这种办法只是暂时有效，一旦用户休眠或则注销，又得重新设置了。所以如果你想开机就让风扇转速受到控制你还得写个脚本再把它做成服务，然后让它开机执行。</p>\n<p>其实最好的解决风扇的问题就是换个风扇。换个笔记本风扇不难，去网上自己买个笔记本风扇就几十块钱，把笔记本拆开自己就换了用不了多就，要不然就找外面修理店的人帮你换。对于一般的笔记本来说超过 <strong>50</strong> 就算坑你了，自己可以在网上先看看你那种机型的风扇值多少。</p>"},{"title":"SPI Flash Modes 介绍","date":"2020-12-31T16:00:00.000Z","_content":"\n该文章翻译来源为 [https://github.com/espressif/esptool/wiki/SPI-Flash-Modes](https://github.com/espressif/esptool/wiki/SPI-Flash-Modes)\n\n它主要介绍了我们烧录 ESP8266 和 ESP32 时对 SPI 接入方式该如何选择，每次我看到什么 DIO，DOUT，DIO 和 QOUT 都一脸懵B不知道该选什么，网上好像也没有什么专门讲这个的文章，至到我找网上翻到官方的文档，所以这里把它记录并翻译过来供大家参考，如果翻译错了请到 [https://github.com/Caffreyfans/Caffreyfans.github.io.git](https://github.com/Caffreyfans/Caffreyfans.github.io.git) 提交 issues 指出问题，我会即时修改。\n\n<!--more-->\nESP8266 和 ESP32 支持 4 种不同的 SPI flash 接入模式：DIO，DOUT，DIO 和 QOUT。他们可以在使用 `esptool.py write_flash` 使用 `--flash_mode` 选项。\n\n这些选择控制多少 I/O 引脚被来与 SPI 闪存芯片连接，传输数据，和用哪种 SPI 命令。\n\nESP8266 和 ESP32 在从当从 SPI 闪存芯片读或执行代码和数据时用这些命令。读取数据，然后内部缓存到芯片。\n\n## 总结\n按性能排序：\n\n|选项|模式名|引脚使用|速度(ESP8266 & ESP32)|\n| ------ | -------- | -------- | -------- |\n|qio|四路 I/O| 4 个引脚用于地址和数据|最快|\n|qout|四路输出| 4 个引脚用于数据|比 `qio` 模式约慢 15%|\n|dio|两路 I/O| 2 个引脚用于地址和数据|比 `qio` 慢约 45%|\n|dout|两路输出| 2 个引脚用于数据|比 `qio` 约慢 50%|\n\n一般来说，应该为你的设备选择最快的 flash 模式。但是不是所有设备都支持所有工作模式。详情见下列 FAQ 部分。\n\n## 工作模式描述\n### 常规 SPI\n一个传统的“单独”SPI（串行外设接口）总线使用 4 个引脚进行通信：\n* 时钟线（CLK）\n* 主出从进（MOSI）\n* 主进从出（MISO)\n* 片选（CS）\n[维基百科里有关于 SPI 的完整介绍](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)。\n\n所有这些信号都是单向的。在单独的 SPI 模式，数据通过MISO引脚从设备发送到主机，并通过MOSI引脚从主机发送到设备。\n\n正常 SPI 的最大数据速率是时钟速率（以位为单位）-所以一个 40MHz 的时钟 = 40Mbits/每秒 = 5Mbytes/每秒。\n\n### 双路 SPI\n为了提升性能，SPI 闪存厂商引进了“双路 SPI”。在双路 SPI 模式下，MOSI 和 MISO 引脚都被同时用来读取或写数据，每个时种周期为 2 位。相对于单独 SPI，一些指令就有两倍速率。\n\n在 `dout` 模式下，主机使用“双输出快速读取”（3BH）命令去读取数据。每个读取指令和读取地址都通过常规 SPI 发送到闪存芯片，但主机同时通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率读取数据。与仅使用 MISO 读取数据的单个 SPI 相比，这传数据传输速率提高了一倍。\n\n在 `dio` 模式下，主机使用“双 I/O 快速读取”（BBH）命令去读取数据。每个读取指令都通过常规 SPI 发送到闪存芯片，但地址通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率发送到闪存芯片。在这之后，主机以“双输出快读取”相同的方式读取每个时钟具有 2 位的速率。\n\n对于 ESP8266 和 ESP32，每次指令读取 32 个字节，并且 dio 模式大约快 dout 快 5%。\n\n请查阅您的特定 SPI 闪存芯片的数据表，以确定它是否支持这两个命令的一个或两个。\n\n### 四路 SPI\n为了进一步提高 SPI 闪存数据传输的性能，SPI 闪存厂商引进了“四路 SPI”模式。这种模式增加两个附加引脚（否则用于闪存芯片 WP 信号和 HOLD 信号）用于数据传输。这是使两 SPI 的数据传输速率提高一倍。\n\n并不是所有 flash 芯片都支持四路 SPI 模式，而且并不是所有 ESP8266 和 ESP32 芯片都有这些引脚连接到 SPI 闪存芯片。一些闪存芯片要求特殊的指令实现四路模式（见下方）。\n\n在 `qout` 模式，主机使用“四输出快速读取”（6BH）指令读取数据。这种命令与“双路输出快速读取”相同，只是数据读取用 4 个引脚代替了 2 个引脚，也就是每个时钟 4 位的速率。这使得传输数据实际快“双路输出快速读取”一倍。\n\n在 `qio` 模式，主机使用“四路 I/O 快速读取”（EBH）指令读取数据。这命令与“双路 I/O 快速读取”相同，每个地址和数据传输用 4 个引脚代替了 2 个引脚，也就是每个时钟周期 4 位的速率。这使得地址和数据传输速度都比“双路 I/O 快速读取”快一倍。\n\n## 常问问题\n### 为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？\n这通常是以下原因：\n* SPI 闪存芯片上的 WP 和 HOLD 引脚没有与乐鑫上的 GPIO 引脚正确连接。这些引脚必须正确连接才能让 quad 模式工作，不是所有板子和模组都连接了它们的。\n* SPI 闪存芯片不支持 quad 模式。查看 闪存芯片的数据表看它是否支持。你可以直接看闪存芯片上面印的型号或者使用 esptool.py flash 命令。\n* 此芯片型号未正确启用 Quad 模式。SPI 闪存不是标准的，每个厂商实施它们芯片的方式都不一样。大多数闪存芯片需要发送某些命令才能启用 Quad SPI 模式，这些命令会有所不同。对于 ESP8266 和 ESP32，这通常意味着芯片第一次以双路 SPI 模式启动然后软件（ESP32 的启动引导或者 ESP8266 的SDK）检测芯片类型并尝试使能四路 SPI 模式。如果具体的芯片类型不被软件支持那么它将无法进入四路模式。\n\n### 为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？\n一些 SPI 闪存芯片类型只支持“双路输出快速读取”和“四路输出快速读取”指令，而不是等效的“双路 I/O”和“四路 I/O”。\n\n### 与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？\n不是。ESP8266 和 ESP32 都是从 flash 里直接执行代码，但是，由于从闪存读取速度很慢，因此数据会透明地缓存在 RAM 中。仅在发生高速缓存未命令时发送闪存读取指令。但是，使用双路 SPI 读取重新填充缓存的速度大约是四路 SPI 的一半。\n\n如果你不能使用四路 SPI 模式，请确保你配置的最快 SPI 闪存时钟速率能够让你的板子或者模组可靠地工作。两路 I/O 模式下的 80Mhz 时钟比四路 I/O 模式下的 40HMz SPI 时钟快。\n\n### 闪存是如何与 ESP8266 或 ESP32 通信的？\n启动引导 .bin 文件，被烧录在 SPI 闪存里，头部包含闪存速度，闪存工作模式，和其他元数据。初始主机模式由 ROM 代码确定，当它在重置后会读取到该头部。esptool.py 为 `-flash_mode` 传入参数当文件被烧录到 flash 里时会更新头部。\n\n这仅确定用于从复位进行初始引导的模式。然后，在启动过程中，软件可能会不同涤配置闪存模式。\n\n比如，在 ESP32 上，如果将 ESP-IDF 配置为 qio/qout 模式，则实际上以 dio/dout 模式刷新 IDF 软件引导程序。当 ROM 代码从闪存引导该引导加载程序时，引导加载程序软件会检查闪存芯片型号，并在其余的引导过程中启用正确的四路 SPI 模式。这是因为有很多不同的方法可以在不同的芯片型号上启用四路 SPI。\n","source":"_posts/SPI Flash Modes.md","raw":"---\ntitle: SPI Flash Modes 介绍\ndate: 2021-01-01\ncategories: ESP8266 嵌入式\n---\n\n该文章翻译来源为 [https://github.com/espressif/esptool/wiki/SPI-Flash-Modes](https://github.com/espressif/esptool/wiki/SPI-Flash-Modes)\n\n它主要介绍了我们烧录 ESP8266 和 ESP32 时对 SPI 接入方式该如何选择，每次我看到什么 DIO，DOUT，DIO 和 QOUT 都一脸懵B不知道该选什么，网上好像也没有什么专门讲这个的文章，至到我找网上翻到官方的文档，所以这里把它记录并翻译过来供大家参考，如果翻译错了请到 [https://github.com/Caffreyfans/Caffreyfans.github.io.git](https://github.com/Caffreyfans/Caffreyfans.github.io.git) 提交 issues 指出问题，我会即时修改。\n\n<!--more-->\nESP8266 和 ESP32 支持 4 种不同的 SPI flash 接入模式：DIO，DOUT，DIO 和 QOUT。他们可以在使用 `esptool.py write_flash` 使用 `--flash_mode` 选项。\n\n这些选择控制多少 I/O 引脚被来与 SPI 闪存芯片连接，传输数据，和用哪种 SPI 命令。\n\nESP8266 和 ESP32 在从当从 SPI 闪存芯片读或执行代码和数据时用这些命令。读取数据，然后内部缓存到芯片。\n\n## 总结\n按性能排序：\n\n|选项|模式名|引脚使用|速度(ESP8266 & ESP32)|\n| ------ | -------- | -------- | -------- |\n|qio|四路 I/O| 4 个引脚用于地址和数据|最快|\n|qout|四路输出| 4 个引脚用于数据|比 `qio` 模式约慢 15%|\n|dio|两路 I/O| 2 个引脚用于地址和数据|比 `qio` 慢约 45%|\n|dout|两路输出| 2 个引脚用于数据|比 `qio` 约慢 50%|\n\n一般来说，应该为你的设备选择最快的 flash 模式。但是不是所有设备都支持所有工作模式。详情见下列 FAQ 部分。\n\n## 工作模式描述\n### 常规 SPI\n一个传统的“单独”SPI（串行外设接口）总线使用 4 个引脚进行通信：\n* 时钟线（CLK）\n* 主出从进（MOSI）\n* 主进从出（MISO)\n* 片选（CS）\n[维基百科里有关于 SPI 的完整介绍](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)。\n\n所有这些信号都是单向的。在单独的 SPI 模式，数据通过MISO引脚从设备发送到主机，并通过MOSI引脚从主机发送到设备。\n\n正常 SPI 的最大数据速率是时钟速率（以位为单位）-所以一个 40MHz 的时钟 = 40Mbits/每秒 = 5Mbytes/每秒。\n\n### 双路 SPI\n为了提升性能，SPI 闪存厂商引进了“双路 SPI”。在双路 SPI 模式下，MOSI 和 MISO 引脚都被同时用来读取或写数据，每个时种周期为 2 位。相对于单独 SPI，一些指令就有两倍速率。\n\n在 `dout` 模式下，主机使用“双输出快速读取”（3BH）命令去读取数据。每个读取指令和读取地址都通过常规 SPI 发送到闪存芯片，但主机同时通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率读取数据。与仅使用 MISO 读取数据的单个 SPI 相比，这传数据传输速率提高了一倍。\n\n在 `dio` 模式下，主机使用“双 I/O 快速读取”（BBH）命令去读取数据。每个读取指令都通过常规 SPI 发送到闪存芯片，但地址通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率发送到闪存芯片。在这之后，主机以“双输出快读取”相同的方式读取每个时钟具有 2 位的速率。\n\n对于 ESP8266 和 ESP32，每次指令读取 32 个字节，并且 dio 模式大约快 dout 快 5%。\n\n请查阅您的特定 SPI 闪存芯片的数据表，以确定它是否支持这两个命令的一个或两个。\n\n### 四路 SPI\n为了进一步提高 SPI 闪存数据传输的性能，SPI 闪存厂商引进了“四路 SPI”模式。这种模式增加两个附加引脚（否则用于闪存芯片 WP 信号和 HOLD 信号）用于数据传输。这是使两 SPI 的数据传输速率提高一倍。\n\n并不是所有 flash 芯片都支持四路 SPI 模式，而且并不是所有 ESP8266 和 ESP32 芯片都有这些引脚连接到 SPI 闪存芯片。一些闪存芯片要求特殊的指令实现四路模式（见下方）。\n\n在 `qout` 模式，主机使用“四输出快速读取”（6BH）指令读取数据。这种命令与“双路输出快速读取”相同，只是数据读取用 4 个引脚代替了 2 个引脚，也就是每个时钟 4 位的速率。这使得传输数据实际快“双路输出快速读取”一倍。\n\n在 `qio` 模式，主机使用“四路 I/O 快速读取”（EBH）指令读取数据。这命令与“双路 I/O 快速读取”相同，每个地址和数据传输用 4 个引脚代替了 2 个引脚，也就是每个时钟周期 4 位的速率。这使得地址和数据传输速度都比“双路 I/O 快速读取”快一倍。\n\n## 常问问题\n### 为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？\n这通常是以下原因：\n* SPI 闪存芯片上的 WP 和 HOLD 引脚没有与乐鑫上的 GPIO 引脚正确连接。这些引脚必须正确连接才能让 quad 模式工作，不是所有板子和模组都连接了它们的。\n* SPI 闪存芯片不支持 quad 模式。查看 闪存芯片的数据表看它是否支持。你可以直接看闪存芯片上面印的型号或者使用 esptool.py flash 命令。\n* 此芯片型号未正确启用 Quad 模式。SPI 闪存不是标准的，每个厂商实施它们芯片的方式都不一样。大多数闪存芯片需要发送某些命令才能启用 Quad SPI 模式，这些命令会有所不同。对于 ESP8266 和 ESP32，这通常意味着芯片第一次以双路 SPI 模式启动然后软件（ESP32 的启动引导或者 ESP8266 的SDK）检测芯片类型并尝试使能四路 SPI 模式。如果具体的芯片类型不被软件支持那么它将无法进入四路模式。\n\n### 为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？\n一些 SPI 闪存芯片类型只支持“双路输出快速读取”和“四路输出快速读取”指令，而不是等效的“双路 I/O”和“四路 I/O”。\n\n### 与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？\n不是。ESP8266 和 ESP32 都是从 flash 里直接执行代码，但是，由于从闪存读取速度很慢，因此数据会透明地缓存在 RAM 中。仅在发生高速缓存未命令时发送闪存读取指令。但是，使用双路 SPI 读取重新填充缓存的速度大约是四路 SPI 的一半。\n\n如果你不能使用四路 SPI 模式，请确保你配置的最快 SPI 闪存时钟速率能够让你的板子或者模组可靠地工作。两路 I/O 模式下的 80Mhz 时钟比四路 I/O 模式下的 40HMz SPI 时钟快。\n\n### 闪存是如何与 ESP8266 或 ESP32 通信的？\n启动引导 .bin 文件，被烧录在 SPI 闪存里，头部包含闪存速度，闪存工作模式，和其他元数据。初始主机模式由 ROM 代码确定，当它在重置后会读取到该头部。esptool.py 为 `-flash_mode` 传入参数当文件被烧录到 flash 里时会更新头部。\n\n这仅确定用于从复位进行初始引导的模式。然后，在启动过程中，软件可能会不同涤配置闪存模式。\n\n比如，在 ESP32 上，如果将 ESP-IDF 配置为 qio/qout 模式，则实际上以 dio/dout 模式刷新 IDF 软件引导程序。当 ROM 代码从闪存引导该引导加载程序时，引导加载程序软件会检查闪存芯片型号，并在其余的引导过程中启用正确的四路 SPI 模式。这是因为有很多不同的方法可以在不同的芯片型号上启用四路 SPI。\n","slug":"SPI Flash Modes","published":1,"updated":"2021-03-10T15:12:06.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tr70007a5jxdc57421f","content":"<p>该文章翻译来源为 <a href=\"https://github.com/espressif/esptool/wiki/SPI-Flash-Modes\">https://github.com/espressif/esptool/wiki/SPI-Flash-Modes</a></p>\n<p>它主要介绍了我们烧录 ESP8266 和 ESP32 时对 SPI 接入方式该如何选择，每次我看到什么 DIO，DOUT，DIO 和 QOUT 都一脸懵B不知道该选什么，网上好像也没有什么专门讲这个的文章，至到我找网上翻到官方的文档，所以这里把它记录并翻译过来供大家参考，如果翻译错了请到 <a href=\"https://github.com/Caffreyfans/Caffreyfans.github.io.git\">https://github.com/Caffreyfans/Caffreyfans.github.io.git</a> 提交 issues 指出问题，我会即时修改。</p>\n<span id=\"more\"></span>\n<p>ESP8266 和 ESP32 支持 4 种不同的 SPI flash 接入模式：DIO，DOUT，DIO 和 QOUT。他们可以在使用 <code>esptool.py write_flash</code> 使用 <code>--flash_mode</code> 选项。</p>\n<p>这些选择控制多少 I/O 引脚被来与 SPI 闪存芯片连接，传输数据，和用哪种 SPI 命令。</p>\n<p>ESP8266 和 ESP32 在从当从 SPI 闪存芯片读或执行代码和数据时用这些命令。读取数据，然后内部缓存到芯片。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>按性能排序：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>模式名</th>\n<th>引脚使用</th>\n<th>速度(ESP8266 &amp; ESP32)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>qio</td>\n<td>四路 I/O</td>\n<td>4 个引脚用于地址和数据</td>\n<td>最快</td>\n</tr>\n<tr>\n<td>qout</td>\n<td>四路输出</td>\n<td>4 个引脚用于数据</td>\n<td>比 <code>qio</code> 模式约慢 15%</td>\n</tr>\n<tr>\n<td>dio</td>\n<td>两路 I/O</td>\n<td>2 个引脚用于地址和数据</td>\n<td>比 <code>qio</code> 慢约 45%</td>\n</tr>\n<tr>\n<td>dout</td>\n<td>两路输出</td>\n<td>2 个引脚用于数据</td>\n<td>比 <code>qio</code> 约慢 50%</td>\n</tr>\n</tbody></table>\n<p>一般来说，应该为你的设备选择最快的 flash 模式。但是不是所有设备都支持所有工作模式。详情见下列 FAQ 部分。</p>\n<h2 id=\"工作模式描述\"><a href=\"#工作模式描述\" class=\"headerlink\" title=\"工作模式描述\"></a>工作模式描述</h2><h3 id=\"常规-SPI\"><a href=\"#常规-SPI\" class=\"headerlink\" title=\"常规 SPI\"></a>常规 SPI</h3><p>一个传统的“单独”SPI（串行外设接口）总线使用 4 个引脚进行通信：</p>\n<ul>\n<li>时钟线（CLK）</li>\n<li>主出从进（MOSI）</li>\n<li>主进从出（MISO)</li>\n<li>片选（CS）<br><a href=\"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface\">维基百科里有关于 SPI 的完整介绍</a>。</li>\n</ul>\n<p>所有这些信号都是单向的。在单独的 SPI 模式，数据通过MISO引脚从设备发送到主机，并通过MOSI引脚从主机发送到设备。</p>\n<p>正常 SPI 的最大数据速率是时钟速率（以位为单位）-所以一个 40MHz 的时钟 = 40Mbits/每秒 = 5Mbytes/每秒。</p>\n<h3 id=\"双路-SPI\"><a href=\"#双路-SPI\" class=\"headerlink\" title=\"双路 SPI\"></a>双路 SPI</h3><p>为了提升性能，SPI 闪存厂商引进了“双路 SPI”。在双路 SPI 模式下，MOSI 和 MISO 引脚都被同时用来读取或写数据，每个时种周期为 2 位。相对于单独 SPI，一些指令就有两倍速率。</p>\n<p>在 <code>dout</code> 模式下，主机使用“双输出快速读取”（3BH）命令去读取数据。每个读取指令和读取地址都通过常规 SPI 发送到闪存芯片，但主机同时通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率读取数据。与仅使用 MISO 读取数据的单个 SPI 相比，这传数据传输速率提高了一倍。</p>\n<p>在 <code>dio</code> 模式下，主机使用“双 I/O 快速读取”（BBH）命令去读取数据。每个读取指令都通过常规 SPI 发送到闪存芯片，但地址通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率发送到闪存芯片。在这之后，主机以“双输出快读取”相同的方式读取每个时钟具有 2 位的速率。</p>\n<p>对于 ESP8266 和 ESP32，每次指令读取 32 个字节，并且 dio 模式大约快 dout 快 5%。</p>\n<p>请查阅您的特定 SPI 闪存芯片的数据表，以确定它是否支持这两个命令的一个或两个。</p>\n<h3 id=\"四路-SPI\"><a href=\"#四路-SPI\" class=\"headerlink\" title=\"四路 SPI\"></a>四路 SPI</h3><p>为了进一步提高 SPI 闪存数据传输的性能，SPI 闪存厂商引进了“四路 SPI”模式。这种模式增加两个附加引脚（否则用于闪存芯片 WP 信号和 HOLD 信号）用于数据传输。这是使两 SPI 的数据传输速率提高一倍。</p>\n<p>并不是所有 flash 芯片都支持四路 SPI 模式，而且并不是所有 ESP8266 和 ESP32 芯片都有这些引脚连接到 SPI 闪存芯片。一些闪存芯片要求特殊的指令实现四路模式（见下方）。</p>\n<p>在 <code>qout</code> 模式，主机使用“四输出快速读取”（6BH）指令读取数据。这种命令与“双路输出快速读取”相同，只是数据读取用 4 个引脚代替了 2 个引脚，也就是每个时钟 4 位的速率。这使得传输数据实际快“双路输出快速读取”一倍。</p>\n<p>在 <code>qio</code> 模式，主机使用“四路 I/O 快速读取”（EBH）指令读取数据。这命令与“双路 I/O 快速读取”相同，每个地址和数据传输用 4 个引脚代替了 2 个引脚，也就是每个时钟周期 4 位的速率。这使得地址和数据传输速度都比“双路 I/O 快速读取”快一倍。</p>\n<h2 id=\"常问问题\"><a href=\"#常问问题\" class=\"headerlink\" title=\"常问问题\"></a>常问问题</h2><h3 id=\"为什么我的乐鑫芯片或模组不能使用-qio-或-qout-模式？\"><a href=\"#为什么我的乐鑫芯片或模组不能使用-qio-或-qout-模式？\" class=\"headerlink\" title=\"为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？\"></a>为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？</h3><p>这通常是以下原因：</p>\n<ul>\n<li>SPI 闪存芯片上的 WP 和 HOLD 引脚没有与乐鑫上的 GPIO 引脚正确连接。这些引脚必须正确连接才能让 quad 模式工作，不是所有板子和模组都连接了它们的。</li>\n<li>SPI 闪存芯片不支持 quad 模式。查看 闪存芯片的数据表看它是否支持。你可以直接看闪存芯片上面印的型号或者使用 esptool.py flash 命令。</li>\n<li>此芯片型号未正确启用 Quad 模式。SPI 闪存不是标准的，每个厂商实施它们芯片的方式都不一样。大多数闪存芯片需要发送某些命令才能启用 Quad SPI 模式，这些命令会有所不同。对于 ESP8266 和 ESP32，这通常意味着芯片第一次以双路 SPI 模式启动然后软件（ESP32 的启动引导或者 ESP8266 的SDK）检测芯片类型并尝试使能四路 SPI 模式。如果具体的芯片类型不被软件支持那么它将无法进入四路模式。</li>\n</ul>\n<h3 id=\"为什么-qout-和-dout-模式正常但是-qio-和-dio-模式不正常？\"><a href=\"#为什么-qout-和-dout-模式正常但是-qio-和-dio-模式不正常？\" class=\"headerlink\" title=\"为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？\"></a>为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？</h3><p>一些 SPI 闪存芯片类型只支持“双路输出快速读取”和“四路输出快速读取”指令，而不是等效的“双路 I/O”和“四路 I/O”。</p>\n<h3 id=\"与四路-SPI-相比，我的代码在双路-SPI-模式下的运行速度快一半吗？\"><a href=\"#与四路-SPI-相比，我的代码在双路-SPI-模式下的运行速度快一半吗？\" class=\"headerlink\" title=\"与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？\"></a>与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？</h3><p>不是。ESP8266 和 ESP32 都是从 flash 里直接执行代码，但是，由于从闪存读取速度很慢，因此数据会透明地缓存在 RAM 中。仅在发生高速缓存未命令时发送闪存读取指令。但是，使用双路 SPI 读取重新填充缓存的速度大约是四路 SPI 的一半。</p>\n<p>如果你不能使用四路 SPI 模式，请确保你配置的最快 SPI 闪存时钟速率能够让你的板子或者模组可靠地工作。两路 I/O 模式下的 80Mhz 时钟比四路 I/O 模式下的 40HMz SPI 时钟快。</p>\n<h3 id=\"闪存是如何与-ESP8266-或-ESP32-通信的？\"><a href=\"#闪存是如何与-ESP8266-或-ESP32-通信的？\" class=\"headerlink\" title=\"闪存是如何与 ESP8266 或 ESP32 通信的？\"></a>闪存是如何与 ESP8266 或 ESP32 通信的？</h3><p>启动引导 .bin 文件，被烧录在 SPI 闪存里，头部包含闪存速度，闪存工作模式，和其他元数据。初始主机模式由 ROM 代码确定，当它在重置后会读取到该头部。esptool.py 为 <code>-flash_mode</code> 传入参数当文件被烧录到 flash 里时会更新头部。</p>\n<p>这仅确定用于从复位进行初始引导的模式。然后，在启动过程中，软件可能会不同涤配置闪存模式。</p>\n<p>比如，在 ESP32 上，如果将 ESP-IDF 配置为 qio/qout 模式，则实际上以 dio/dout 模式刷新 IDF 软件引导程序。当 ROM 代码从闪存引导该引导加载程序时，引导加载程序软件会检查闪存芯片型号，并在其余的引导过程中启用正确的四路 SPI 模式。这是因为有很多不同的方法可以在不同的芯片型号上启用四路 SPI。</p>\n","site":{"data":{}},"excerpt":"<p>该文章翻译来源为 <a href=\"https://github.com/espressif/esptool/wiki/SPI-Flash-Modes\">https://github.com/espressif/esptool/wiki/SPI-Flash-Modes</a></p>\n<p>它主要介绍了我们烧录 ESP8266 和 ESP32 时对 SPI 接入方式该如何选择，每次我看到什么 DIO，DOUT，DIO 和 QOUT 都一脸懵B不知道该选什么，网上好像也没有什么专门讲这个的文章，至到我找网上翻到官方的文档，所以这里把它记录并翻译过来供大家参考，如果翻译错了请到 <a href=\"https://github.com/Caffreyfans/Caffreyfans.github.io.git\">https://github.com/Caffreyfans/Caffreyfans.github.io.git</a> 提交 issues 指出问题，我会即时修改。</p>","more":"<p>ESP8266 和 ESP32 支持 4 种不同的 SPI flash 接入模式：DIO，DOUT，DIO 和 QOUT。他们可以在使用 <code>esptool.py write_flash</code> 使用 <code>--flash_mode</code> 选项。</p>\n<p>这些选择控制多少 I/O 引脚被来与 SPI 闪存芯片连接，传输数据，和用哪种 SPI 命令。</p>\n<p>ESP8266 和 ESP32 在从当从 SPI 闪存芯片读或执行代码和数据时用这些命令。读取数据，然后内部缓存到芯片。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>按性能排序：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>模式名</th>\n<th>引脚使用</th>\n<th>速度(ESP8266 &amp; ESP32)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>qio</td>\n<td>四路 I/O</td>\n<td>4 个引脚用于地址和数据</td>\n<td>最快</td>\n</tr>\n<tr>\n<td>qout</td>\n<td>四路输出</td>\n<td>4 个引脚用于数据</td>\n<td>比 <code>qio</code> 模式约慢 15%</td>\n</tr>\n<tr>\n<td>dio</td>\n<td>两路 I/O</td>\n<td>2 个引脚用于地址和数据</td>\n<td>比 <code>qio</code> 慢约 45%</td>\n</tr>\n<tr>\n<td>dout</td>\n<td>两路输出</td>\n<td>2 个引脚用于数据</td>\n<td>比 <code>qio</code> 约慢 50%</td>\n</tr>\n</tbody></table>\n<p>一般来说，应该为你的设备选择最快的 flash 模式。但是不是所有设备都支持所有工作模式。详情见下列 FAQ 部分。</p>\n<h2 id=\"工作模式描述\"><a href=\"#工作模式描述\" class=\"headerlink\" title=\"工作模式描述\"></a>工作模式描述</h2><h3 id=\"常规-SPI\"><a href=\"#常规-SPI\" class=\"headerlink\" title=\"常规 SPI\"></a>常规 SPI</h3><p>一个传统的“单独”SPI（串行外设接口）总线使用 4 个引脚进行通信：</p>\n<ul>\n<li>时钟线（CLK）</li>\n<li>主出从进（MOSI）</li>\n<li>主进从出（MISO)</li>\n<li>片选（CS）<br><a href=\"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface\">维基百科里有关于 SPI 的完整介绍</a>。</li>\n</ul>\n<p>所有这些信号都是单向的。在单独的 SPI 模式，数据通过MISO引脚从设备发送到主机，并通过MOSI引脚从主机发送到设备。</p>\n<p>正常 SPI 的最大数据速率是时钟速率（以位为单位）-所以一个 40MHz 的时钟 = 40Mbits/每秒 = 5Mbytes/每秒。</p>\n<h3 id=\"双路-SPI\"><a href=\"#双路-SPI\" class=\"headerlink\" title=\"双路 SPI\"></a>双路 SPI</h3><p>为了提升性能，SPI 闪存厂商引进了“双路 SPI”。在双路 SPI 模式下，MOSI 和 MISO 引脚都被同时用来读取或写数据，每个时种周期为 2 位。相对于单独 SPI，一些指令就有两倍速率。</p>\n<p>在 <code>dout</code> 模式下，主机使用“双输出快速读取”（3BH）命令去读取数据。每个读取指令和读取地址都通过常规 SPI 发送到闪存芯片，但主机同时通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率读取数据。与仅使用 MISO 读取数据的单个 SPI 相比，这传数据传输速率提高了一倍。</p>\n<p>在 <code>dio</code> 模式下，主机使用“双 I/O 快速读取”（BBH）命令去读取数据。每个读取指令都通过常规 SPI 发送到闪存芯片，但地址通过 MOSI 和 MISO 引脚以每个时钟周期 2 位的速率发送到闪存芯片。在这之后，主机以“双输出快读取”相同的方式读取每个时钟具有 2 位的速率。</p>\n<p>对于 ESP8266 和 ESP32，每次指令读取 32 个字节，并且 dio 模式大约快 dout 快 5%。</p>\n<p>请查阅您的特定 SPI 闪存芯片的数据表，以确定它是否支持这两个命令的一个或两个。</p>\n<h3 id=\"四路-SPI\"><a href=\"#四路-SPI\" class=\"headerlink\" title=\"四路 SPI\"></a>四路 SPI</h3><p>为了进一步提高 SPI 闪存数据传输的性能，SPI 闪存厂商引进了“四路 SPI”模式。这种模式增加两个附加引脚（否则用于闪存芯片 WP 信号和 HOLD 信号）用于数据传输。这是使两 SPI 的数据传输速率提高一倍。</p>\n<p>并不是所有 flash 芯片都支持四路 SPI 模式，而且并不是所有 ESP8266 和 ESP32 芯片都有这些引脚连接到 SPI 闪存芯片。一些闪存芯片要求特殊的指令实现四路模式（见下方）。</p>\n<p>在 <code>qout</code> 模式，主机使用“四输出快速读取”（6BH）指令读取数据。这种命令与“双路输出快速读取”相同，只是数据读取用 4 个引脚代替了 2 个引脚，也就是每个时钟 4 位的速率。这使得传输数据实际快“双路输出快速读取”一倍。</p>\n<p>在 <code>qio</code> 模式，主机使用“四路 I/O 快速读取”（EBH）指令读取数据。这命令与“双路 I/O 快速读取”相同，每个地址和数据传输用 4 个引脚代替了 2 个引脚，也就是每个时钟周期 4 位的速率。这使得地址和数据传输速度都比“双路 I/O 快速读取”快一倍。</p>\n<h2 id=\"常问问题\"><a href=\"#常问问题\" class=\"headerlink\" title=\"常问问题\"></a>常问问题</h2><h3 id=\"为什么我的乐鑫芯片或模组不能使用-qio-或-qout-模式？\"><a href=\"#为什么我的乐鑫芯片或模组不能使用-qio-或-qout-模式？\" class=\"headerlink\" title=\"为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？\"></a>为什么我的乐鑫芯片或模组不能使用 qio 或 qout 模式？</h3><p>这通常是以下原因：</p>\n<ul>\n<li>SPI 闪存芯片上的 WP 和 HOLD 引脚没有与乐鑫上的 GPIO 引脚正确连接。这些引脚必须正确连接才能让 quad 模式工作，不是所有板子和模组都连接了它们的。</li>\n<li>SPI 闪存芯片不支持 quad 模式。查看 闪存芯片的数据表看它是否支持。你可以直接看闪存芯片上面印的型号或者使用 esptool.py flash 命令。</li>\n<li>此芯片型号未正确启用 Quad 模式。SPI 闪存不是标准的，每个厂商实施它们芯片的方式都不一样。大多数闪存芯片需要发送某些命令才能启用 Quad SPI 模式，这些命令会有所不同。对于 ESP8266 和 ESP32，这通常意味着芯片第一次以双路 SPI 模式启动然后软件（ESP32 的启动引导或者 ESP8266 的SDK）检测芯片类型并尝试使能四路 SPI 模式。如果具体的芯片类型不被软件支持那么它将无法进入四路模式。</li>\n</ul>\n<h3 id=\"为什么-qout-和-dout-模式正常但是-qio-和-dio-模式不正常？\"><a href=\"#为什么-qout-和-dout-模式正常但是-qio-和-dio-模式不正常？\" class=\"headerlink\" title=\"为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？\"></a>为什么 qout 和 dout 模式正常但是 qio 和 dio 模式不正常？</h3><p>一些 SPI 闪存芯片类型只支持“双路输出快速读取”和“四路输出快速读取”指令，而不是等效的“双路 I/O”和“四路 I/O”。</p>\n<h3 id=\"与四路-SPI-相比，我的代码在双路-SPI-模式下的运行速度快一半吗？\"><a href=\"#与四路-SPI-相比，我的代码在双路-SPI-模式下的运行速度快一半吗？\" class=\"headerlink\" title=\"与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？\"></a>与四路 SPI 相比，我的代码在双路 SPI 模式下的运行速度快一半吗？</h3><p>不是。ESP8266 和 ESP32 都是从 flash 里直接执行代码，但是，由于从闪存读取速度很慢，因此数据会透明地缓存在 RAM 中。仅在发生高速缓存未命令时发送闪存读取指令。但是，使用双路 SPI 读取重新填充缓存的速度大约是四路 SPI 的一半。</p>\n<p>如果你不能使用四路 SPI 模式，请确保你配置的最快 SPI 闪存时钟速率能够让你的板子或者模组可靠地工作。两路 I/O 模式下的 80Mhz 时钟比四路 I/O 模式下的 40HMz SPI 时钟快。</p>\n<h3 id=\"闪存是如何与-ESP8266-或-ESP32-通信的？\"><a href=\"#闪存是如何与-ESP8266-或-ESP32-通信的？\" class=\"headerlink\" title=\"闪存是如何与 ESP8266 或 ESP32 通信的？\"></a>闪存是如何与 ESP8266 或 ESP32 通信的？</h3><p>启动引导 .bin 文件，被烧录在 SPI 闪存里，头部包含闪存速度，闪存工作模式，和其他元数据。初始主机模式由 ROM 代码确定，当它在重置后会读取到该头部。esptool.py 为 <code>-flash_mode</code> 传入参数当文件被烧录到 flash 里时会更新头部。</p>\n<p>这仅确定用于从复位进行初始引导的模式。然后，在启动过程中，软件可能会不同涤配置闪存模式。</p>\n<p>比如，在 ESP32 上，如果将 ESP-IDF 配置为 qio/qout 模式，则实际上以 dio/dout 模式刷新 IDF 软件引导程序。当 ROM 代码从闪存引导该引导加载程序时，引导加载程序软件会检查闪存芯片型号，并在其余的引导过程中启用正确的四路 SPI 模式。这是因为有很多不同的方法可以在不同的芯片型号上启用四路 SPI。</p>"},{"title":"memmove 实现","date":"2020-12-20T16:00:00.000Z","_content":"\n# 一次关于 memmove 实现的记录\n有一次面试嵌入式工程师，题目中有一题为“请不使用任何函数实现 memmove 源码\"，这题我没做出来。\n\n没做出来的原因1：我没使用过 `memmove` 函数不知道其作用，只知道字面意思。\n\n没做出来原因2：就算面试官告诉我这个函数的作用是把一段内存从一个地方移动到另一个地方，我也不知道如何不用函数来实现。\n\n关于这道题我脑子里第一反映就是使用 `memcpy` 直接拷过去，但是规定是不能使用函数的，我就傻了。后面我就想要不新开一段内存，做两次复制，第一次复制是源内存中数据到新内存空间，第二次复制是新内存空间到目标地址空间。这样做不是不行，但是浪费内存空间，而且操作步骤多，浪费处理器计算力。后面面试官又提醒我说，不要开辟新的内存空间该怎么办？我回答我实在没有办法了......\n\n直接我现在看了 gcc 里的 `memmove` 的源码现在才知道自己面试不过是应该的。先看下 gcc 中的源码吧。\n\n<!--more-->\n```c\nvoid *\nmemmove (void *dest, const void *src, size_t len)\n{\n  char *d = dest;   \n  const char *s = src;\n  if (d < s)\n    while (len--)\n      *d++ = *s++;\n  else\n    {\n      char *lasts = s + (len-1);\n      char *lastd = d + (len-1);\n      while (len--)\n        *lastd-- = *lasts--;\n    }\n  return dest;\n}\n```\n现在才知道原来标准库里面的函数十分朴实，没有什么花里胡哨的操作，就是一个字节一个字节的拷贝。但是拷贝也是有前提的，如果目标地址低于源地址，就直接拷贝直接 len 为 0，这样拷贝的顺序就是正向的；如果目标地址是高于源地址的，那就需要做逆向拷贝，从最后一个字节拷贝到第一个字节来，这样做的原因就是为了避免正向拷贝的情况下，目标地址其实位置是源地址内存中的一部分，那么就会有内存覆盖情况，最终覆盖部分数据丢失，而逆向拷贝就不会。\n\n后来我也看了 `memcpy` 的源码，它其中就有内存覆盖的情况，所以当使用 `memcpy` 函数时，如果你的目标地址的起始位置是源地址空间的一部分，就会出现错误。\n\n```\n src\n  ↓\n+-------------------------------------------------+\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |\n+-------------------------------------------------+       \n| a | b | c | d | e | f | g | h | i | j |  k |  l |\n+-------------------------------------------------+\n                                  ↑\n                                 dest\n```\n上面就是 memcpy 出现内存覆盖而导致数据丢失的情况，所以我们使用 memcpy 的时候应该知道有这么种情况，即使是数据丢失也是我们期望的一部分话就不用担心该问题了。","source":"_posts/memmove.md","raw":"---\ntitle: memmove 实现\ndate: 2020-12-21    \ncategories: 面试题记录\n---\n\n# 一次关于 memmove 实现的记录\n有一次面试嵌入式工程师，题目中有一题为“请不使用任何函数实现 memmove 源码\"，这题我没做出来。\n\n没做出来的原因1：我没使用过 `memmove` 函数不知道其作用，只知道字面意思。\n\n没做出来原因2：就算面试官告诉我这个函数的作用是把一段内存从一个地方移动到另一个地方，我也不知道如何不用函数来实现。\n\n关于这道题我脑子里第一反映就是使用 `memcpy` 直接拷过去，但是规定是不能使用函数的，我就傻了。后面我就想要不新开一段内存，做两次复制，第一次复制是源内存中数据到新内存空间，第二次复制是新内存空间到目标地址空间。这样做不是不行，但是浪费内存空间，而且操作步骤多，浪费处理器计算力。后面面试官又提醒我说，不要开辟新的内存空间该怎么办？我回答我实在没有办法了......\n\n直接我现在看了 gcc 里的 `memmove` 的源码现在才知道自己面试不过是应该的。先看下 gcc 中的源码吧。\n\n<!--more-->\n```c\nvoid *\nmemmove (void *dest, const void *src, size_t len)\n{\n  char *d = dest;   \n  const char *s = src;\n  if (d < s)\n    while (len--)\n      *d++ = *s++;\n  else\n    {\n      char *lasts = s + (len-1);\n      char *lastd = d + (len-1);\n      while (len--)\n        *lastd-- = *lasts--;\n    }\n  return dest;\n}\n```\n现在才知道原来标准库里面的函数十分朴实，没有什么花里胡哨的操作，就是一个字节一个字节的拷贝。但是拷贝也是有前提的，如果目标地址低于源地址，就直接拷贝直接 len 为 0，这样拷贝的顺序就是正向的；如果目标地址是高于源地址的，那就需要做逆向拷贝，从最后一个字节拷贝到第一个字节来，这样做的原因就是为了避免正向拷贝的情况下，目标地址其实位置是源地址内存中的一部分，那么就会有内存覆盖情况，最终覆盖部分数据丢失，而逆向拷贝就不会。\n\n后来我也看了 `memcpy` 的源码，它其中就有内存覆盖的情况，所以当使用 `memcpy` 函数时，如果你的目标地址的起始位置是源地址空间的一部分，就会出现错误。\n\n```\n src\n  ↓\n+-------------------------------------------------+\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |\n+-------------------------------------------------+       \n| a | b | c | d | e | f | g | h | i | j |  k |  l |\n+-------------------------------------------------+\n                                  ↑\n                                 dest\n```\n上面就是 memcpy 出现内存覆盖而导致数据丢失的情况，所以我们使用 memcpy 的时候应该知道有这么种情况，即使是数据丢失也是我们期望的一部分话就不用担心该问题了。","slug":"memmove","published":1,"updated":"2021-03-10T15:11:37.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tr80008a5jxb34bcphl","content":"<h1 id=\"一次关于-memmove-实现的记录\"><a href=\"#一次关于-memmove-实现的记录\" class=\"headerlink\" title=\"一次关于 memmove 实现的记录\"></a>一次关于 memmove 实现的记录</h1><p>有一次面试嵌入式工程师，题目中有一题为“请不使用任何函数实现 memmove 源码”，这题我没做出来。</p>\n<p>没做出来的原因1：我没使用过 <code>memmove</code> 函数不知道其作用，只知道字面意思。</p>\n<p>没做出来原因2：就算面试官告诉我这个函数的作用是把一段内存从一个地方移动到另一个地方，我也不知道如何不用函数来实现。</p>\n<p>关于这道题我脑子里第一反映就是使用 <code>memcpy</code> 直接拷过去，但是规定是不能使用函数的，我就傻了。后面我就想要不新开一段内存，做两次复制，第一次复制是源内存中数据到新内存空间，第二次复制是新内存空间到目标地址空间。这样做不是不行，但是浪费内存空间，而且操作步骤多，浪费处理器计算力。后面面试官又提醒我说，不要开辟新的内存空间该怎么办？我回答我实在没有办法了……</p>\n<p>直接我现在看了 gcc 里的 <code>memmove</code> 的源码现在才知道自己面试不过是应该的。先看下 gcc 中的源码吧。</p>\n<span id=\"more\"></span>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">memmove</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> len<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>d <span class=\"token operator\">=</span> dest<span class=\"token punctuation\">;</span>   \n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s <span class=\"token operator\">=</span> src<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">*</span>d<span class=\"token operator\">++</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>s<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>lasts <span class=\"token operator\">=</span> s <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>lastd <span class=\"token operator\">=</span> d <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">*</span>lastd<span class=\"token operator\">--</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>lasts<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> dest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在才知道原来标准库里面的函数十分朴实，没有什么花里胡哨的操作，就是一个字节一个字节的拷贝。但是拷贝也是有前提的，如果目标地址低于源地址，就直接拷贝直接 len 为 0，这样拷贝的顺序就是正向的；如果目标地址是高于源地址的，那就需要做逆向拷贝，从最后一个字节拷贝到第一个字节来，这样做的原因就是为了避免正向拷贝的情况下，目标地址其实位置是源地址内存中的一部分，那么就会有内存覆盖情况，最终覆盖部分数据丢失，而逆向拷贝就不会。</p>\n<p>后来我也看了 <code>memcpy</code> 的源码，它其中就有内存覆盖的情况，所以当使用 <code>memcpy</code> 函数时，如果你的目标地址的起始位置是源地址空间的一部分，就会出现错误。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> src\n  ↓\n+-------------------------------------------------+\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |\n+-------------------------------------------------+       \n| a | b | c | d | e | f | g | h | i | j |  k |  l |\n+-------------------------------------------------+\n                                  ↑\n                                 dest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面就是 memcpy 出现内存覆盖而导致数据丢失的情况，所以我们使用 memcpy 的时候应该知道有这么种情况，即使是数据丢失也是我们期望的一部分话就不用担心该问题了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一次关于-memmove-实现的记录\"><a href=\"#一次关于-memmove-实现的记录\" class=\"headerlink\" title=\"一次关于 memmove 实现的记录\"></a>一次关于 memmove 实现的记录</h1><p>有一次面试嵌入式工程师，题目中有一题为“请不使用任何函数实现 memmove 源码”，这题我没做出来。</p>\n<p>没做出来的原因1：我没使用过 <code>memmove</code> 函数不知道其作用，只知道字面意思。</p>\n<p>没做出来原因2：就算面试官告诉我这个函数的作用是把一段内存从一个地方移动到另一个地方，我也不知道如何不用函数来实现。</p>\n<p>关于这道题我脑子里第一反映就是使用 <code>memcpy</code> 直接拷过去，但是规定是不能使用函数的，我就傻了。后面我就想要不新开一段内存，做两次复制，第一次复制是源内存中数据到新内存空间，第二次复制是新内存空间到目标地址空间。这样做不是不行，但是浪费内存空间，而且操作步骤多，浪费处理器计算力。后面面试官又提醒我说，不要开辟新的内存空间该怎么办？我回答我实在没有办法了……</p>\n<p>直接我现在看了 gcc 里的 <code>memmove</code> 的源码现在才知道自己面试不过是应该的。先看下 gcc 中的源码吧。</p>","more":"<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">memmove</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> len<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>d <span class=\"token operator\">=</span> dest<span class=\"token punctuation\">;</span>   \n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s <span class=\"token operator\">=</span> src<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">*</span>d<span class=\"token operator\">++</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>s<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>lasts <span class=\"token operator\">=</span> s <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>lastd <span class=\"token operator\">=</span> d <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">*</span>lastd<span class=\"token operator\">--</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>lasts<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> dest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在才知道原来标准库里面的函数十分朴实，没有什么花里胡哨的操作，就是一个字节一个字节的拷贝。但是拷贝也是有前提的，如果目标地址低于源地址，就直接拷贝直接 len 为 0，这样拷贝的顺序就是正向的；如果目标地址是高于源地址的，那就需要做逆向拷贝，从最后一个字节拷贝到第一个字节来，这样做的原因就是为了避免正向拷贝的情况下，目标地址其实位置是源地址内存中的一部分，那么就会有内存覆盖情况，最终覆盖部分数据丢失，而逆向拷贝就不会。</p>\n<p>后来我也看了 <code>memcpy</code> 的源码，它其中就有内存覆盖的情况，所以当使用 <code>memcpy</code> 函数时，如果你的目标地址的起始位置是源地址空间的一部分，就会出现错误。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> src\n  ↓\n+-------------------------------------------------+\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |\n+-------------------------------------------------+       \n| a | b | c | d | e | f | g | h | i | j |  k |  l |\n+-------------------------------------------------+\n                                  ↑\n                                 dest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面就是 memcpy 出现内存覆盖而导致数据丢失的情况，所以我们使用 memcpy 的时候应该知道有这么种情况，即使是数据丢失也是我们期望的一部分话就不用担心该问题了。</p>"},{"title":"指针与下标","date":"2020-12-19T16:00:00.000Z","_content":"如何可以互换地使用指针表达式与表达式，应该使用哪种更为合适？对于大多数而言下标更容易理解，尤其在多维数组中。所以在可读性方面，下标更有优势。而我本人的编程习惯也倾向于使用下标,而且还一直以为下标与指针表达式等价。直到看了《C与指针》才知道，其实这两者有效率上的区别。\n\n<!--more-->\n**假定两种方法都是正确的，下标绝对不会比指针更有效率，但指针有时会比下标更有效率**\n为了理解这个效率问题，让我们来研究两个循环，他们用于执行相同的任务。首先，我们使用下标方案将数组中的所有元素都设置为 0。\n```c\nint array[10], a;\nfor (a = 0; a < 10; i++)\n    array[a] = 0;\n```\n为了对下标表达式求值,编译器在程序中插入指令,取得 a 的值，并把它与整数的长度（也就是 4）相乘。这个乘法需要花费一定的时间与空间。\n\n现在再让我们看看下面这个循环，它所执行的任务和前面的循环完全一样。\n```c\nint array[10], *ap;\nfor (ap = array; ap < array + 10; ap++)\n    *ap = 0;\n```\n尽管这里并不存在下标，但还是存在乘法运算。现在，这个乘法运算出现在 for 语句的调整部分。1 这个值必须与整数的长度想乘，然后再与指针相加。但这里存在一个重大的区别：这个乘法只在编译时执行一次——程序现在包含了一条指令，把 4 与指针相加。程序在运行时没有乘法的换算。\n\n这个例子说明了指针比下标更有效率的场合，因为了乘法的换算。在绝大数机器上，程序就会更小、更快一些。","source":"_posts/pointer_and_index.md","raw":"---\ntitle: 指针与下标\ndate: 2020-12-20\ncategories: C\n---\n如何可以互换地使用指针表达式与表达式，应该使用哪种更为合适？对于大多数而言下标更容易理解，尤其在多维数组中。所以在可读性方面，下标更有优势。而我本人的编程习惯也倾向于使用下标,而且还一直以为下标与指针表达式等价。直到看了《C与指针》才知道，其实这两者有效率上的区别。\n\n<!--more-->\n**假定两种方法都是正确的，下标绝对不会比指针更有效率，但指针有时会比下标更有效率**\n为了理解这个效率问题，让我们来研究两个循环，他们用于执行相同的任务。首先，我们使用下标方案将数组中的所有元素都设置为 0。\n```c\nint array[10], a;\nfor (a = 0; a < 10; i++)\n    array[a] = 0;\n```\n为了对下标表达式求值,编译器在程序中插入指令,取得 a 的值，并把它与整数的长度（也就是 4）相乘。这个乘法需要花费一定的时间与空间。\n\n现在再让我们看看下面这个循环，它所执行的任务和前面的循环完全一样。\n```c\nint array[10], *ap;\nfor (ap = array; ap < array + 10; ap++)\n    *ap = 0;\n```\n尽管这里并不存在下标，但还是存在乘法运算。现在，这个乘法运算出现在 for 语句的调整部分。1 这个值必须与整数的长度想乘，然后再与指针相加。但这里存在一个重大的区别：这个乘法只在编译时执行一次——程序现在包含了一条指令，把 4 与指针相加。程序在运行时没有乘法的换算。\n\n这个例子说明了指针比下标更有效率的场合，因为了乘法的换算。在绝大数机器上，程序就会更小、更快一些。","slug":"pointer_and_index","published":1,"updated":"2021-03-10T15:11:47.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2tra000aa5jx4ubbdd0s","content":"<p>如何可以互换地使用指针表达式与表达式，应该使用哪种更为合适？对于大多数而言下标更容易理解，尤其在多维数组中。所以在可读性方面，下标更有优势。而我本人的编程习惯也倾向于使用下标,而且还一直以为下标与指针表达式等价。直到看了《C与指针》才知道，其实这两者有效率上的区别。</p>\n<span id=\"more\"></span>\n<p><strong>假定两种方法都是正确的，下标绝对不会比指针更有效率，但指针有时会比下标更有效率</strong><br>为了理解这个效率问题，让我们来研究两个循环，他们用于执行相同的任务。首先，我们使用下标方案将数组中的所有元素都设置为 0。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    array<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>为了对下标表达式求值,编译器在程序中插入指令,取得 a 的值，并把它与整数的长度（也就是 4）相乘。这个乘法需要花费一定的时间与空间。</p>\n<p>现在再让我们看看下面这个循环，它所执行的任务和前面的循环完全一样。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>ap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>ap <span class=\"token operator\">=</span> array<span class=\"token punctuation\">;</span> ap <span class=\"token operator\">&lt;</span> array <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> ap<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">*</span>ap <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>尽管这里并不存在下标，但还是存在乘法运算。现在，这个乘法运算出现在 for 语句的调整部分。1 这个值必须与整数的长度想乘，然后再与指针相加。但这里存在一个重大的区别：这个乘法只在编译时执行一次——程序现在包含了一条指令，把 4 与指针相加。程序在运行时没有乘法的换算。</p>\n<p>这个例子说明了指针比下标更有效率的场合，因为了乘法的换算。在绝大数机器上，程序就会更小、更快一些。</p>\n","site":{"data":{}},"excerpt":"<p>如何可以互换地使用指针表达式与表达式，应该使用哪种更为合适？对于大多数而言下标更容易理解，尤其在多维数组中。所以在可读性方面，下标更有优势。而我本人的编程习惯也倾向于使用下标,而且还一直以为下标与指针表达式等价。直到看了《C与指针》才知道，其实这两者有效率上的区别。</p>","more":"<p><strong>假定两种方法都是正确的，下标绝对不会比指针更有效率，但指针有时会比下标更有效率</strong><br>为了理解这个效率问题，让我们来研究两个循环，他们用于执行相同的任务。首先，我们使用下标方案将数组中的所有元素都设置为 0。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    array<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>为了对下标表达式求值,编译器在程序中插入指令,取得 a 的值，并把它与整数的长度（也就是 4）相乘。这个乘法需要花费一定的时间与空间。</p>\n<p>现在再让我们看看下面这个循环，它所执行的任务和前面的循环完全一样。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>ap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>ap <span class=\"token operator\">=</span> array<span class=\"token punctuation\">;</span> ap <span class=\"token operator\">&lt;</span> array <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> ap<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">*</span>ap <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>尽管这里并不存在下标，但还是存在乘法运算。现在，这个乘法运算出现在 for 语句的调整部分。1 这个值必须与整数的长度想乘，然后再与指针相加。但这里存在一个重大的区别：这个乘法只在编译时执行一次——程序现在包含了一条指令，把 4 与指针相加。程序在运行时没有乘法的换算。</p>\n<p>这个例子说明了指针比下标更有效率的场合，因为了乘法的换算。在绝大数机器上，程序就会更小、更快一些。</p>"},{"title":"利用Docker搭建Samba服务","date":"2019-03-16T16:00:00.000Z","_content":"### 前述\n能看到搜索到这篇文章想必你已经了解了什么是 **Docker**，什么是 **Samba** 了。如果你不了解这两样东西，那么我建议你在网上搜索一下，仔细了解下这两样比较实用的工具。\n\n我就以我通俗的语言简述下这两样东西，**Docker** 是一种标准化的软件单元，说白了有了它，我们使用一个软件就像手机上使用 **APP** 一样，我们不用管这个软件怎么写的，以及运行这个软件需要什么环境啊。当我们手机需要某个软件的时候，我们都直接在应用商店里直接搜索下载某个软件，然后打开运行。**Docker** 跟这种道理差不多，如果我们需要某个软件，那么我们也直接从镜像仓库里直接拉取（手机上我们说下载应用，**Docker** 使用的是 **pull** 命令那么就该翻译成拉取，道理是一样的），手机上我们下载的称做安装包，**Docker** 中对应就是应该是镜像。手机上下载好软件包后安装的这个步骤对应 **Docker** 中就应该是创建容器的这个步骤了，创建容器的时候只需要你配置一些简单的参数。手机安装包在你的手机上能下载并安装，在别人的手机上也一样。**Docker** 也是如此，同一镜像都可以在同样的 **CPU** 架构下创建容器运行。只要你装了 **Docker** 就不在乎你用的什么系统了，就只有 **CPU** 架构的区分了。这样就大大为应用的部署提供了方便，而且通常来说一个容器是非常\t轻量的，创建和删除它都非常的方便。这就是为什么要使用 **Docker** 来搭建 **Samba** 服务的原因了。\n\n<!--more-->\n至于 **Samba** 就是适用与 **Linux** 和 **Unix** 的标准 **Windows** 互操作性程序套件。有了它我们就可以把任意文件在我们的 **Windows** 系统和 **Linux** 系统中任意的转移了。\n\n### 启动容器\n```bash\nsudo docker run -it --name samba --restart always \\\n\t--net host -p 139:139 -p 455:455  -v /home:/shared \\\n\t-d dperson/samba -s \"share;/shared;yes;no;yes\" -n\n```\n我们来说下每个参数的含义:\n\nsudo -> 使用 root 权限执行后续命令\n\ndocker -> docker 命令\n\nrun -> docker 命令的参数，用于启动容器\n\n-i -> 让容器的标准保持打开\n\n-t -> 为容器分配一个伪终端\n\n--name -> 容器名， samba 这里就给该容器命名为 samba\n\n--restart -> 重启参数，always 我们这里选的就是一直重启，只要是启动失败了它就会不断的重启，这里的作用主要是为了开机启动\n\n--net -> 加入网络，host 就是说该容器加入到主机网络中\n\n-p -> 端口映射，139、455 是 **Samba** 协议的端口\n\n-v -> 文件映射， /home:/shared 就是把主机中的 /home 目录映射到 容器中的 /shared 目录中\n\n-d -> 后台运行\n\ndperson/samba 使用的镜像名，当我们的本地没有该镜像时，它会自动去网络仓库里搜索并拉取， 镜像可以是我们自己写的，也可以是别人写好的，我们这里所使用的就是别人已经写的了的\n\n这上面的都是 **Docker** 命令中的参数，而镜像名后面跟的参数就是该镜像自己设定的参数了，有的镜像可能有，有的镜像可能也没有。这主要就要看这个镜像是怎么写的了\n\n-s -> 设置共享目录， \"share;/shared;yes;no;yes\" 给共享的文件夹取名为 share，共享的是容器中的 shared 文件夹（前面的参数就已经把主机中的文件映射到这里了），可见，非只读，启用访客\n\n***关于更多的 dperson/samba 详细设置请见 [dperson/samba](https://hub.docker.com/r/dperson/samba/)***\n\n","source":"_posts/利用Docker搭建Samba服务.md","raw":"---\ntitle: 利用Docker搭建Samba服务\ndate: 2019-03-17\ncategories: Linux\n---\n### 前述\n能看到搜索到这篇文章想必你已经了解了什么是 **Docker**，什么是 **Samba** 了。如果你不了解这两样东西，那么我建议你在网上搜索一下，仔细了解下这两样比较实用的工具。\n\n我就以我通俗的语言简述下这两样东西，**Docker** 是一种标准化的软件单元，说白了有了它，我们使用一个软件就像手机上使用 **APP** 一样，我们不用管这个软件怎么写的，以及运行这个软件需要什么环境啊。当我们手机需要某个软件的时候，我们都直接在应用商店里直接搜索下载某个软件，然后打开运行。**Docker** 跟这种道理差不多，如果我们需要某个软件，那么我们也直接从镜像仓库里直接拉取（手机上我们说下载应用，**Docker** 使用的是 **pull** 命令那么就该翻译成拉取，道理是一样的），手机上我们下载的称做安装包，**Docker** 中对应就是应该是镜像。手机上下载好软件包后安装的这个步骤对应 **Docker** 中就应该是创建容器的这个步骤了，创建容器的时候只需要你配置一些简单的参数。手机安装包在你的手机上能下载并安装，在别人的手机上也一样。**Docker** 也是如此，同一镜像都可以在同样的 **CPU** 架构下创建容器运行。只要你装了 **Docker** 就不在乎你用的什么系统了，就只有 **CPU** 架构的区分了。这样就大大为应用的部署提供了方便，而且通常来说一个容器是非常\t轻量的，创建和删除它都非常的方便。这就是为什么要使用 **Docker** 来搭建 **Samba** 服务的原因了。\n\n<!--more-->\n至于 **Samba** 就是适用与 **Linux** 和 **Unix** 的标准 **Windows** 互操作性程序套件。有了它我们就可以把任意文件在我们的 **Windows** 系统和 **Linux** 系统中任意的转移了。\n\n### 启动容器\n```bash\nsudo docker run -it --name samba --restart always \\\n\t--net host -p 139:139 -p 455:455  -v /home:/shared \\\n\t-d dperson/samba -s \"share;/shared;yes;no;yes\" -n\n```\n我们来说下每个参数的含义:\n\nsudo -> 使用 root 权限执行后续命令\n\ndocker -> docker 命令\n\nrun -> docker 命令的参数，用于启动容器\n\n-i -> 让容器的标准保持打开\n\n-t -> 为容器分配一个伪终端\n\n--name -> 容器名， samba 这里就给该容器命名为 samba\n\n--restart -> 重启参数，always 我们这里选的就是一直重启，只要是启动失败了它就会不断的重启，这里的作用主要是为了开机启动\n\n--net -> 加入网络，host 就是说该容器加入到主机网络中\n\n-p -> 端口映射，139、455 是 **Samba** 协议的端口\n\n-v -> 文件映射， /home:/shared 就是把主机中的 /home 目录映射到 容器中的 /shared 目录中\n\n-d -> 后台运行\n\ndperson/samba 使用的镜像名，当我们的本地没有该镜像时，它会自动去网络仓库里搜索并拉取， 镜像可以是我们自己写的，也可以是别人写好的，我们这里所使用的就是别人已经写的了的\n\n这上面的都是 **Docker** 命令中的参数，而镜像名后面跟的参数就是该镜像自己设定的参数了，有的镜像可能有，有的镜像可能也没有。这主要就要看这个镜像是怎么写的了\n\n-s -> 设置共享目录， \"share;/shared;yes;no;yes\" 给共享的文件夹取名为 share，共享的是容器中的 shared 文件夹（前面的参数就已经把主机中的文件映射到这里了），可见，非只读，启用访客\n\n***关于更多的 dperson/samba 详细设置请见 [dperson/samba](https://hub.docker.com/r/dperson/samba/)***\n\n","slug":"利用Docker搭建Samba服务","published":1,"updated":"2021-03-10T15:12:10.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2trb000ba5jx780edljg","content":"<h3 id=\"前述\"><a href=\"#前述\" class=\"headerlink\" title=\"前述\"></a>前述</h3><p>能看到搜索到这篇文章想必你已经了解了什么是 <strong>Docker</strong>，什么是 <strong>Samba</strong> 了。如果你不了解这两样东西，那么我建议你在网上搜索一下，仔细了解下这两样比较实用的工具。</p>\n<p>我就以我通俗的语言简述下这两样东西，<strong>Docker</strong> 是一种标准化的软件单元，说白了有了它，我们使用一个软件就像手机上使用 <strong>APP</strong> 一样，我们不用管这个软件怎么写的，以及运行这个软件需要什么环境啊。当我们手机需要某个软件的时候，我们都直接在应用商店里直接搜索下载某个软件，然后打开运行。<strong>Docker</strong> 跟这种道理差不多，如果我们需要某个软件，那么我们也直接从镜像仓库里直接拉取（手机上我们说下载应用，<strong>Docker</strong> 使用的是 <strong>pull</strong> 命令那么就该翻译成拉取，道理是一样的），手机上我们下载的称做安装包，<strong>Docker</strong> 中对应就是应该是镜像。手机上下载好软件包后安装的这个步骤对应 <strong>Docker</strong> 中就应该是创建容器的这个步骤了，创建容器的时候只需要你配置一些简单的参数。手机安装包在你的手机上能下载并安装，在别人的手机上也一样。<strong>Docker</strong> 也是如此，同一镜像都可以在同样的 <strong>CPU</strong> 架构下创建容器运行。只要你装了 <strong>Docker</strong> 就不在乎你用的什么系统了，就只有 <strong>CPU</strong> 架构的区分了。这样就大大为应用的部署提供了方便，而且通常来说一个容器是非常    轻量的，创建和删除它都非常的方便。这就是为什么要使用 <strong>Docker</strong> 来搭建 <strong>Samba</strong> 服务的原因了。</p>\n<span id=\"more\"></span>\n<p>至于 <strong>Samba</strong> 就是适用与 <strong>Linux</strong> 和 <strong>Unix</strong> 的标准 <strong>Windows</strong> 互操作性程序套件。有了它我们就可以把任意文件在我们的 <strong>Windows</strong> 系统和 <strong>Linux</strong> 系统中任意的转移了。</p>\n<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> docker run -it --name samba --restart always <span class=\"token punctuation\">\\</span>\n\t--net <span class=\"token function\">host</span> -p <span class=\"token number\">139</span>:139 -p <span class=\"token number\">455</span>:455  -v /home:/shared <span class=\"token punctuation\">\\</span>\n\t-d dperson/samba -s <span class=\"token string\">\"share;/shared;yes;no;yes\"</span> -n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们来说下每个参数的含义:</p>\n<p>sudo -&gt; 使用 root 权限执行后续命令</p>\n<p>docker -&gt; docker 命令</p>\n<p>run -&gt; docker 命令的参数，用于启动容器</p>\n<p>-i -&gt; 让容器的标准保持打开</p>\n<p>-t -&gt; 为容器分配一个伪终端</p>\n<p>–name -&gt; 容器名， samba 这里就给该容器命名为 samba</p>\n<p>–restart -&gt; 重启参数，always 我们这里选的就是一直重启，只要是启动失败了它就会不断的重启，这里的作用主要是为了开机启动</p>\n<p>–net -&gt; 加入网络，host 就是说该容器加入到主机网络中</p>\n<p>-p -&gt; 端口映射，139、455 是 <strong>Samba</strong> 协议的端口</p>\n<p>-v -&gt; 文件映射， /home:/shared 就是把主机中的 /home 目录映射到 容器中的 /shared 目录中</p>\n<p>-d -&gt; 后台运行</p>\n<p>dperson/samba 使用的镜像名，当我们的本地没有该镜像时，它会自动去网络仓库里搜索并拉取， 镜像可以是我们自己写的，也可以是别人写好的，我们这里所使用的就是别人已经写的了的</p>\n<p>这上面的都是 <strong>Docker</strong> 命令中的参数，而镜像名后面跟的参数就是该镜像自己设定的参数了，有的镜像可能有，有的镜像可能也没有。这主要就要看这个镜像是怎么写的了</p>\n<p>-s -&gt; 设置共享目录， “share;/shared;yes;no;yes” 给共享的文件夹取名为 share，共享的是容器中的 shared 文件夹（前面的参数就已经把主机中的文件映射到这里了），可见，非只读，启用访客</p>\n<p><em><strong>关于更多的 dperson/samba 详细设置请见 <a href=\"https://hub.docker.com/r/dperson/samba/\">dperson/samba</a></strong></em></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前述\"><a href=\"#前述\" class=\"headerlink\" title=\"前述\"></a>前述</h3><p>能看到搜索到这篇文章想必你已经了解了什么是 <strong>Docker</strong>，什么是 <strong>Samba</strong> 了。如果你不了解这两样东西，那么我建议你在网上搜索一下，仔细了解下这两样比较实用的工具。</p>\n<p>我就以我通俗的语言简述下这两样东西，<strong>Docker</strong> 是一种标准化的软件单元，说白了有了它，我们使用一个软件就像手机上使用 <strong>APP</strong> 一样，我们不用管这个软件怎么写的，以及运行这个软件需要什么环境啊。当我们手机需要某个软件的时候，我们都直接在应用商店里直接搜索下载某个软件，然后打开运行。<strong>Docker</strong> 跟这种道理差不多，如果我们需要某个软件，那么我们也直接从镜像仓库里直接拉取（手机上我们说下载应用，<strong>Docker</strong> 使用的是 <strong>pull</strong> 命令那么就该翻译成拉取，道理是一样的），手机上我们下载的称做安装包，<strong>Docker</strong> 中对应就是应该是镜像。手机上下载好软件包后安装的这个步骤对应 <strong>Docker</strong> 中就应该是创建容器的这个步骤了，创建容器的时候只需要你配置一些简单的参数。手机安装包在你的手机上能下载并安装，在别人的手机上也一样。<strong>Docker</strong> 也是如此，同一镜像都可以在同样的 <strong>CPU</strong> 架构下创建容器运行。只要你装了 <strong>Docker</strong> 就不在乎你用的什么系统了，就只有 <strong>CPU</strong> 架构的区分了。这样就大大为应用的部署提供了方便，而且通常来说一个容器是非常    轻量的，创建和删除它都非常的方便。这就是为什么要使用 <strong>Docker</strong> 来搭建 <strong>Samba</strong> 服务的原因了。</p>","more":"<p>至于 <strong>Samba</strong> 就是适用与 <strong>Linux</strong> 和 <strong>Unix</strong> 的标准 <strong>Windows</strong> 互操作性程序套件。有了它我们就可以把任意文件在我们的 <strong>Windows</strong> 系统和 <strong>Linux</strong> 系统中任意的转移了。</p>\n<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> docker run -it --name samba --restart always <span class=\"token punctuation\">\\</span>\n\t--net <span class=\"token function\">host</span> -p <span class=\"token number\">139</span>:139 -p <span class=\"token number\">455</span>:455  -v /home:/shared <span class=\"token punctuation\">\\</span>\n\t-d dperson/samba -s <span class=\"token string\">\"share;/shared;yes;no;yes\"</span> -n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们来说下每个参数的含义:</p>\n<p>sudo -&gt; 使用 root 权限执行后续命令</p>\n<p>docker -&gt; docker 命令</p>\n<p>run -&gt; docker 命令的参数，用于启动容器</p>\n<p>-i -&gt; 让容器的标准保持打开</p>\n<p>-t -&gt; 为容器分配一个伪终端</p>\n<p>–name -&gt; 容器名， samba 这里就给该容器命名为 samba</p>\n<p>–restart -&gt; 重启参数，always 我们这里选的就是一直重启，只要是启动失败了它就会不断的重启，这里的作用主要是为了开机启动</p>\n<p>–net -&gt; 加入网络，host 就是说该容器加入到主机网络中</p>\n<p>-p -&gt; 端口映射，139、455 是 <strong>Samba</strong> 协议的端口</p>\n<p>-v -&gt; 文件映射， /home:/shared 就是把主机中的 /home 目录映射到 容器中的 /shared 目录中</p>\n<p>-d -&gt; 后台运行</p>\n<p>dperson/samba 使用的镜像名，当我们的本地没有该镜像时，它会自动去网络仓库里搜索并拉取， 镜像可以是我们自己写的，也可以是别人写好的，我们这里所使用的就是别人已经写的了的</p>\n<p>这上面的都是 <strong>Docker</strong> 命令中的参数，而镜像名后面跟的参数就是该镜像自己设定的参数了，有的镜像可能有，有的镜像可能也没有。这主要就要看这个镜像是怎么写的了</p>\n<p>-s -&gt; 设置共享目录， “share;/shared;yes;no;yes” 给共享的文件夹取名为 share，共享的是容器中的 shared 文件夹（前面的参数就已经把主机中的文件映射到这里了），可见，非只读，启用访客</p>\n<p><em><strong>关于更多的 dperson/samba 详细设置请见 <a href=\"https://hub.docker.com/r/dperson/samba/\">dperson/samba</a></strong></em></p>"},{"title":"讲一个玩 Homeassistant 一年的故事(一)","date":"2018-12-18T16:00:00.000Z","comments":1,"_content":"\n## 大家好，以下为我玩 ***HASS*** 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\n\n### 我是如何入坑？\n\t\n那么我就先从入坑开始讲起，大概是 `2017` 年的 `5` 月份我买了一块树莓派，型号是 `3b` ，买这个的初衷是为了玩，看着网上的教程资料发现这个小板子好玩的很呐，感觉无所不能，于是就在淘宝上购买了我的第一块板子，和一些面包板、杜邦线之类的东西。\n\n<!--more-->\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/1.png\" width=\"50%\" height=\"50%\"/><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/2.png\" width=\"50%\" height=\"50%\"/>\n买了这些东西其实不是为了玩 ***HASS*** ，当时想的是学习传感器以及单片机，自己一心想做个遥控小车出来。然后自己跟着一本印度人写的树莓派应用的书学习，初步了解到了点什么是 **传感器**，什么是 **Linux** 。自己傻乎乎的在那里玩 **超声波** 、**DHT11** 的驱动还以为自己发现了新大陆，觉得自己非常的牛逼。忍不住想在别人面前炫耀，于是自己加了个树莓派交流群，其实里面吹牛的多，干事的少。一天我例行公事在群友面前炫耀自己是怎么用树莓派让我的 **HC-SR04**、**DHT11** 如何工作的，结果有位老哥一声不吭的录了一段视频，视频里的内容我现在都记得，他用 **Siri** 控制了他一个自制的台灯。这种从来没发过话的人，突然发了一个比你还牛的视频，对于我来说无疑是对我巨大的打击，我顿时感觉自己的人格受到了严重的侮辱。我立马加了他好友，他也很很快的添加了我。于是我疯狂的赞美他，夸他是多么多么的牛，希望他也能教教我怎么做。最开始他没理我，于是我第二天又问他是怎么做的，可能是他不耐烦了，就回了我两个词 **homeassistant + homebridge** 就完了，再问他具体怎么做的也不说了，大神的口是真的难开，就回我两个词。再怎么问他都不鸟我了，于是我就在百度上找 **homeassistant homebridge** ，最开始这个资料是真的少，百度了许久才搞懂这个 **Homeassistant** 和 **Homebridge** 是两个东西，**Homeassistant** 可以理解为一个 **Hub** 而 **Homebridge** 应该理解为 `homeassistant to homekit` 的一个网关。百度上有用的资料就两篇，一个是 **老高** 的帖子，另一个是一个不知名的人写的，这两位人就是带我入门的人。老高的贴子最好，他讲的很详细，我的树莓派也因此发挥了它的光和热, 要知道我最初买树莓派并不是为了玩 **Hass** 的，所以这个也就告诉我们一个道理 \"无心插柳柳成阴\" ，他的教程从树莓派刷机到安装 **Homeassistant** ，到配置以及 **Sonoff** 刷固件每个细节都讲了，他还专门录制了视频害怕我们不会，没办法那时候是真的菜，他不讲那么细中间卡一步就够折腾的。\n\n就这样照着老高的帖子我跌跌撞撞的在一个星期内成功的用 **Siri** 了我的一个发光二级管的亮灭。于是我按耐不住激动的心情又录了一个 **Siri** 控制发光二级管的视频，这次的视频引起的反响就更大了。连前面我主动加的那位小哥都表示惊讶——\"你这么快就弄好了？\"，呵呵你也不看看我是谁。后面我与这个小哥互相交流了会，发现他也是个狠角色，比我大一级，参加过学校的比赛还获得过奖。顿时我就对他心存敬意，希望有朝一日也像他那样成功。过了几天我又把这个视频拿到群里炫耀，这时一个在 **HomeAssistant智能家居** 群里的人发现了我，并夸赞我东西做的不错，问我是不是也玩 **Homeassistant** 的。不一会他就把我拉到了全国最大的 **Homeassistant** 交流群，进入之后我又发现自己原来又是最菜的，别人都开始研究怎么让空调连接到 **Homeassistant** 了，**Sonoff** 这些别人早会了。\n\n\n\n\n### 这一年我学到了些什么？\n1. #### 我学会了学习新东西的能力\n\t从这张图就看的出我段位不低了，入坑早资料少，所以后面入坑的朋友真心别心急慢慢来，前面已经出了很多教程了，选自己有用的学，学的很快的，毕竟资料很丰富了。我知道有的人跟我一样很依赖问别人，自己不愿意花大功夫去网上找资料。自己经验表明一般来说你的问题在网上都会找到，你要有总结出你的问题并提取关键词的能力，然后拿到网上去搜索一会就找到了，只有你的问题很前沿或者很奇葩的问题才找不到。\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/3.png\" width=\"50%\" height=\"50%\"/>\n2. #### 国外网站要多逛\n\t不得不承认老外是真的强，不是我舔他们。其实我们玩的这些东西都是老外玩了之后我们再玩的。除了 **ESP8266**、**小米设备** 是我们国产的，其余大多都是老外先玩的, **Homeassistant、Homekit、Espeasy、Tasmota、Lovelace……** 他们一般都比我们玩的溜，毕竟是他们写的东西。所以要找新的东西或者找些什么资料啊，去他们的网站找找，学习别人的东西也未尝不可。\n3. #### 要舍得花钱\n\t不得不说玩 ***HASS*** 是真的烧钱，我没玩 ***HASS*** 之前每个月都还会剩个两三百，每个月还会请别人在外面吃顿饭，自从玩了 ***HASS*** 后发现这玩意就是个无底洞。买完树莓买 **Sonoff**，刚把这个买了别人又在玩 **Nodemcu** 了又得买，双十一到了又跟风买天猫精灵，平时还买些传感器和配套的东西之类的，又什么 **WS2812B**、**N1**、**K2P**、**摄像头** 之类的反正我现在每个月都欠蚂蚁花呗钱，活动资金不够了就问朋友借。舍得花钱但到理性消费，买些自己需要的东西就行了，别看见什么就买，买来不用浪费。\n\n**看一张白神设备图**\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/4.jpg\" width=\"50%\" height=\"50%\"/>\n4. #### 学到了些新技术\n    学校没学到的玩 **HASS** 学到了些，玩 **HASS** 你起码会学到点 **Linux** 的基础吧，设置开机启动，设置账户，权限，防火墙问题等等，再说 **Linux** 上的软件 **Frp**、**Docker**、**Nginx**、**Shadowsocket** ……也会接触到，反正东西需要自己琢磨。硬件也有从硬件连接到固件烧录，体验过之后就会收获很多，学习的时候要保持敬畏之心。为什么这么说？如果你弄些东西的过程中完全想当然的来做，很容易吃亏，有时候是耗时，有时候就是把东西弄坏。得不偿失，我一般喜欢弄东西的时候完全按教程来，等我把东西弄好了，自己再在再创造。这样一来是为了让我更快的体验到这东西弄好之后是什么样子，二来是为了总结经验方便再创造。","source":"_posts/玩HASS一年的故事 (一).md","raw":"---\ntitle: 讲一个玩 Homeassistant 一年的故事(一)\ndate: 2018-12-19\ncategories: 故事\ncomments: true\n---\n\n## 大家好，以下为我玩 ***HASS*** 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\n\n### 我是如何入坑？\n\t\n那么我就先从入坑开始讲起，大概是 `2017` 年的 `5` 月份我买了一块树莓派，型号是 `3b` ，买这个的初衷是为了玩，看着网上的教程资料发现这个小板子好玩的很呐，感觉无所不能，于是就在淘宝上购买了我的第一块板子，和一些面包板、杜邦线之类的东西。\n\n<!--more-->\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/1.png\" width=\"50%\" height=\"50%\"/><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/2.png\" width=\"50%\" height=\"50%\"/>\n买了这些东西其实不是为了玩 ***HASS*** ，当时想的是学习传感器以及单片机，自己一心想做个遥控小车出来。然后自己跟着一本印度人写的树莓派应用的书学习，初步了解到了点什么是 **传感器**，什么是 **Linux** 。自己傻乎乎的在那里玩 **超声波** 、**DHT11** 的驱动还以为自己发现了新大陆，觉得自己非常的牛逼。忍不住想在别人面前炫耀，于是自己加了个树莓派交流群，其实里面吹牛的多，干事的少。一天我例行公事在群友面前炫耀自己是怎么用树莓派让我的 **HC-SR04**、**DHT11** 如何工作的，结果有位老哥一声不吭的录了一段视频，视频里的内容我现在都记得，他用 **Siri** 控制了他一个自制的台灯。这种从来没发过话的人，突然发了一个比你还牛的视频，对于我来说无疑是对我巨大的打击，我顿时感觉自己的人格受到了严重的侮辱。我立马加了他好友，他也很很快的添加了我。于是我疯狂的赞美他，夸他是多么多么的牛，希望他也能教教我怎么做。最开始他没理我，于是我第二天又问他是怎么做的，可能是他不耐烦了，就回了我两个词 **homeassistant + homebridge** 就完了，再问他具体怎么做的也不说了，大神的口是真的难开，就回我两个词。再怎么问他都不鸟我了，于是我就在百度上找 **homeassistant homebridge** ，最开始这个资料是真的少，百度了许久才搞懂这个 **Homeassistant** 和 **Homebridge** 是两个东西，**Homeassistant** 可以理解为一个 **Hub** 而 **Homebridge** 应该理解为 `homeassistant to homekit` 的一个网关。百度上有用的资料就两篇，一个是 **老高** 的帖子，另一个是一个不知名的人写的，这两位人就是带我入门的人。老高的贴子最好，他讲的很详细，我的树莓派也因此发挥了它的光和热, 要知道我最初买树莓派并不是为了玩 **Hass** 的，所以这个也就告诉我们一个道理 \"无心插柳柳成阴\" ，他的教程从树莓派刷机到安装 **Homeassistant** ，到配置以及 **Sonoff** 刷固件每个细节都讲了，他还专门录制了视频害怕我们不会，没办法那时候是真的菜，他不讲那么细中间卡一步就够折腾的。\n\n就这样照着老高的帖子我跌跌撞撞的在一个星期内成功的用 **Siri** 了我的一个发光二级管的亮灭。于是我按耐不住激动的心情又录了一个 **Siri** 控制发光二级管的视频，这次的视频引起的反响就更大了。连前面我主动加的那位小哥都表示惊讶——\"你这么快就弄好了？\"，呵呵你也不看看我是谁。后面我与这个小哥互相交流了会，发现他也是个狠角色，比我大一级，参加过学校的比赛还获得过奖。顿时我就对他心存敬意，希望有朝一日也像他那样成功。过了几天我又把这个视频拿到群里炫耀，这时一个在 **HomeAssistant智能家居** 群里的人发现了我，并夸赞我东西做的不错，问我是不是也玩 **Homeassistant** 的。不一会他就把我拉到了全国最大的 **Homeassistant** 交流群，进入之后我又发现自己原来又是最菜的，别人都开始研究怎么让空调连接到 **Homeassistant** 了，**Sonoff** 这些别人早会了。\n\n\n\n\n### 这一年我学到了些什么？\n1. #### 我学会了学习新东西的能力\n\t从这张图就看的出我段位不低了，入坑早资料少，所以后面入坑的朋友真心别心急慢慢来，前面已经出了很多教程了，选自己有用的学，学的很快的，毕竟资料很丰富了。我知道有的人跟我一样很依赖问别人，自己不愿意花大功夫去网上找资料。自己经验表明一般来说你的问题在网上都会找到，你要有总结出你的问题并提取关键词的能力，然后拿到网上去搜索一会就找到了，只有你的问题很前沿或者很奇葩的问题才找不到。\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/3.png\" width=\"50%\" height=\"50%\"/>\n2. #### 国外网站要多逛\n\t不得不承认老外是真的强，不是我舔他们。其实我们玩的这些东西都是老外玩了之后我们再玩的。除了 **ESP8266**、**小米设备** 是我们国产的，其余大多都是老外先玩的, **Homeassistant、Homekit、Espeasy、Tasmota、Lovelace……** 他们一般都比我们玩的溜，毕竟是他们写的东西。所以要找新的东西或者找些什么资料啊，去他们的网站找找，学习别人的东西也未尝不可。\n3. #### 要舍得花钱\n\t不得不说玩 ***HASS*** 是真的烧钱，我没玩 ***HASS*** 之前每个月都还会剩个两三百，每个月还会请别人在外面吃顿饭，自从玩了 ***HASS*** 后发现这玩意就是个无底洞。买完树莓买 **Sonoff**，刚把这个买了别人又在玩 **Nodemcu** 了又得买，双十一到了又跟风买天猫精灵，平时还买些传感器和配套的东西之类的，又什么 **WS2812B**、**N1**、**K2P**、**摄像头** 之类的反正我现在每个月都欠蚂蚁花呗钱，活动资金不够了就问朋友借。舍得花钱但到理性消费，买些自己需要的东西就行了，别看见什么就买，买来不用浪费。\n\n**看一张白神设备图**\n<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/4.jpg\" width=\"50%\" height=\"50%\"/>\n4. #### 学到了些新技术\n    学校没学到的玩 **HASS** 学到了些，玩 **HASS** 你起码会学到点 **Linux** 的基础吧，设置开机启动，设置账户，权限，防火墙问题等等，再说 **Linux** 上的软件 **Frp**、**Docker**、**Nginx**、**Shadowsocket** ……也会接触到，反正东西需要自己琢磨。硬件也有从硬件连接到固件烧录，体验过之后就会收获很多，学习的时候要保持敬畏之心。为什么这么说？如果你弄些东西的过程中完全想当然的来做，很容易吃亏，有时候是耗时，有时候就是把东西弄坏。得不偿失，我一般喜欢弄东西的时候完全按教程来，等我把东西弄好了，自己再在再创造。这样一来是为了让我更快的体验到这东西弄好之后是什么样子，二来是为了总结经验方便再创造。","slug":"玩HASS一年的故事 (一)","published":1,"updated":"2021-03-10T15:13:18.663Z","layout":"post","photos":[],"link":"","_id":"ckm3l2tre000ea5jx5qwub0f0","content":"<h2 id=\"大家好，以下为我玩-HASS-一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\"><a href=\"#大家好，以下为我玩-HASS-一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\" class=\"headerlink\" title=\"大家好，以下为我玩 HASS 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\"></a>大家好，以下为我玩 <em><strong>HASS</strong></em> 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。</h2><h3 id=\"我是如何入坑？\"><a href=\"#我是如何入坑？\" class=\"headerlink\" title=\"我是如何入坑？\"></a>我是如何入坑？</h3><p>那么我就先从入坑开始讲起，大概是 <code>2017</code> 年的 <code>5</code> 月份我买了一块树莓派，型号是 <code>3b</code> ，买这个的初衷是为了玩，看着网上的教程资料发现这个小板子好玩的很呐，感觉无所不能，于是就在淘宝上购买了我的第一块板子，和一些面包板、杜邦线之类的东西。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/1.png\" width=\"50%\" height=\"50%\"/><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/2.png\" width=\"50%\" height=\"50%\"/><br>买了这些东西其实不是为了玩 <em><strong>HASS</strong></em> ，当时想的是学习传感器以及单片机，自己一心想做个遥控小车出来。然后自己跟着一本印度人写的树莓派应用的书学习，初步了解到了点什么是 <strong>传感器</strong>，什么是 <strong>Linux</strong> 。自己傻乎乎的在那里玩 <strong>超声波</strong> 、<strong>DHT11</strong> 的驱动还以为自己发现了新大陆，觉得自己非常的牛逼。忍不住想在别人面前炫耀，于是自己加了个树莓派交流群，其实里面吹牛的多，干事的少。一天我例行公事在群友面前炫耀自己是怎么用树莓派让我的 <strong>HC-SR04</strong>、<strong>DHT11</strong> 如何工作的，结果有位老哥一声不吭的录了一段视频，视频里的内容我现在都记得，他用 <strong>Siri</strong> 控制了他一个自制的台灯。这种从来没发过话的人，突然发了一个比你还牛的视频，对于我来说无疑是对我巨大的打击，我顿时感觉自己的人格受到了严重的侮辱。我立马加了他好友，他也很很快的添加了我。于是我疯狂的赞美他，夸他是多么多么的牛，希望他也能教教我怎么做。最开始他没理我，于是我第二天又问他是怎么做的，可能是他不耐烦了，就回了我两个词 <strong>homeassistant + homebridge</strong> 就完了，再问他具体怎么做的也不说了，大神的口是真的难开，就回我两个词。再怎么问他都不鸟我了，于是我就在百度上找 <strong>homeassistant homebridge</strong> ，最开始这个资料是真的少，百度了许久才搞懂这个 <strong>Homeassistant</strong> 和 <strong>Homebridge</strong> 是两个东西，<strong>Homeassistant</strong> 可以理解为一个 <strong>Hub</strong> 而 <strong>Homebridge</strong> 应该理解为 <code>homeassistant to homekit</code> 的一个网关。百度上有用的资料就两篇，一个是 <strong>老高</strong> 的帖子，另一个是一个不知名的人写的，这两位人就是带我入门的人。老高的贴子最好，他讲的很详细，我的树莓派也因此发挥了它的光和热, 要知道我最初买树莓派并不是为了玩 <strong>Hass</strong> 的，所以这个也就告诉我们一个道理 “无心插柳柳成阴” ，他的教程从树莓派刷机到安装 <strong>Homeassistant</strong> ，到配置以及 <strong>Sonoff</strong> 刷固件每个细节都讲了，他还专门录制了视频害怕我们不会，没办法那时候是真的菜，他不讲那么细中间卡一步就够折腾的。</p>\n<p>就这样照着老高的帖子我跌跌撞撞的在一个星期内成功的用 <strong>Siri</strong> 了我的一个发光二级管的亮灭。于是我按耐不住激动的心情又录了一个 <strong>Siri</strong> 控制发光二级管的视频，这次的视频引起的反响就更大了。连前面我主动加的那位小哥都表示惊讶——“你这么快就弄好了？”，呵呵你也不看看我是谁。后面我与这个小哥互相交流了会，发现他也是个狠角色，比我大一级，参加过学校的比赛还获得过奖。顿时我就对他心存敬意，希望有朝一日也像他那样成功。过了几天我又把这个视频拿到群里炫耀，这时一个在 <strong>HomeAssistant智能家居</strong> 群里的人发现了我，并夸赞我东西做的不错，问我是不是也玩 <strong>Homeassistant</strong> 的。不一会他就把我拉到了全国最大的 <strong>Homeassistant</strong> 交流群，进入之后我又发现自己原来又是最菜的，别人都开始研究怎么让空调连接到 <strong>Homeassistant</strong> 了，<strong>Sonoff</strong> 这些别人早会了。</p>\n<h3 id=\"这一年我学到了些什么？\"><a href=\"#这一年我学到了些什么？\" class=\"headerlink\" title=\"这一年我学到了些什么？\"></a>这一年我学到了些什么？</h3><ol>\n<li><h4 id=\"我学会了学习新东西的能力\"><a href=\"#我学会了学习新东西的能力\" class=\"headerlink\" title=\"我学会了学习新东西的能力\"></a>我学会了学习新东西的能力</h4> 从这张图就看的出我段位不低了，入坑早资料少，所以后面入坑的朋友真心别心急慢慢来，前面已经出了很多教程了，选自己有用的学，学的很快的，毕竟资料很丰富了。我知道有的人跟我一样很依赖问别人，自己不愿意花大功夫去网上找资料。自己经验表明一般来说你的问题在网上都会找到，你要有总结出你的问题并提取关键词的能力，然后拿到网上去搜索一会就找到了，只有你的问题很前沿或者很奇葩的问题才找不到。<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/3.png\" width=\"50%\" height=\"50%\"/></li>\n<li><h4 id=\"国外网站要多逛\"><a href=\"#国外网站要多逛\" class=\"headerlink\" title=\"国外网站要多逛\"></a>国外网站要多逛</h4> 不得不承认老外是真的强，不是我舔他们。其实我们玩的这些东西都是老外玩了之后我们再玩的。除了 <strong>ESP8266</strong>、<strong>小米设备</strong> 是我们国产的，其余大多都是老外先玩的, <strong>Homeassistant、Homekit、Espeasy、Tasmota、Lovelace……</strong> 他们一般都比我们玩的溜，毕竟是他们写的东西。所以要找新的东西或者找些什么资料啊，去他们的网站找找，学习别人的东西也未尝不可。</li>\n<li><h4 id=\"要舍得花钱\"><a href=\"#要舍得花钱\" class=\"headerlink\" title=\"要舍得花钱\"></a>要舍得花钱</h4> 不得不说玩 <em><strong>HASS</strong></em> 是真的烧钱，我没玩 <em><strong>HASS</strong></em> 之前每个月都还会剩个两三百，每个月还会请别人在外面吃顿饭，自从玩了 <em><strong>HASS</strong></em> 后发现这玩意就是个无底洞。买完树莓买 <strong>Sonoff</strong>，刚把这个买了别人又在玩 <strong>Nodemcu</strong> 了又得买，双十一到了又跟风买天猫精灵，平时还买些传感器和配套的东西之类的，又什么 <strong>WS2812B</strong>、<strong>N1</strong>、<strong>K2P</strong>、<strong>摄像头</strong> 之类的反正我现在每个月都欠蚂蚁花呗钱，活动资金不够了就问朋友借。舍得花钱但到理性消费，买些自己需要的东西就行了，别看见什么就买，买来不用浪费。</li>\n</ol>\n<p><strong>看一张白神设备图</strong><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/4.jpg\" width=\"50%\" height=\"50%\"/><br>4. #### 学到了些新技术<br>    学校没学到的玩 <strong>HASS</strong> 学到了些，玩 <strong>HASS</strong> 你起码会学到点 <strong>Linux</strong> 的基础吧，设置开机启动，设置账户，权限，防火墙问题等等，再说 <strong>Linux</strong> 上的软件 <strong>Frp</strong>、<strong>Docker</strong>、<strong>Nginx</strong>、<strong>Shadowsocket</strong> ……也会接触到，反正东西需要自己琢磨。硬件也有从硬件连接到固件烧录，体验过之后就会收获很多，学习的时候要保持敬畏之心。为什么这么说？如果你弄些东西的过程中完全想当然的来做，很容易吃亏，有时候是耗时，有时候就是把东西弄坏。得不偿失，我一般喜欢弄东西的时候完全按教程来，等我把东西弄好了，自己再在再创造。这样一来是为了让我更快的体验到这东西弄好之后是什么样子，二来是为了总结经验方便再创造。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"大家好，以下为我玩-HASS-一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\"><a href=\"#大家好，以下为我玩-HASS-一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\" class=\"headerlink\" title=\"大家好，以下为我玩 HASS 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。\"></a>大家好，以下为我玩 <em><strong>HASS</strong></em> 一年的故事，我将以短小说的形式展现给大家，闲来无事故有此文。文中不谈技术只谈故事与经验。</h2><h3 id=\"我是如何入坑？\"><a href=\"#我是如何入坑？\" class=\"headerlink\" title=\"我是如何入坑？\"></a>我是如何入坑？</h3><p>那么我就先从入坑开始讲起，大概是 <code>2017</code> 年的 <code>5</code> 月份我买了一块树莓派，型号是 <code>3b</code> ，买这个的初衷是为了玩，看着网上的教程资料发现这个小板子好玩的很呐，感觉无所不能，于是就在淘宝上购买了我的第一块板子，和一些面包板、杜邦线之类的东西。</p>","more":"<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/1.png\" width=\"50%\" height=\"50%\"/><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/2.png\" width=\"50%\" height=\"50%\"/><br>买了这些东西其实不是为了玩 <em><strong>HASS</strong></em> ，当时想的是学习传感器以及单片机，自己一心想做个遥控小车出来。然后自己跟着一本印度人写的树莓派应用的书学习，初步了解到了点什么是 <strong>传感器</strong>，什么是 <strong>Linux</strong> 。自己傻乎乎的在那里玩 <strong>超声波</strong> 、<strong>DHT11</strong> 的驱动还以为自己发现了新大陆，觉得自己非常的牛逼。忍不住想在别人面前炫耀，于是自己加了个树莓派交流群，其实里面吹牛的多，干事的少。一天我例行公事在群友面前炫耀自己是怎么用树莓派让我的 <strong>HC-SR04</strong>、<strong>DHT11</strong> 如何工作的，结果有位老哥一声不吭的录了一段视频，视频里的内容我现在都记得，他用 <strong>Siri</strong> 控制了他一个自制的台灯。这种从来没发过话的人，突然发了一个比你还牛的视频，对于我来说无疑是对我巨大的打击，我顿时感觉自己的人格受到了严重的侮辱。我立马加了他好友，他也很很快的添加了我。于是我疯狂的赞美他，夸他是多么多么的牛，希望他也能教教我怎么做。最开始他没理我，于是我第二天又问他是怎么做的，可能是他不耐烦了，就回了我两个词 <strong>homeassistant + homebridge</strong> 就完了，再问他具体怎么做的也不说了，大神的口是真的难开，就回我两个词。再怎么问他都不鸟我了，于是我就在百度上找 <strong>homeassistant homebridge</strong> ，最开始这个资料是真的少，百度了许久才搞懂这个 <strong>Homeassistant</strong> 和 <strong>Homebridge</strong> 是两个东西，<strong>Homeassistant</strong> 可以理解为一个 <strong>Hub</strong> 而 <strong>Homebridge</strong> 应该理解为 <code>homeassistant to homekit</code> 的一个网关。百度上有用的资料就两篇，一个是 <strong>老高</strong> 的帖子，另一个是一个不知名的人写的，这两位人就是带我入门的人。老高的贴子最好，他讲的很详细，我的树莓派也因此发挥了它的光和热, 要知道我最初买树莓派并不是为了玩 <strong>Hass</strong> 的，所以这个也就告诉我们一个道理 “无心插柳柳成阴” ，他的教程从树莓派刷机到安装 <strong>Homeassistant</strong> ，到配置以及 <strong>Sonoff</strong> 刷固件每个细节都讲了，他还专门录制了视频害怕我们不会，没办法那时候是真的菜，他不讲那么细中间卡一步就够折腾的。</p>\n<p>就这样照着老高的帖子我跌跌撞撞的在一个星期内成功的用 <strong>Siri</strong> 了我的一个发光二级管的亮灭。于是我按耐不住激动的心情又录了一个 <strong>Siri</strong> 控制发光二级管的视频，这次的视频引起的反响就更大了。连前面我主动加的那位小哥都表示惊讶——“你这么快就弄好了？”，呵呵你也不看看我是谁。后面我与这个小哥互相交流了会，发现他也是个狠角色，比我大一级，参加过学校的比赛还获得过奖。顿时我就对他心存敬意，希望有朝一日也像他那样成功。过了几天我又把这个视频拿到群里炫耀，这时一个在 <strong>HomeAssistant智能家居</strong> 群里的人发现了我，并夸赞我东西做的不错，问我是不是也玩 <strong>Homeassistant</strong> 的。不一会他就把我拉到了全国最大的 <strong>Homeassistant</strong> 交流群，进入之后我又发现自己原来又是最菜的，别人都开始研究怎么让空调连接到 <strong>Homeassistant</strong> 了，<strong>Sonoff</strong> 这些别人早会了。</p>\n<h3 id=\"这一年我学到了些什么？\"><a href=\"#这一年我学到了些什么？\" class=\"headerlink\" title=\"这一年我学到了些什么？\"></a>这一年我学到了些什么？</h3><ol>\n<li><h4 id=\"我学会了学习新东西的能力\"><a href=\"#我学会了学习新东西的能力\" class=\"headerlink\" title=\"我学会了学习新东西的能力\"></a>我学会了学习新东西的能力</h4> 从这张图就看的出我段位不低了，入坑早资料少，所以后面入坑的朋友真心别心急慢慢来，前面已经出了很多教程了，选自己有用的学，学的很快的，毕竟资料很丰富了。我知道有的人跟我一样很依赖问别人，自己不愿意花大功夫去网上找资料。自己经验表明一般来说你的问题在网上都会找到，你要有总结出你的问题并提取关键词的能力，然后拿到网上去搜索一会就找到了，只有你的问题很前沿或者很奇葩的问题才找不到。<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/3.png\" width=\"50%\" height=\"50%\"/></li>\n<li><h4 id=\"国外网站要多逛\"><a href=\"#国外网站要多逛\" class=\"headerlink\" title=\"国外网站要多逛\"></a>国外网站要多逛</h4> 不得不承认老外是真的强，不是我舔他们。其实我们玩的这些东西都是老外玩了之后我们再玩的。除了 <strong>ESP8266</strong>、<strong>小米设备</strong> 是我们国产的，其余大多都是老外先玩的, <strong>Homeassistant、Homekit、Espeasy、Tasmota、Lovelace……</strong> 他们一般都比我们玩的溜，毕竟是他们写的东西。所以要找新的东西或者找些什么资料啊，去他们的网站找找，学习别人的东西也未尝不可。</li>\n<li><h4 id=\"要舍得花钱\"><a href=\"#要舍得花钱\" class=\"headerlink\" title=\"要舍得花钱\"></a>要舍得花钱</h4> 不得不说玩 <em><strong>HASS</strong></em> 是真的烧钱，我没玩 <em><strong>HASS</strong></em> 之前每个月都还会剩个两三百，每个月还会请别人在外面吃顿饭，自从玩了 <em><strong>HASS</strong></em> 后发现这玩意就是个无底洞。买完树莓买 <strong>Sonoff</strong>，刚把这个买了别人又在玩 <strong>Nodemcu</strong> 了又得买，双十一到了又跟风买天猫精灵，平时还买些传感器和配套的东西之类的，又什么 <strong>WS2812B</strong>、<strong>N1</strong>、<strong>K2P</strong>、<strong>摄像头</strong> 之类的反正我现在每个月都欠蚂蚁花呗钱，活动资金不够了就问朋友借。舍得花钱但到理性消费，买些自己需要的东西就行了，别看见什么就买，买来不用浪费。</li>\n</ol>\n<p><strong>看一张白神设备图</strong><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/blog_1/4.jpg\" width=\"50%\" height=\"50%\"/><br>4. #### 学到了些新技术<br>    学校没学到的玩 <strong>HASS</strong> 学到了些，玩 <strong>HASS</strong> 你起码会学到点 <strong>Linux</strong> 的基础吧，设置开机启动，设置账户，权限，防火墙问题等等，再说 <strong>Linux</strong> 上的软件 <strong>Frp</strong>、<strong>Docker</strong>、<strong>Nginx</strong>、<strong>Shadowsocket</strong> ……也会接触到，反正东西需要自己琢磨。硬件也有从硬件连接到固件烧录，体验过之后就会收获很多，学习的时候要保持敬畏之心。为什么这么说？如果你弄些东西的过程中完全想当然的来做，很容易吃亏，有时候是耗时，有时候就是把东西弄坏。得不偿失，我一般喜欢弄东西的时候完全按教程来，等我把东西弄好了，自己再在再创造。这样一来是为了让我更快的体验到这东西弄好之后是什么样子，二来是为了总结经验方便再创造。</p>"},{"title":"译：UEFI 启动真正做了什么","date":"2020-09-03T16:00:00.000Z","preview":600,"_content":"该文译自 Adam Willianson 的 \"UEFI boot:how does that actually work, then?\"\n\n又是 AdamW 文章时间了！如果你是想找简短而生动的文章，请到别处。\n\n[Kamil Paral](http://kparal.wordpress.com/) 友好地提示我，我是一名狂热的纸制化着。时刻注意自己有什么问题。\n\n*对行业大众的重要注解：* 这篇博客只针对普通大众：目的是消除一些普通神话和帮助普通大众更好的理解 UEFI。这不是低级的完全的详细描述也不能保证 100% 技术上准确的解释，我不是一名专业的固件工程师或者类似的人。如果你实际上是在构建操作系统或者其他的东西，请不要依赖我的简单说明或者向我请求帮助；我只是互联网上的白痴。如果你想做善事并且有钱的话，加入 UEFI 论坛询问您的供应商或检查您的参考实施或其他。如果你没有钱，那就问你有经验的同事，好的。*重要注解结束*\n\n也许你已经在网上读了很多关于 UEFI 的文章了。这里有一点很重要的信息你应该知道：它们 95% 的都是垃圾。如果你想知道关于 UEFI，或者拓展关于 UEFI 规范以外的知识，[mig59's blog](http://mjg59.dreamwidth.org/) 和一些看起来可靠的相关人员 - [Rod Smith](http://www.rodsbooks.com/linux-uefi/), [Peter Jones](http://blog.uncooperative.org/)，Chris Murphy 和一些相对较少的文档，这些 OS 的开发人员实际上知道 UEFI 到底做了什么。你所认为你认识像误解的混合毒药，误解、半真相、炒作和彻底的谎言。所以你应该完全忘了它们。\n\n好的，我们已经走上正道了。我最想讨论的就是引导加载了，因为那是对于大多数人最重要的固件，一些网站一直发一些误解的东西并且引起人们的误解。\n\n<!--more-->\n## 术语\n首先，让我们摆脱一些术语。BIOS 和 UEFI 都是计算机的固件。BISO 类型的固件（大多数）仅在 IBM PC 兼容计算机上找到。UEFI 相对来说更大通用，可以在非 IMB 兼容计算机上找到。UEFI\n\n你不能有 'UEFI BIOS'，也没有 'UEFI BIOS‘。请千万不要说 'UEFI BIOS'. BIOS 并非所有 PC 固件的通用术语。它只是 PC 固件的一种类型。你的计算机有一个固件。如果它是 IBM PC 兼容计算机，几乎可以肯定是一个 BIOS 或者 UEFI 固件。如果你正在跑 [Coreboot](http://www.coreboot.org/)，先生/女士祝贺您，您是个例外，你应该为你自己感到自豪。\n\n安全启动和 UEFI 并非是一个事。千万不要交换使用这些术语。安全系统是 UEFI 规范里一个单独有效的可选项，在 UEFI 规范的版本 2.2 中添加。稍后我再确切的讨论它是什么，但是现在，只需要记住它和 UEFI 不是一样东西。你需要明白安全启动是什么，UEFI 是什么，任何时间你应该知道你自己在说什么。我们先来说 UEFI，后面我们再说安全启动作为 UEFI 的拓展，因为基本上就是这样。\n\n奖金历史记录：UEFI 不是微软发明，不被它控制，并且从未被微软控制。它的前生和基础，EFI 是英特尔开发并推行的。UEFI 被[UEFI 联盟](http://uefi.org/)管理。微软是 UEFI 联盟成员之一。还有红帽、苹果还有很多主要的 PC 厂家，英特尔（很明显）、AMD、和[其他主要的次要的硬件软件公司和组织的清单](http://uefi.org/members)。这是一个广泛的共识规范，和一大堆必要的麻烦，这些我们后面再单独讲。这不是任何一家公司的 “邪恶之车”。\n\n## 参考\n如果你真正的想理解 UEFI，去读 UEFI 规范是一个很好的办法。你可以这样做，这也很简单。不你用花一分钱，我不是在告诉你阅读是让你最快乐的事情了，因为它不是。但是它会浪费你的时间，你可以在这里找到 [UEFI 的官网](http://www.uefi.org/specs/download)。你必须确认一些选项，但是你不会把你的灵魂签署给撒旦，不用担心。当我写这些事，当前版本是 [2.4 Errata A](http://www.uefi.org/sites/default/files/resources/2_4_Errata_A.pdf)，那就是这篇文章写的版本。这里没有 BIOS 规范，BIOS 是实事上的标准-它的工作方式与1980年代在实际IBM PC上的工作方式相同。这也是 UEFI 存在的原因之一。\n\n现在，让事情简单点，我们来考虑下两个世界。一个是 IBM PC 兼容计算机世界-以下简称为 PCs - 在 UEFI 和 GPT 存在之前。你们很多人可能对这个世界很熟悉并且可能非常了解。我们来说下在具有 BIOS 固件的 PC 是如何启动的。\n\nBIOS 启动\n它有效，实际上是一种非常非常简单的方式。在你老派的 BIOS PC 上，你有一个或者多个是 MBR 的硬盘。这个 MBR 是另一个实事标准；基本上，磁盘的最开始以特定格式描述了磁盘上的分区，包含一个 '启动引导',一段非常小 BIOS 固件知道如何执行的代码，它的任务是启动操作系统。（现代的启动引导通常更大能够包含 MBR 空间和必要使用的多阶段设计，MBR 中的位知道如何从其他位置加载下一阶段，但这对于我们来说并不是现在的重点）。\n\n所有 BIOS 固件都知道，在启动系统的上下文中，是哪个磁盘有操作系统。你，BIOS 基础计算机的所有者，可以告诉 BIOS 固件你要启动的哪个磁盘上的系统。固件不明白这范围以外的事情了。它执行启动引导找到具体硬盘上的 MBR ，就完了。固件再也不会被调用了。\n\n在 BIOS 的世界里，显然所有形式的多重引导都在固件层之上处理。固件层不知道什么是启动引导，或者什么是操作系统。它更不知道分区是什么。所有它能做的只是从磁盘的 MBR 分区执行启动引到程序。您也无法从固件外部配置引导过程。\n\n## UEFI 启动：背景\n好的，我们已经有 BIOS 世界的基础了。现在让我们看一下在UEFI系统上启动的工作方式。使您不了解这篇文章的细节，也请理解：它完全不同。彻底完全地不同与 BIOS 的启动方式。你不能将你对 BIOS 引导过程来理解 UEFI 启动。你需要知道这是一个完全不同的世界。\n\n这还有一件重要的十需要知道：许多 UEFI 固件实现了某种 BIOS 兼容模式，通常被叫称为 CSM。许多 UEFI 固件能像 BIOS 固件一样启动-它们会找磁盘上的 MBR，并且执行 MBR 里的启动引导，然后将所有内容留给该引导程序。人们有时会错误地将使用此功能称为“禁用 UEFI”，这是语法上的错误。你不能“禁用”你系统上的固件。这是很笨的术语。不要用它，但理解人们真正想说的东西。他们想说 UEFI 固件能以\"BIOS 模式“启动系统而不是原生 UEFI 模式。\n\n我将描述下原生 UEFI 启动。如果你有基于 UEFI 系统，其固件具有 BIOS 兼容性功能，并且你决定使用它。那么就启动而言，你可以假装你的系统是基于 BIOS 的，做所有事的方式跟 BIOS 启动方式一样。但是，如果要执行此操作，请确保您始终应用它。我真心强烈不推荐你将 UEFI-原生 与 BIOS-兼容的永久安装操作系统的引导，特别是在相同的磁盘上。这是非常非常糟糕的主意，这会造成你身心痛苦。如果你决定这样做，不要来向我哭。\n\n为了理智，我假设磁盘尺有所短  GPT 分区表，和 EFI FAT32 [EFI 系统分区](https://en.wikipedia.org/wiki/EFI_System_partition)。根据要深入研究这些内容的深度，您可能会发现，并不是严格说来，您可以始终假设在处理UEFI本机启动时将要使用 GPT 磁盘和 EFI FAT32 ESP，但是 UEFI 规范与 GPT 磁盘和 EFI FAT32 ESP 紧密相关，在99％的情况下，这是您要处理的问题。除非你正在使用 Macs，坦白说，Macs 很混乱。\n\n**编辑注解:** 以下内容（取决于含义和复杂性）在 2014-01-26 经过大量修改，此帖子的初始版本发布后几个小时根据 Peter Jones 的反馈。认为这是 V2.0 版的文章。早期版本以不太准确和混乱的方式编写。\n\n## UEFI 原生启动：它背后真正做了什么\n好吧，顺便说一句，让我们开始讨论。这就是原生 UEFI 引导实际上是如何工作的。拥有一些高级背景知道可能会有所帮助。\n\nUEFI 在固件级提供了很多基础架构来处理系统启动。它远不及 BIOS 那么简单。不像 BIOS，UEFI 真正地理解，要从不同程度上，磁盘分区、启动引导程序和操作系统等概念。\n\n你可以看一下 BIOS 引导过程，再看一下 UEFI 过程，看 UEFI 流程如何扩展各种位以解决特定问题。\n\n这 BIOS/MBR 查找引导程序的方式非常简陋，当你思考它时。它就像非特别的酱：这是在磁盘头一段极小的空间里包含神奇的代码，它只对系统固件有意义，只能用特殊工具来写它。这种方法存在几个问题。\n* 这不方便处理 - 你需要特殊的固件来写 MBR 分区， 也就只有一个办法搞清楚它是什么，dd 出内容然后分析它。\n* 如上所述，MBR 它本身没那么大不足以容纳许多现代引导程序。它所做的是安装它们自身的一小部分到 MBR 适当的位置，剩余的空间到磁盘常规 MBR 结束到第一分区开始之的空白空间。这有一个很大的问题（好吧，这整个设计就是个大问题，但是从未注意到），这就是关于第一分区的开始位置没有可靠的约定，因此很难确保会有足够的空间。通常可以认为，没有足够的空间用于某些引导加载程序配置。\n* 设计没有提供为选择引导目标（磁盘除外）的任何标准代理层或机制...但是对于人们想选择磁盘意外的引导目标。比如，他们想有个可启动的东西-通常是操作系统-每个磁盘。唯一的方式是这样，在 BIOS/MBR 时间里是引导程序来处理它；但是仍没有一个被广泛认可的约定来完成以正常的方式来完成这些。有许多许多的方法，没有一个可以与其他任何一个互操作，写一个在 OS/OS 安装代理层能干净地处理多重引导问题的工具那太难了。\n* 该设计没有提供从磁盘以外的任何东西引导的标准方法。我不想在这篇文章真正的讨论这个问题，但请注意，这是 UEFI 引导的另一个优势：它提供了从例如远程服务器引导的标准方式。\n* 没有提供机制可以用于配置高于固件的级别来配置固件的启动行为。\n\n所以你能想象 UEFI 精灵围坐在一起考虑这个问题，并提出了解决方案。取代固件只知道磁盘和每个磁盘上的“魔术”区域-引导加载程序代码可能驻留的位置，UEFI 对于处理启动引导的固件有更多的基础设施。让我们看看它定义的所有与这里相关的东西。\n\n# EFI 可执行文件\nUEFI 规格定义了一种可执行格式并要求所有 UEFI 固件能够执行这种格式的代码。当您为本机 UEFI 编写引导加载程序时，你将以这种格式编写。这种方式十分简单明了，不需要过多的解释：这是个好东西，现在我们有了一个固件规范真正地定义了固件可执行通用代码格式。\n\n# GPT(GUID 分区表)格式\n[GUID 分区表](https://en.wikipedia.org/wiki/GUID_Partition_Table) 格式非常贴符合 UEFI 规范，此外，没有什么特别复杂的或需要过多解释的，这只是规范提供的基础。GPT 只是做分区表的标准-信息在磁盘的头部，它定义了磁盘包含什么分区。它是在许多方面比 MBR/'MS-DOS' 做更好的分区标准，UEFI 规范要求符合 UEFI 的固件必须能够解释 GPT（它同样要求能够执行 MBR，为了向后兼容）。所有这些都是有用的基础：这里正在发生的事情是规范正在建立某些功能，固件层以上的所有内容都可以依赖于固件。\n\n# EFI 系统分区\n实际上，在修订本文时，我确实想将头放在 EFI 系统分区概念上，因为它非常精彩的部分。实际上，”EFI 系统分区“这概念正是回答 MBR 空间“特殊调味料”的问题。正如我们在上面看到的，在磁盘开始时一些未定义的空白空间的概念是“引导加载程序代码所在的位置”，这是一个非常糟糕的设计。EFI 系统分区就是来解决这个问题的。\n\n解决办法是：我们要求固件能够一些具体的文件系统。UEFI 规范要求合格的固件应该能读取 FAT12， FAT 格式的 FAT16 和 FAT32 变体。实际上，它所做的是编篆对那么格式特定的解释，因为他们在 UEFI 被接受时就已经存在了，就是说符合 UEFI 的固件必须能够读这些格式。规范如下：\n\n“被可扩展固件接口支持的文件系统是基于 FAT 文件系统。EFI 定义了明确记录和可测试的 FAT 版本。符合 EFI 规范","source":"_posts/译：UEFI 启动真正做了什么.md","raw":"---\ntitle: 译：UEFI 启动真正做了什么\ndate: 2020-09-04\ncategories: 操作系统\ntags: UEFI - BOOT\npreview: 600\n---\n该文译自 Adam Willianson 的 \"UEFI boot:how does that actually work, then?\"\n\n又是 AdamW 文章时间了！如果你是想找简短而生动的文章，请到别处。\n\n[Kamil Paral](http://kparal.wordpress.com/) 友好地提示我，我是一名狂热的纸制化着。时刻注意自己有什么问题。\n\n*对行业大众的重要注解：* 这篇博客只针对普通大众：目的是消除一些普通神话和帮助普通大众更好的理解 UEFI。这不是低级的完全的详细描述也不能保证 100% 技术上准确的解释，我不是一名专业的固件工程师或者类似的人。如果你实际上是在构建操作系统或者其他的东西，请不要依赖我的简单说明或者向我请求帮助；我只是互联网上的白痴。如果你想做善事并且有钱的话，加入 UEFI 论坛询问您的供应商或检查您的参考实施或其他。如果你没有钱，那就问你有经验的同事，好的。*重要注解结束*\n\n也许你已经在网上读了很多关于 UEFI 的文章了。这里有一点很重要的信息你应该知道：它们 95% 的都是垃圾。如果你想知道关于 UEFI，或者拓展关于 UEFI 规范以外的知识，[mig59's blog](http://mjg59.dreamwidth.org/) 和一些看起来可靠的相关人员 - [Rod Smith](http://www.rodsbooks.com/linux-uefi/), [Peter Jones](http://blog.uncooperative.org/)，Chris Murphy 和一些相对较少的文档，这些 OS 的开发人员实际上知道 UEFI 到底做了什么。你所认为你认识像误解的混合毒药，误解、半真相、炒作和彻底的谎言。所以你应该完全忘了它们。\n\n好的，我们已经走上正道了。我最想讨论的就是引导加载了，因为那是对于大多数人最重要的固件，一些网站一直发一些误解的东西并且引起人们的误解。\n\n<!--more-->\n## 术语\n首先，让我们摆脱一些术语。BIOS 和 UEFI 都是计算机的固件。BISO 类型的固件（大多数）仅在 IBM PC 兼容计算机上找到。UEFI 相对来说更大通用，可以在非 IMB 兼容计算机上找到。UEFI\n\n你不能有 'UEFI BIOS'，也没有 'UEFI BIOS‘。请千万不要说 'UEFI BIOS'. BIOS 并非所有 PC 固件的通用术语。它只是 PC 固件的一种类型。你的计算机有一个固件。如果它是 IBM PC 兼容计算机，几乎可以肯定是一个 BIOS 或者 UEFI 固件。如果你正在跑 [Coreboot](http://www.coreboot.org/)，先生/女士祝贺您，您是个例外，你应该为你自己感到自豪。\n\n安全启动和 UEFI 并非是一个事。千万不要交换使用这些术语。安全系统是 UEFI 规范里一个单独有效的可选项，在 UEFI 规范的版本 2.2 中添加。稍后我再确切的讨论它是什么，但是现在，只需要记住它和 UEFI 不是一样东西。你需要明白安全启动是什么，UEFI 是什么，任何时间你应该知道你自己在说什么。我们先来说 UEFI，后面我们再说安全启动作为 UEFI 的拓展，因为基本上就是这样。\n\n奖金历史记录：UEFI 不是微软发明，不被它控制，并且从未被微软控制。它的前生和基础，EFI 是英特尔开发并推行的。UEFI 被[UEFI 联盟](http://uefi.org/)管理。微软是 UEFI 联盟成员之一。还有红帽、苹果还有很多主要的 PC 厂家，英特尔（很明显）、AMD、和[其他主要的次要的硬件软件公司和组织的清单](http://uefi.org/members)。这是一个广泛的共识规范，和一大堆必要的麻烦，这些我们后面再单独讲。这不是任何一家公司的 “邪恶之车”。\n\n## 参考\n如果你真正的想理解 UEFI，去读 UEFI 规范是一个很好的办法。你可以这样做，这也很简单。不你用花一分钱，我不是在告诉你阅读是让你最快乐的事情了，因为它不是。但是它会浪费你的时间，你可以在这里找到 [UEFI 的官网](http://www.uefi.org/specs/download)。你必须确认一些选项，但是你不会把你的灵魂签署给撒旦，不用担心。当我写这些事，当前版本是 [2.4 Errata A](http://www.uefi.org/sites/default/files/resources/2_4_Errata_A.pdf)，那就是这篇文章写的版本。这里没有 BIOS 规范，BIOS 是实事上的标准-它的工作方式与1980年代在实际IBM PC上的工作方式相同。这也是 UEFI 存在的原因之一。\n\n现在，让事情简单点，我们来考虑下两个世界。一个是 IBM PC 兼容计算机世界-以下简称为 PCs - 在 UEFI 和 GPT 存在之前。你们很多人可能对这个世界很熟悉并且可能非常了解。我们来说下在具有 BIOS 固件的 PC 是如何启动的。\n\nBIOS 启动\n它有效，实际上是一种非常非常简单的方式。在你老派的 BIOS PC 上，你有一个或者多个是 MBR 的硬盘。这个 MBR 是另一个实事标准；基本上，磁盘的最开始以特定格式描述了磁盘上的分区，包含一个 '启动引导',一段非常小 BIOS 固件知道如何执行的代码，它的任务是启动操作系统。（现代的启动引导通常更大能够包含 MBR 空间和必要使用的多阶段设计，MBR 中的位知道如何从其他位置加载下一阶段，但这对于我们来说并不是现在的重点）。\n\n所有 BIOS 固件都知道，在启动系统的上下文中，是哪个磁盘有操作系统。你，BIOS 基础计算机的所有者，可以告诉 BIOS 固件你要启动的哪个磁盘上的系统。固件不明白这范围以外的事情了。它执行启动引导找到具体硬盘上的 MBR ，就完了。固件再也不会被调用了。\n\n在 BIOS 的世界里，显然所有形式的多重引导都在固件层之上处理。固件层不知道什么是启动引导，或者什么是操作系统。它更不知道分区是什么。所有它能做的只是从磁盘的 MBR 分区执行启动引到程序。您也无法从固件外部配置引导过程。\n\n## UEFI 启动：背景\n好的，我们已经有 BIOS 世界的基础了。现在让我们看一下在UEFI系统上启动的工作方式。使您不了解这篇文章的细节，也请理解：它完全不同。彻底完全地不同与 BIOS 的启动方式。你不能将你对 BIOS 引导过程来理解 UEFI 启动。你需要知道这是一个完全不同的世界。\n\n这还有一件重要的十需要知道：许多 UEFI 固件实现了某种 BIOS 兼容模式，通常被叫称为 CSM。许多 UEFI 固件能像 BIOS 固件一样启动-它们会找磁盘上的 MBR，并且执行 MBR 里的启动引导，然后将所有内容留给该引导程序。人们有时会错误地将使用此功能称为“禁用 UEFI”，这是语法上的错误。你不能“禁用”你系统上的固件。这是很笨的术语。不要用它，但理解人们真正想说的东西。他们想说 UEFI 固件能以\"BIOS 模式“启动系统而不是原生 UEFI 模式。\n\n我将描述下原生 UEFI 启动。如果你有基于 UEFI 系统，其固件具有 BIOS 兼容性功能，并且你决定使用它。那么就启动而言，你可以假装你的系统是基于 BIOS 的，做所有事的方式跟 BIOS 启动方式一样。但是，如果要执行此操作，请确保您始终应用它。我真心强烈不推荐你将 UEFI-原生 与 BIOS-兼容的永久安装操作系统的引导，特别是在相同的磁盘上。这是非常非常糟糕的主意，这会造成你身心痛苦。如果你决定这样做，不要来向我哭。\n\n为了理智，我假设磁盘尺有所短  GPT 分区表，和 EFI FAT32 [EFI 系统分区](https://en.wikipedia.org/wiki/EFI_System_partition)。根据要深入研究这些内容的深度，您可能会发现，并不是严格说来，您可以始终假设在处理UEFI本机启动时将要使用 GPT 磁盘和 EFI FAT32 ESP，但是 UEFI 规范与 GPT 磁盘和 EFI FAT32 ESP 紧密相关，在99％的情况下，这是您要处理的问题。除非你正在使用 Macs，坦白说，Macs 很混乱。\n\n**编辑注解:** 以下内容（取决于含义和复杂性）在 2014-01-26 经过大量修改，此帖子的初始版本发布后几个小时根据 Peter Jones 的反馈。认为这是 V2.0 版的文章。早期版本以不太准确和混乱的方式编写。\n\n## UEFI 原生启动：它背后真正做了什么\n好吧，顺便说一句，让我们开始讨论。这就是原生 UEFI 引导实际上是如何工作的。拥有一些高级背景知道可能会有所帮助。\n\nUEFI 在固件级提供了很多基础架构来处理系统启动。它远不及 BIOS 那么简单。不像 BIOS，UEFI 真正地理解，要从不同程度上，磁盘分区、启动引导程序和操作系统等概念。\n\n你可以看一下 BIOS 引导过程，再看一下 UEFI 过程，看 UEFI 流程如何扩展各种位以解决特定问题。\n\n这 BIOS/MBR 查找引导程序的方式非常简陋，当你思考它时。它就像非特别的酱：这是在磁盘头一段极小的空间里包含神奇的代码，它只对系统固件有意义，只能用特殊工具来写它。这种方法存在几个问题。\n* 这不方便处理 - 你需要特殊的固件来写 MBR 分区， 也就只有一个办法搞清楚它是什么，dd 出内容然后分析它。\n* 如上所述，MBR 它本身没那么大不足以容纳许多现代引导程序。它所做的是安装它们自身的一小部分到 MBR 适当的位置，剩余的空间到磁盘常规 MBR 结束到第一分区开始之的空白空间。这有一个很大的问题（好吧，这整个设计就是个大问题，但是从未注意到），这就是关于第一分区的开始位置没有可靠的约定，因此很难确保会有足够的空间。通常可以认为，没有足够的空间用于某些引导加载程序配置。\n* 设计没有提供为选择引导目标（磁盘除外）的任何标准代理层或机制...但是对于人们想选择磁盘意外的引导目标。比如，他们想有个可启动的东西-通常是操作系统-每个磁盘。唯一的方式是这样，在 BIOS/MBR 时间里是引导程序来处理它；但是仍没有一个被广泛认可的约定来完成以正常的方式来完成这些。有许多许多的方法，没有一个可以与其他任何一个互操作，写一个在 OS/OS 安装代理层能干净地处理多重引导问题的工具那太难了。\n* 该设计没有提供从磁盘以外的任何东西引导的标准方法。我不想在这篇文章真正的讨论这个问题，但请注意，这是 UEFI 引导的另一个优势：它提供了从例如远程服务器引导的标准方式。\n* 没有提供机制可以用于配置高于固件的级别来配置固件的启动行为。\n\n所以你能想象 UEFI 精灵围坐在一起考虑这个问题，并提出了解决方案。取代固件只知道磁盘和每个磁盘上的“魔术”区域-引导加载程序代码可能驻留的位置，UEFI 对于处理启动引导的固件有更多的基础设施。让我们看看它定义的所有与这里相关的东西。\n\n# EFI 可执行文件\nUEFI 规格定义了一种可执行格式并要求所有 UEFI 固件能够执行这种格式的代码。当您为本机 UEFI 编写引导加载程序时，你将以这种格式编写。这种方式十分简单明了，不需要过多的解释：这是个好东西，现在我们有了一个固件规范真正地定义了固件可执行通用代码格式。\n\n# GPT(GUID 分区表)格式\n[GUID 分区表](https://en.wikipedia.org/wiki/GUID_Partition_Table) 格式非常贴符合 UEFI 规范，此外，没有什么特别复杂的或需要过多解释的，这只是规范提供的基础。GPT 只是做分区表的标准-信息在磁盘的头部，它定义了磁盘包含什么分区。它是在许多方面比 MBR/'MS-DOS' 做更好的分区标准，UEFI 规范要求符合 UEFI 的固件必须能够解释 GPT（它同样要求能够执行 MBR，为了向后兼容）。所有这些都是有用的基础：这里正在发生的事情是规范正在建立某些功能，固件层以上的所有内容都可以依赖于固件。\n\n# EFI 系统分区\n实际上，在修订本文时，我确实想将头放在 EFI 系统分区概念上，因为它非常精彩的部分。实际上，”EFI 系统分区“这概念正是回答 MBR 空间“特殊调味料”的问题。正如我们在上面看到的，在磁盘开始时一些未定义的空白空间的概念是“引导加载程序代码所在的位置”，这是一个非常糟糕的设计。EFI 系统分区就是来解决这个问题的。\n\n解决办法是：我们要求固件能够一些具体的文件系统。UEFI 规范要求合格的固件应该能读取 FAT12， FAT 格式的 FAT16 和 FAT32 变体。实际上，它所做的是编篆对那么格式特定的解释，因为他们在 UEFI 被接受时就已经存在了，就是说符合 UEFI 的固件必须能够读这些格式。规范如下：\n\n“被可扩展固件接口支持的文件系统是基于 FAT 文件系统。EFI 定义了明确记录和可测试的 FAT 版本。符合 EFI 规范","slug":"译：UEFI 启动真正做了什么","published":1,"updated":"2021-03-10T15:12:22.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2trg000fa5jx1bm1h51g","content":"<p>该文译自 Adam Willianson 的 “UEFI boot:how does that actually work, then?”</p>\n<p>又是 AdamW 文章时间了！如果你是想找简短而生动的文章，请到别处。</p>\n<p><a href=\"http://kparal.wordpress.com/\">Kamil Paral</a> 友好地提示我，我是一名狂热的纸制化着。时刻注意自己有什么问题。</p>\n<p><em>对行业大众的重要注解：</em> 这篇博客只针对普通大众：目的是消除一些普通神话和帮助普通大众更好的理解 UEFI。这不是低级的完全的详细描述也不能保证 100% 技术上准确的解释，我不是一名专业的固件工程师或者类似的人。如果你实际上是在构建操作系统或者其他的东西，请不要依赖我的简单说明或者向我请求帮助；我只是互联网上的白痴。如果你想做善事并且有钱的话，加入 UEFI 论坛询问您的供应商或检查您的参考实施或其他。如果你没有钱，那就问你有经验的同事，好的。<em>重要注解结束</em></p>\n<p>也许你已经在网上读了很多关于 UEFI 的文章了。这里有一点很重要的信息你应该知道：它们 95% 的都是垃圾。如果你想知道关于 UEFI，或者拓展关于 UEFI 规范以外的知识，<a href=\"http://mjg59.dreamwidth.org/\">mig59’s blog</a> 和一些看起来可靠的相关人员 - <a href=\"http://www.rodsbooks.com/linux-uefi/\">Rod Smith</a>, <a href=\"http://blog.uncooperative.org/\">Peter Jones</a>，Chris Murphy 和一些相对较少的文档，这些 OS 的开发人员实际上知道 UEFI 到底做了什么。你所认为你认识像误解的混合毒药，误解、半真相、炒作和彻底的谎言。所以你应该完全忘了它们。</p>\n<p>好的，我们已经走上正道了。我最想讨论的就是引导加载了，因为那是对于大多数人最重要的固件，一些网站一直发一些误解的东西并且引起人们的误解。</p>\n<span id=\"more\"></span>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>首先，让我们摆脱一些术语。BIOS 和 UEFI 都是计算机的固件。BISO 类型的固件（大多数）仅在 IBM PC 兼容计算机上找到。UEFI 相对来说更大通用，可以在非 IMB 兼容计算机上找到。UEFI</p>\n<p>你不能有 ‘UEFI BIOS’，也没有 ‘UEFI BIOS‘。请千万不要说 ‘UEFI BIOS’. BIOS 并非所有 PC 固件的通用术语。它只是 PC 固件的一种类型。你的计算机有一个固件。如果它是 IBM PC 兼容计算机，几乎可以肯定是一个 BIOS 或者 UEFI 固件。如果你正在跑 <a href=\"http://www.coreboot.org/\">Coreboot</a>，先生/女士祝贺您，您是个例外，你应该为你自己感到自豪。</p>\n<p>安全启动和 UEFI 并非是一个事。千万不要交换使用这些术语。安全系统是 UEFI 规范里一个单独有效的可选项，在 UEFI 规范的版本 2.2 中添加。稍后我再确切的讨论它是什么，但是现在，只需要记住它和 UEFI 不是一样东西。你需要明白安全启动是什么，UEFI 是什么，任何时间你应该知道你自己在说什么。我们先来说 UEFI，后面我们再说安全启动作为 UEFI 的拓展，因为基本上就是这样。</p>\n<p>奖金历史记录：UEFI 不是微软发明，不被它控制，并且从未被微软控制。它的前生和基础，EFI 是英特尔开发并推行的。UEFI 被<a href=\"http://uefi.org/\">UEFI 联盟</a>管理。微软是 UEFI 联盟成员之一。还有红帽、苹果还有很多主要的 PC 厂家，英特尔（很明显）、AMD、和<a href=\"http://uefi.org/members\">其他主要的次要的硬件软件公司和组织的清单</a>。这是一个广泛的共识规范，和一大堆必要的麻烦，这些我们后面再单独讲。这不是任何一家公司的 “邪恶之车”。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>如果你真正的想理解 UEFI，去读 UEFI 规范是一个很好的办法。你可以这样做，这也很简单。不你用花一分钱，我不是在告诉你阅读是让你最快乐的事情了，因为它不是。但是它会浪费你的时间，你可以在这里找到 <a href=\"http://www.uefi.org/specs/download\">UEFI 的官网</a>。你必须确认一些选项，但是你不会把你的灵魂签署给撒旦，不用担心。当我写这些事，当前版本是 <a href=\"http://www.uefi.org/sites/default/files/resources/2_4_Errata_A.pdf\">2.4 Errata A</a>，那就是这篇文章写的版本。这里没有 BIOS 规范，BIOS 是实事上的标准-它的工作方式与1980年代在实际IBM PC上的工作方式相同。这也是 UEFI 存在的原因之一。</p>\n<p>现在，让事情简单点，我们来考虑下两个世界。一个是 IBM PC 兼容计算机世界-以下简称为 PCs - 在 UEFI 和 GPT 存在之前。你们很多人可能对这个世界很熟悉并且可能非常了解。我们来说下在具有 BIOS 固件的 PC 是如何启动的。</p>\n<p>BIOS 启动<br>它有效，实际上是一种非常非常简单的方式。在你老派的 BIOS PC 上，你有一个或者多个是 MBR 的硬盘。这个 MBR 是另一个实事标准；基本上，磁盘的最开始以特定格式描述了磁盘上的分区，包含一个 ‘启动引导’,一段非常小 BIOS 固件知道如何执行的代码，它的任务是启动操作系统。（现代的启动引导通常更大能够包含 MBR 空间和必要使用的多阶段设计，MBR 中的位知道如何从其他位置加载下一阶段，但这对于我们来说并不是现在的重点）。</p>\n<p>所有 BIOS 固件都知道，在启动系统的上下文中，是哪个磁盘有操作系统。你，BIOS 基础计算机的所有者，可以告诉 BIOS 固件你要启动的哪个磁盘上的系统。固件不明白这范围以外的事情了。它执行启动引导找到具体硬盘上的 MBR ，就完了。固件再也不会被调用了。</p>\n<p>在 BIOS 的世界里，显然所有形式的多重引导都在固件层之上处理。固件层不知道什么是启动引导，或者什么是操作系统。它更不知道分区是什么。所有它能做的只是从磁盘的 MBR 分区执行启动引到程序。您也无法从固件外部配置引导过程。</p>\n<h2 id=\"UEFI-启动：背景\"><a href=\"#UEFI-启动：背景\" class=\"headerlink\" title=\"UEFI 启动：背景\"></a>UEFI 启动：背景</h2><p>好的，我们已经有 BIOS 世界的基础了。现在让我们看一下在UEFI系统上启动的工作方式。使您不了解这篇文章的细节，也请理解：它完全不同。彻底完全地不同与 BIOS 的启动方式。你不能将你对 BIOS 引导过程来理解 UEFI 启动。你需要知道这是一个完全不同的世界。</p>\n<p>这还有一件重要的十需要知道：许多 UEFI 固件实现了某种 BIOS 兼容模式，通常被叫称为 CSM。许多 UEFI 固件能像 BIOS 固件一样启动-它们会找磁盘上的 MBR，并且执行 MBR 里的启动引导，然后将所有内容留给该引导程序。人们有时会错误地将使用此功能称为“禁用 UEFI”，这是语法上的错误。你不能“禁用”你系统上的固件。这是很笨的术语。不要用它，但理解人们真正想说的东西。他们想说 UEFI 固件能以”BIOS 模式“启动系统而不是原生 UEFI 模式。</p>\n<p>我将描述下原生 UEFI 启动。如果你有基于 UEFI 系统，其固件具有 BIOS 兼容性功能，并且你决定使用它。那么就启动而言，你可以假装你的系统是基于 BIOS 的，做所有事的方式跟 BIOS 启动方式一样。但是，如果要执行此操作，请确保您始终应用它。我真心强烈不推荐你将 UEFI-原生 与 BIOS-兼容的永久安装操作系统的引导，特别是在相同的磁盘上。这是非常非常糟糕的主意，这会造成你身心痛苦。如果你决定这样做，不要来向我哭。</p>\n<p>为了理智，我假设磁盘尺有所短  GPT 分区表，和 EFI FAT32 <a href=\"https://en.wikipedia.org/wiki/EFI_System_partition\">EFI 系统分区</a>。根据要深入研究这些内容的深度，您可能会发现，并不是严格说来，您可以始终假设在处理UEFI本机启动时将要使用 GPT 磁盘和 EFI FAT32 ESP，但是 UEFI 规范与 GPT 磁盘和 EFI FAT32 ESP 紧密相关，在99％的情况下，这是您要处理的问题。除非你正在使用 Macs，坦白说，Macs 很混乱。</p>\n<p><strong>编辑注解:</strong> 以下内容（取决于含义和复杂性）在 2014-01-26 经过大量修改，此帖子的初始版本发布后几个小时根据 Peter Jones 的反馈。认为这是 V2.0 版的文章。早期版本以不太准确和混乱的方式编写。</p>\n<h2 id=\"UEFI-原生启动：它背后真正做了什么\"><a href=\"#UEFI-原生启动：它背后真正做了什么\" class=\"headerlink\" title=\"UEFI 原生启动：它背后真正做了什么\"></a>UEFI 原生启动：它背后真正做了什么</h2><p>好吧，顺便说一句，让我们开始讨论。这就是原生 UEFI 引导实际上是如何工作的。拥有一些高级背景知道可能会有所帮助。</p>\n<p>UEFI 在固件级提供了很多基础架构来处理系统启动。它远不及 BIOS 那么简单。不像 BIOS，UEFI 真正地理解，要从不同程度上，磁盘分区、启动引导程序和操作系统等概念。</p>\n<p>你可以看一下 BIOS 引导过程，再看一下 UEFI 过程，看 UEFI 流程如何扩展各种位以解决特定问题。</p>\n<p>这 BIOS/MBR 查找引导程序的方式非常简陋，当你思考它时。它就像非特别的酱：这是在磁盘头一段极小的空间里包含神奇的代码，它只对系统固件有意义，只能用特殊工具来写它。这种方法存在几个问题。</p>\n<ul>\n<li>这不方便处理 - 你需要特殊的固件来写 MBR 分区， 也就只有一个办法搞清楚它是什么，dd 出内容然后分析它。</li>\n<li>如上所述，MBR 它本身没那么大不足以容纳许多现代引导程序。它所做的是安装它们自身的一小部分到 MBR 适当的位置，剩余的空间到磁盘常规 MBR 结束到第一分区开始之的空白空间。这有一个很大的问题（好吧，这整个设计就是个大问题，但是从未注意到），这就是关于第一分区的开始位置没有可靠的约定，因此很难确保会有足够的空间。通常可以认为，没有足够的空间用于某些引导加载程序配置。</li>\n<li>设计没有提供为选择引导目标（磁盘除外）的任何标准代理层或机制…但是对于人们想选择磁盘意外的引导目标。比如，他们想有个可启动的东西-通常是操作系统-每个磁盘。唯一的方式是这样，在 BIOS/MBR 时间里是引导程序来处理它；但是仍没有一个被广泛认可的约定来完成以正常的方式来完成这些。有许多许多的方法，没有一个可以与其他任何一个互操作，写一个在 OS/OS 安装代理层能干净地处理多重引导问题的工具那太难了。</li>\n<li>该设计没有提供从磁盘以外的任何东西引导的标准方法。我不想在这篇文章真正的讨论这个问题，但请注意，这是 UEFI 引导的另一个优势：它提供了从例如远程服务器引导的标准方式。</li>\n<li>没有提供机制可以用于配置高于固件的级别来配置固件的启动行为。</li>\n</ul>\n<p>所以你能想象 UEFI 精灵围坐在一起考虑这个问题，并提出了解决方案。取代固件只知道磁盘和每个磁盘上的“魔术”区域-引导加载程序代码可能驻留的位置，UEFI 对于处理启动引导的固件有更多的基础设施。让我们看看它定义的所有与这里相关的东西。</p>\n<h1 id=\"EFI-可执行文件\"><a href=\"#EFI-可执行文件\" class=\"headerlink\" title=\"EFI 可执行文件\"></a>EFI 可执行文件</h1><p>UEFI 规格定义了一种可执行格式并要求所有 UEFI 固件能够执行这种格式的代码。当您为本机 UEFI 编写引导加载程序时，你将以这种格式编写。这种方式十分简单明了，不需要过多的解释：这是个好东西，现在我们有了一个固件规范真正地定义了固件可执行通用代码格式。</p>\n<h1 id=\"GPT-GUID-分区表-格式\"><a href=\"#GPT-GUID-分区表-格式\" class=\"headerlink\" title=\"GPT(GUID 分区表)格式\"></a>GPT(GUID 分区表)格式</h1><p><a href=\"https://en.wikipedia.org/wiki/GUID_Partition_Table\">GUID 分区表</a> 格式非常贴符合 UEFI 规范，此外，没有什么特别复杂的或需要过多解释的，这只是规范提供的基础。GPT 只是做分区表的标准-信息在磁盘的头部，它定义了磁盘包含什么分区。它是在许多方面比 MBR/‘MS-DOS’ 做更好的分区标准，UEFI 规范要求符合 UEFI 的固件必须能够解释 GPT（它同样要求能够执行 MBR，为了向后兼容）。所有这些都是有用的基础：这里正在发生的事情是规范正在建立某些功能，固件层以上的所有内容都可以依赖于固件。</p>\n<h1 id=\"EFI-系统分区\"><a href=\"#EFI-系统分区\" class=\"headerlink\" title=\"EFI 系统分区\"></a>EFI 系统分区</h1><p>实际上，在修订本文时，我确实想将头放在 EFI 系统分区概念上，因为它非常精彩的部分。实际上，”EFI 系统分区“这概念正是回答 MBR 空间“特殊调味料”的问题。正如我们在上面看到的，在磁盘开始时一些未定义的空白空间的概念是“引导加载程序代码所在的位置”，这是一个非常糟糕的设计。EFI 系统分区就是来解决这个问题的。</p>\n<p>解决办法是：我们要求固件能够一些具体的文件系统。UEFI 规范要求合格的固件应该能读取 FAT12， FAT 格式的 FAT16 和 FAT32 变体。实际上，它所做的是编篆对那么格式特定的解释，因为他们在 UEFI 被接受时就已经存在了，就是说符合 UEFI 的固件必须能够读这些格式。规范如下：</p>\n<p>“被可扩展固件接口支持的文件系统是基于 FAT 文件系统。EFI 定义了明确记录和可测试的 FAT 版本。符合 EFI 规范</p>\n","site":{"data":{}},"excerpt":"<p>该文译自 Adam Willianson 的 “UEFI boot:how does that actually work, then?”</p>\n<p>又是 AdamW 文章时间了！如果你是想找简短而生动的文章，请到别处。</p>\n<p><a href=\"http://kparal.wordpress.com/\">Kamil Paral</a> 友好地提示我，我是一名狂热的纸制化着。时刻注意自己有什么问题。</p>\n<p><em>对行业大众的重要注解：</em> 这篇博客只针对普通大众：目的是消除一些普通神话和帮助普通大众更好的理解 UEFI。这不是低级的完全的详细描述也不能保证 100% 技术上准确的解释，我不是一名专业的固件工程师或者类似的人。如果你实际上是在构建操作系统或者其他的东西，请不要依赖我的简单说明或者向我请求帮助；我只是互联网上的白痴。如果你想做善事并且有钱的话，加入 UEFI 论坛询问您的供应商或检查您的参考实施或其他。如果你没有钱，那就问你有经验的同事，好的。<em>重要注解结束</em></p>\n<p>也许你已经在网上读了很多关于 UEFI 的文章了。这里有一点很重要的信息你应该知道：它们 95% 的都是垃圾。如果你想知道关于 UEFI，或者拓展关于 UEFI 规范以外的知识，<a href=\"http://mjg59.dreamwidth.org/\">mig59’s blog</a> 和一些看起来可靠的相关人员 - <a href=\"http://www.rodsbooks.com/linux-uefi/\">Rod Smith</a>, <a href=\"http://blog.uncooperative.org/\">Peter Jones</a>，Chris Murphy 和一些相对较少的文档，这些 OS 的开发人员实际上知道 UEFI 到底做了什么。你所认为你认识像误解的混合毒药，误解、半真相、炒作和彻底的谎言。所以你应该完全忘了它们。</p>\n<p>好的，我们已经走上正道了。我最想讨论的就是引导加载了，因为那是对于大多数人最重要的固件，一些网站一直发一些误解的东西并且引起人们的误解。</p>","more":"<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>首先，让我们摆脱一些术语。BIOS 和 UEFI 都是计算机的固件。BISO 类型的固件（大多数）仅在 IBM PC 兼容计算机上找到。UEFI 相对来说更大通用，可以在非 IMB 兼容计算机上找到。UEFI</p>\n<p>你不能有 ‘UEFI BIOS’，也没有 ‘UEFI BIOS‘。请千万不要说 ‘UEFI BIOS’. BIOS 并非所有 PC 固件的通用术语。它只是 PC 固件的一种类型。你的计算机有一个固件。如果它是 IBM PC 兼容计算机，几乎可以肯定是一个 BIOS 或者 UEFI 固件。如果你正在跑 <a href=\"http://www.coreboot.org/\">Coreboot</a>，先生/女士祝贺您，您是个例外，你应该为你自己感到自豪。</p>\n<p>安全启动和 UEFI 并非是一个事。千万不要交换使用这些术语。安全系统是 UEFI 规范里一个单独有效的可选项，在 UEFI 规范的版本 2.2 中添加。稍后我再确切的讨论它是什么，但是现在，只需要记住它和 UEFI 不是一样东西。你需要明白安全启动是什么，UEFI 是什么，任何时间你应该知道你自己在说什么。我们先来说 UEFI，后面我们再说安全启动作为 UEFI 的拓展，因为基本上就是这样。</p>\n<p>奖金历史记录：UEFI 不是微软发明，不被它控制，并且从未被微软控制。它的前生和基础，EFI 是英特尔开发并推行的。UEFI 被<a href=\"http://uefi.org/\">UEFI 联盟</a>管理。微软是 UEFI 联盟成员之一。还有红帽、苹果还有很多主要的 PC 厂家，英特尔（很明显）、AMD、和<a href=\"http://uefi.org/members\">其他主要的次要的硬件软件公司和组织的清单</a>。这是一个广泛的共识规范，和一大堆必要的麻烦，这些我们后面再单独讲。这不是任何一家公司的 “邪恶之车”。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>如果你真正的想理解 UEFI，去读 UEFI 规范是一个很好的办法。你可以这样做，这也很简单。不你用花一分钱，我不是在告诉你阅读是让你最快乐的事情了，因为它不是。但是它会浪费你的时间，你可以在这里找到 <a href=\"http://www.uefi.org/specs/download\">UEFI 的官网</a>。你必须确认一些选项，但是你不会把你的灵魂签署给撒旦，不用担心。当我写这些事，当前版本是 <a href=\"http://www.uefi.org/sites/default/files/resources/2_4_Errata_A.pdf\">2.4 Errata A</a>，那就是这篇文章写的版本。这里没有 BIOS 规范，BIOS 是实事上的标准-它的工作方式与1980年代在实际IBM PC上的工作方式相同。这也是 UEFI 存在的原因之一。</p>\n<p>现在，让事情简单点，我们来考虑下两个世界。一个是 IBM PC 兼容计算机世界-以下简称为 PCs - 在 UEFI 和 GPT 存在之前。你们很多人可能对这个世界很熟悉并且可能非常了解。我们来说下在具有 BIOS 固件的 PC 是如何启动的。</p>\n<p>BIOS 启动<br>它有效，实际上是一种非常非常简单的方式。在你老派的 BIOS PC 上，你有一个或者多个是 MBR 的硬盘。这个 MBR 是另一个实事标准；基本上，磁盘的最开始以特定格式描述了磁盘上的分区，包含一个 ‘启动引导’,一段非常小 BIOS 固件知道如何执行的代码，它的任务是启动操作系统。（现代的启动引导通常更大能够包含 MBR 空间和必要使用的多阶段设计，MBR 中的位知道如何从其他位置加载下一阶段，但这对于我们来说并不是现在的重点）。</p>\n<p>所有 BIOS 固件都知道，在启动系统的上下文中，是哪个磁盘有操作系统。你，BIOS 基础计算机的所有者，可以告诉 BIOS 固件你要启动的哪个磁盘上的系统。固件不明白这范围以外的事情了。它执行启动引导找到具体硬盘上的 MBR ，就完了。固件再也不会被调用了。</p>\n<p>在 BIOS 的世界里，显然所有形式的多重引导都在固件层之上处理。固件层不知道什么是启动引导，或者什么是操作系统。它更不知道分区是什么。所有它能做的只是从磁盘的 MBR 分区执行启动引到程序。您也无法从固件外部配置引导过程。</p>\n<h2 id=\"UEFI-启动：背景\"><a href=\"#UEFI-启动：背景\" class=\"headerlink\" title=\"UEFI 启动：背景\"></a>UEFI 启动：背景</h2><p>好的，我们已经有 BIOS 世界的基础了。现在让我们看一下在UEFI系统上启动的工作方式。使您不了解这篇文章的细节，也请理解：它完全不同。彻底完全地不同与 BIOS 的启动方式。你不能将你对 BIOS 引导过程来理解 UEFI 启动。你需要知道这是一个完全不同的世界。</p>\n<p>这还有一件重要的十需要知道：许多 UEFI 固件实现了某种 BIOS 兼容模式，通常被叫称为 CSM。许多 UEFI 固件能像 BIOS 固件一样启动-它们会找磁盘上的 MBR，并且执行 MBR 里的启动引导，然后将所有内容留给该引导程序。人们有时会错误地将使用此功能称为“禁用 UEFI”，这是语法上的错误。你不能“禁用”你系统上的固件。这是很笨的术语。不要用它，但理解人们真正想说的东西。他们想说 UEFI 固件能以”BIOS 模式“启动系统而不是原生 UEFI 模式。</p>\n<p>我将描述下原生 UEFI 启动。如果你有基于 UEFI 系统，其固件具有 BIOS 兼容性功能，并且你决定使用它。那么就启动而言，你可以假装你的系统是基于 BIOS 的，做所有事的方式跟 BIOS 启动方式一样。但是，如果要执行此操作，请确保您始终应用它。我真心强烈不推荐你将 UEFI-原生 与 BIOS-兼容的永久安装操作系统的引导，特别是在相同的磁盘上。这是非常非常糟糕的主意，这会造成你身心痛苦。如果你决定这样做，不要来向我哭。</p>\n<p>为了理智，我假设磁盘尺有所短  GPT 分区表，和 EFI FAT32 <a href=\"https://en.wikipedia.org/wiki/EFI_System_partition\">EFI 系统分区</a>。根据要深入研究这些内容的深度，您可能会发现，并不是严格说来，您可以始终假设在处理UEFI本机启动时将要使用 GPT 磁盘和 EFI FAT32 ESP，但是 UEFI 规范与 GPT 磁盘和 EFI FAT32 ESP 紧密相关，在99％的情况下，这是您要处理的问题。除非你正在使用 Macs，坦白说，Macs 很混乱。</p>\n<p><strong>编辑注解:</strong> 以下内容（取决于含义和复杂性）在 2014-01-26 经过大量修改，此帖子的初始版本发布后几个小时根据 Peter Jones 的反馈。认为这是 V2.0 版的文章。早期版本以不太准确和混乱的方式编写。</p>\n<h2 id=\"UEFI-原生启动：它背后真正做了什么\"><a href=\"#UEFI-原生启动：它背后真正做了什么\" class=\"headerlink\" title=\"UEFI 原生启动：它背后真正做了什么\"></a>UEFI 原生启动：它背后真正做了什么</h2><p>好吧，顺便说一句，让我们开始讨论。这就是原生 UEFI 引导实际上是如何工作的。拥有一些高级背景知道可能会有所帮助。</p>\n<p>UEFI 在固件级提供了很多基础架构来处理系统启动。它远不及 BIOS 那么简单。不像 BIOS，UEFI 真正地理解，要从不同程度上，磁盘分区、启动引导程序和操作系统等概念。</p>\n<p>你可以看一下 BIOS 引导过程，再看一下 UEFI 过程，看 UEFI 流程如何扩展各种位以解决特定问题。</p>\n<p>这 BIOS/MBR 查找引导程序的方式非常简陋，当你思考它时。它就像非特别的酱：这是在磁盘头一段极小的空间里包含神奇的代码，它只对系统固件有意义，只能用特殊工具来写它。这种方法存在几个问题。</p>\n<ul>\n<li>这不方便处理 - 你需要特殊的固件来写 MBR 分区， 也就只有一个办法搞清楚它是什么，dd 出内容然后分析它。</li>\n<li>如上所述，MBR 它本身没那么大不足以容纳许多现代引导程序。它所做的是安装它们自身的一小部分到 MBR 适当的位置，剩余的空间到磁盘常规 MBR 结束到第一分区开始之的空白空间。这有一个很大的问题（好吧，这整个设计就是个大问题，但是从未注意到），这就是关于第一分区的开始位置没有可靠的约定，因此很难确保会有足够的空间。通常可以认为，没有足够的空间用于某些引导加载程序配置。</li>\n<li>设计没有提供为选择引导目标（磁盘除外）的任何标准代理层或机制…但是对于人们想选择磁盘意外的引导目标。比如，他们想有个可启动的东西-通常是操作系统-每个磁盘。唯一的方式是这样，在 BIOS/MBR 时间里是引导程序来处理它；但是仍没有一个被广泛认可的约定来完成以正常的方式来完成这些。有许多许多的方法，没有一个可以与其他任何一个互操作，写一个在 OS/OS 安装代理层能干净地处理多重引导问题的工具那太难了。</li>\n<li>该设计没有提供从磁盘以外的任何东西引导的标准方法。我不想在这篇文章真正的讨论这个问题，但请注意，这是 UEFI 引导的另一个优势：它提供了从例如远程服务器引导的标准方式。</li>\n<li>没有提供机制可以用于配置高于固件的级别来配置固件的启动行为。</li>\n</ul>\n<p>所以你能想象 UEFI 精灵围坐在一起考虑这个问题，并提出了解决方案。取代固件只知道磁盘和每个磁盘上的“魔术”区域-引导加载程序代码可能驻留的位置，UEFI 对于处理启动引导的固件有更多的基础设施。让我们看看它定义的所有与这里相关的东西。</p>\n<h1 id=\"EFI-可执行文件\"><a href=\"#EFI-可执行文件\" class=\"headerlink\" title=\"EFI 可执行文件\"></a>EFI 可执行文件</h1><p>UEFI 规格定义了一种可执行格式并要求所有 UEFI 固件能够执行这种格式的代码。当您为本机 UEFI 编写引导加载程序时，你将以这种格式编写。这种方式十分简单明了，不需要过多的解释：这是个好东西，现在我们有了一个固件规范真正地定义了固件可执行通用代码格式。</p>\n<h1 id=\"GPT-GUID-分区表-格式\"><a href=\"#GPT-GUID-分区表-格式\" class=\"headerlink\" title=\"GPT(GUID 分区表)格式\"></a>GPT(GUID 分区表)格式</h1><p><a href=\"https://en.wikipedia.org/wiki/GUID_Partition_Table\">GUID 分区表</a> 格式非常贴符合 UEFI 规范，此外，没有什么特别复杂的或需要过多解释的，这只是规范提供的基础。GPT 只是做分区表的标准-信息在磁盘的头部，它定义了磁盘包含什么分区。它是在许多方面比 MBR/‘MS-DOS’ 做更好的分区标准，UEFI 规范要求符合 UEFI 的固件必须能够解释 GPT（它同样要求能够执行 MBR，为了向后兼容）。所有这些都是有用的基础：这里正在发生的事情是规范正在建立某些功能，固件层以上的所有内容都可以依赖于固件。</p>\n<h1 id=\"EFI-系统分区\"><a href=\"#EFI-系统分区\" class=\"headerlink\" title=\"EFI 系统分区\"></a>EFI 系统分区</h1><p>实际上，在修订本文时，我确实想将头放在 EFI 系统分区概念上，因为它非常精彩的部分。实际上，”EFI 系统分区“这概念正是回答 MBR 空间“特殊调味料”的问题。正如我们在上面看到的，在磁盘开始时一些未定义的空白空间的概念是“引导加载程序代码所在的位置”，这是一个非常糟糕的设计。EFI 系统分区就是来解决这个问题的。</p>\n<p>解决办法是：我们要求固件能够一些具体的文件系统。UEFI 规范要求合格的固件应该能读取 FAT12， FAT 格式的 FAT16 和 FAT32 变体。实际上，它所做的是编篆对那么格式特定的解释，因为他们在 UEFI 被接受时就已经存在了，就是说符合 UEFI 的固件必须能够读这些格式。规范如下：</p>\n<p>“被可扩展固件接口支持的文件系统是基于 FAT 文件系统。EFI 定义了明确记录和可测试的 FAT 版本。符合 EFI 规范</p>"},{"title":"路由器通过锐捷认证","date":"2018-12-18T16:00:00.000Z","comments":1,"_content":"\n# 为什么一般路由器不能用于校园联通网络认证？\n我们家里常用的路由器一般只支持 [PPPoE协议](https://baike.baidu.com/item/PPPOE/139247?fr=aladdin) , 而我们校园的联通网用的是锐捷认证的方式，这种拨号方式比较特殊所以一般路由器并不支持。[mentohust](https://baike.baidu.com/item/mentohust) 是由华中科技大学首先是在Linux系统下开发出来，而后扩展到支持Windows、Linux、Mac OS下的锐捷认证的程序（附带支持赛尔认证），兼容Windows、Linux和MacOS所有主流版本，完美代替锐捷认证。\n现在市面上的智能路由器的官方固件里一般都集成了这种认证方式，一些路由三方固件也支持这种认证方式，比如 `openwrt` , `ddwrt` , `Pandora` , `梅林` 这些。路由器里面装的就是 `Linux` 系统，就利用 `mentohust` 来实现锐捷认证。所以校园联通网还是可以使用路由器的。这里我讲述一种我自己使用的方式，用 ***极路由1S*** 来上网。至于再刷三方固件的来运行 `mentohust` 的方式也是可以的，只不过这里不做描述。\n\n<!--more-->\n# 具体操作\n\n## 准备材料\n> * 硬件部分\n> 淘宝上或者咸鱼，转转上去买一个 ***极路由1S*** 买新的一般在100左右，二手的50左右。建议大家买二手，因为路由器不容易坏，一般不用担心无法正常使用这个问题。\n> * 软件部分 \n> \n\n| 软件名 | 功能说明 |\n| ------ | -------- |\n| Putty | ssh连接 |\n| Winscp | 文件传输 |\n| Notepad++ | 编辑器 |\n| Mentohusttool | 抓包 |\n\n[**软件包下载连接**](https://github.com/Caffreyfans/Public-Source/releases/download/1.0/hiwifi-1S.zip)\n所需要的软件全部打包到压缩文件里，解压安装即可使用。软件只能在 `windows 64位` 系统上安装，如果你是其他类型的系统，请自行下载同名软件。软件下载好之后请安装到电脑上，以备使用，这些软件都是我从官方下载打包的，如果不放心请到官方下载同名软件。\n## 申请极路由开发者权限\n当我们拿到路由器并且上电之后，我们首先需要做的就是申请开发者权限。因为这个操作需要官方那边给你授权，这个授权过程会需要几天。申请开发者权限的主要目的是让极路由打开 `ssh` 服务。当我们打开了路由器的 `ssh` 服务就可以通过 `Putty` 远程登陆到路由器操作了。\n\n1. 首先让路由器联网，联网方式可以用无线中继的方式或者用别人连好网的路由器牵根线到自己的路由器![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/3.png) \n\n2. 点开智能插件，选择插件市场![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/1.png) \n\n3. 在全部插件里面选择开发者模式，点击安装![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/2.png) \n\n\n## 抓包与修改包文件\n我们需要用到 `Mentohusttool` 抓包，然后用 `Notepad++` 修改包文件,把自己联通的网线连接到自己的电脑上\n\n1. 打开 `MentoHUSTTool-RP.exe` 后选择开始，弹出来的文件选择框里，从你的 `成都信息工程大学校园网认证客户端` 的安装包文件里选中 `8021.exe` 这个应用程序，然后进入抓包就绪态(客户端默认安装位置为 `C:\\Program Files\\Ruijie Networks\\Ruijie Supplicant` ,自定义位置请自行找到)\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/5.png)\n\n2. 然后在 `成都信息工程大学校园网认证客户端` 里填好自己的账号密码，点击连接抓包程序会自己抓到包\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/4.png)\n\n3. 将抓到的包命名成 `1` 保存在桌面上\n这里需要注意这个 `1.mpf` 文件名不能修改成其他的，因为后面的脚本里设置的就是这个名字，修改成其他的会出错。\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/7.png)\n\n4. 将得到的 `1.mpf` 文件用 `Notepad++` 打开，在 `Notepad++` 里选择插件管理\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/6.png)\n\n5. 在插件管理器里找到 `HEX-Editor` 点击 `Install` 安装，安装成功后重启 `Notepad++`\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/9.png)\n\n6. 在插件里选择 `Hex-Editor` 找到 `View in HEX` 选项并点击，之后你会看到打开文件内容有所变化\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/10.png)\n\n7. 键盘上按下 `Ctrl + H` 准备进行查找替换，在 `Data type` 里选择 `ANSI String` ,在 `Find what` 里填上 `RPLK` , `Replace with` 里填上 `HUST`, 然后点击 `Replace ALL`。修改好之后保存文件,然后就可以关闭前面打开过的程序了\n![Notepad++](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/11.png)\n\n\n## 上传文件并执行 ***Shell*** 命令\n用一根网线连接的你的电脑,或者连接路由器的 `WiFi` ,待你路由器打开了 `开发者模式` 后就可以执行这步操作了\n\n1. 打开 `Winscp` ,在文件协议里选择 `SCP` ,主机名填上 `hiwifi.com` ,端口号填上 `1022` ,用户名填上 `root` ,密码填上你路由器登录密码(默认为 `admin` )\n\n![Winscp](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/12.png)\n\n2. 然后直接将你桌面上修改好的 `1.mpf` 文件直接拖到路由器的 `/root` 文件夹下，待文件传送好了就可以关闭 `Winscp` 了\n![Winscp](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/13.png)\n\n3. 打开 `Putty` , `Host Name` 里面填上 `hiwifi.com` , `Port` 里面填上 `1022` ,然后点击 `Open` 选项，然后在弹出的新窗口的 `login as` 里填上 `root` 之后按下键盘的 `回车键`,然后输入你路由器的登录,密码跟 `Winscp` 里填的是一样的，填密码的时候回没有回显，填好密码之后按下 `回车键` ,成功登录到路由器后台\n\n4. 执行 `shell` 命令,将下列命令复制并粘贴到刚刚打开的路由器命令行里(在putty里点击鼠标右键粘贴),然后按下回车,等脚本执行完了就可以关闭 `Putty` 了\n``` shell\ncd /tmp &&curl -k -o shadow.sh https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/scripts/shadow.sh && sh shadow.sh && rm shadow.sh\n```\n![Putty](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/15.png)\n\n## 复制MAC与开启锐捷认证\n执行完这步就能成功让路由器联网了\n\n1. 在电脑上按下 `Win + r` ,然后在里面输入 `cmd`\n![CMD](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/21.png)\n\n2. 输入 `ipconfig -all` 查询电脑的 `MAC` 地址\n![MAC](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/22.png)\n\n3. 在路由器管理界面的首页中点击 `MAC地址克隆`,在里面选择 `手动输入` ,填上刚才获得的 `MAC` 地址，其中 `-` 用 `:` 代替,然后点击保存\n![MAC](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/23.png)\n\n4. 在路由器的 `互联网` 里打开 `锐捷认证` ,填上图示信息,点击 `8021x.exe` 后面的选择文件并在 `成都信息工程大学校园网认证客户端` 的安装文件中选取同名文件上传, `SuConfig.dat` 、`W32N55.dll` 执行相同操作,然后点击 `提交`\n![锐捷认证](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/17.png)\n\n5. 点击 `查看日志` 当出现如图信息表明认证成功！\n![锐捷认证](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/18.png)\n\n\n## 彩蛋\n\n\n1. 路由器管理界面有个 `安全上网` 这其实是 `SS` 客户端只要你填上你的节点信息,并开启就可以让路由器下的所有设备实现科学上网\n![安全上网](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/20.png)\n\n2. 成功开启 `SS` 之后\n![安全上网](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/19.png)\n","source":"_posts/路由器通过锐捷认证.md","raw":"---\ntitle: 路由器通过锐捷认证\ndate: 2018-12-19\ncategories: 路由器\ncomments: true\n---\n\n# 为什么一般路由器不能用于校园联通网络认证？\n我们家里常用的路由器一般只支持 [PPPoE协议](https://baike.baidu.com/item/PPPOE/139247?fr=aladdin) , 而我们校园的联通网用的是锐捷认证的方式，这种拨号方式比较特殊所以一般路由器并不支持。[mentohust](https://baike.baidu.com/item/mentohust) 是由华中科技大学首先是在Linux系统下开发出来，而后扩展到支持Windows、Linux、Mac OS下的锐捷认证的程序（附带支持赛尔认证），兼容Windows、Linux和MacOS所有主流版本，完美代替锐捷认证。\n现在市面上的智能路由器的官方固件里一般都集成了这种认证方式，一些路由三方固件也支持这种认证方式，比如 `openwrt` , `ddwrt` , `Pandora` , `梅林` 这些。路由器里面装的就是 `Linux` 系统，就利用 `mentohust` 来实现锐捷认证。所以校园联通网还是可以使用路由器的。这里我讲述一种我自己使用的方式，用 ***极路由1S*** 来上网。至于再刷三方固件的来运行 `mentohust` 的方式也是可以的，只不过这里不做描述。\n\n<!--more-->\n# 具体操作\n\n## 准备材料\n> * 硬件部分\n> 淘宝上或者咸鱼，转转上去买一个 ***极路由1S*** 买新的一般在100左右，二手的50左右。建议大家买二手，因为路由器不容易坏，一般不用担心无法正常使用这个问题。\n> * 软件部分 \n> \n\n| 软件名 | 功能说明 |\n| ------ | -------- |\n| Putty | ssh连接 |\n| Winscp | 文件传输 |\n| Notepad++ | 编辑器 |\n| Mentohusttool | 抓包 |\n\n[**软件包下载连接**](https://github.com/Caffreyfans/Public-Source/releases/download/1.0/hiwifi-1S.zip)\n所需要的软件全部打包到压缩文件里，解压安装即可使用。软件只能在 `windows 64位` 系统上安装，如果你是其他类型的系统，请自行下载同名软件。软件下载好之后请安装到电脑上，以备使用，这些软件都是我从官方下载打包的，如果不放心请到官方下载同名软件。\n## 申请极路由开发者权限\n当我们拿到路由器并且上电之后，我们首先需要做的就是申请开发者权限。因为这个操作需要官方那边给你授权，这个授权过程会需要几天。申请开发者权限的主要目的是让极路由打开 `ssh` 服务。当我们打开了路由器的 `ssh` 服务就可以通过 `Putty` 远程登陆到路由器操作了。\n\n1. 首先让路由器联网，联网方式可以用无线中继的方式或者用别人连好网的路由器牵根线到自己的路由器![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/3.png) \n\n2. 点开智能插件，选择插件市场![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/1.png) \n\n3. 在全部插件里面选择开发者模式，点击安装![已连接网络图](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/2.png) \n\n\n## 抓包与修改包文件\n我们需要用到 `Mentohusttool` 抓包，然后用 `Notepad++` 修改包文件,把自己联通的网线连接到自己的电脑上\n\n1. 打开 `MentoHUSTTool-RP.exe` 后选择开始，弹出来的文件选择框里，从你的 `成都信息工程大学校园网认证客户端` 的安装包文件里选中 `8021.exe` 这个应用程序，然后进入抓包就绪态(客户端默认安装位置为 `C:\\Program Files\\Ruijie Networks\\Ruijie Supplicant` ,自定义位置请自行找到)\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/5.png)\n\n2. 然后在 `成都信息工程大学校园网认证客户端` 里填好自己的账号密码，点击连接抓包程序会自己抓到包\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/4.png)\n\n3. 将抓到的包命名成 `1` 保存在桌面上\n这里需要注意这个 `1.mpf` 文件名不能修改成其他的，因为后面的脚本里设置的就是这个名字，修改成其他的会出错。\n![MentoHUSTool-RP.exe](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/7.png)\n\n4. 将得到的 `1.mpf` 文件用 `Notepad++` 打开，在 `Notepad++` 里选择插件管理\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/6.png)\n\n5. 在插件管理器里找到 `HEX-Editor` 点击 `Install` 安装，安装成功后重启 `Notepad++`\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/9.png)\n\n6. 在插件里选择 `Hex-Editor` 找到 `View in HEX` 选项并点击，之后你会看到打开文件内容有所变化\n![Notepad](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/10.png)\n\n7. 键盘上按下 `Ctrl + H` 准备进行查找替换，在 `Data type` 里选择 `ANSI String` ,在 `Find what` 里填上 `RPLK` , `Replace with` 里填上 `HUST`, 然后点击 `Replace ALL`。修改好之后保存文件,然后就可以关闭前面打开过的程序了\n![Notepad++](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/11.png)\n\n\n## 上传文件并执行 ***Shell*** 命令\n用一根网线连接的你的电脑,或者连接路由器的 `WiFi` ,待你路由器打开了 `开发者模式` 后就可以执行这步操作了\n\n1. 打开 `Winscp` ,在文件协议里选择 `SCP` ,主机名填上 `hiwifi.com` ,端口号填上 `1022` ,用户名填上 `root` ,密码填上你路由器登录密码(默认为 `admin` )\n\n![Winscp](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/12.png)\n\n2. 然后直接将你桌面上修改好的 `1.mpf` 文件直接拖到路由器的 `/root` 文件夹下，待文件传送好了就可以关闭 `Winscp` 了\n![Winscp](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/13.png)\n\n3. 打开 `Putty` , `Host Name` 里面填上 `hiwifi.com` , `Port` 里面填上 `1022` ,然后点击 `Open` 选项，然后在弹出的新窗口的 `login as` 里填上 `root` 之后按下键盘的 `回车键`,然后输入你路由器的登录,密码跟 `Winscp` 里填的是一样的，填密码的时候回没有回显，填好密码之后按下 `回车键` ,成功登录到路由器后台\n\n4. 执行 `shell` 命令,将下列命令复制并粘贴到刚刚打开的路由器命令行里(在putty里点击鼠标右键粘贴),然后按下回车,等脚本执行完了就可以关闭 `Putty` 了\n``` shell\ncd /tmp &&curl -k -o shadow.sh https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/scripts/shadow.sh && sh shadow.sh && rm shadow.sh\n```\n![Putty](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/15.png)\n\n## 复制MAC与开启锐捷认证\n执行完这步就能成功让路由器联网了\n\n1. 在电脑上按下 `Win + r` ,然后在里面输入 `cmd`\n![CMD](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/21.png)\n\n2. 输入 `ipconfig -all` 查询电脑的 `MAC` 地址\n![MAC](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/22.png)\n\n3. 在路由器管理界面的首页中点击 `MAC地址克隆`,在里面选择 `手动输入` ,填上刚才获得的 `MAC` 地址，其中 `-` 用 `:` 代替,然后点击保存\n![MAC](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/23.png)\n\n4. 在路由器的 `互联网` 里打开 `锐捷认证` ,填上图示信息,点击 `8021x.exe` 后面的选择文件并在 `成都信息工程大学校园网认证客户端` 的安装文件中选取同名文件上传, `SuConfig.dat` 、`W32N55.dll` 执行相同操作,然后点击 `提交`\n![锐捷认证](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/17.png)\n\n5. 点击 `查看日志` 当出现如图信息表明认证成功！\n![锐捷认证](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/18.png)\n\n\n## 彩蛋\n\n\n1. 路由器管理界面有个 `安全上网` 这其实是 `SS` 客户端只要你填上你的节点信息,并开启就可以让路由器下的所有设备实现科学上网\n![安全上网](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/20.png)\n\n2. 成功开启 `SS` 之后\n![安全上网](https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/19.png)\n","slug":"路由器通过锐捷认证","published":1,"updated":"2021-03-10T15:12:25.925Z","layout":"post","photos":[],"link":"","_id":"ckm3l2tri000ia5jx04ogg2dn","content":"<h1 id=\"为什么一般路由器不能用于校园联通网络认证？\"><a href=\"#为什么一般路由器不能用于校园联通网络认证？\" class=\"headerlink\" title=\"为什么一般路由器不能用于校园联通网络认证？\"></a>为什么一般路由器不能用于校园联通网络认证？</h1><p>我们家里常用的路由器一般只支持 <a href=\"https://baike.baidu.com/item/PPPOE/139247?fr=aladdin\">PPPoE协议</a> , 而我们校园的联通网用的是锐捷认证的方式，这种拨号方式比较特殊所以一般路由器并不支持。<a href=\"https://baike.baidu.com/item/mentohust\">mentohust</a> 是由华中科技大学首先是在Linux系统下开发出来，而后扩展到支持Windows、Linux、Mac OS下的锐捷认证的程序（附带支持赛尔认证），兼容Windows、Linux和MacOS所有主流版本，完美代替锐捷认证。<br>现在市面上的智能路由器的官方固件里一般都集成了这种认证方式，一些路由三方固件也支持这种认证方式，比如 <code>openwrt</code> , <code>ddwrt</code> , <code>Pandora</code> , <code>梅林</code> 这些。路由器里面装的就是 <code>Linux</code> 系统，就利用 <code>mentohust</code> 来实现锐捷认证。所以校园联通网还是可以使用路由器的。这里我讲述一种我自己使用的方式，用 <em><strong>极路由1S</strong></em> 来上网。至于再刷三方固件的来运行 <code>mentohust</code> 的方式也是可以的，只不过这里不做描述。</p>\n<span id=\"more\"></span>\n<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><h2 id=\"准备材料\"><a href=\"#准备材料\" class=\"headerlink\" title=\"准备材料\"></a>准备材料</h2><blockquote>\n<ul>\n<li>硬件部分<br>淘宝上或者咸鱼，转转上去买一个 <em><strong>极路由1S</strong></em> 买新的一般在100左右，二手的50左右。建议大家买二手，因为路由器不容易坏，一般不用担心无法正常使用这个问题。</li>\n<li>软件部分 </li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>软件名</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Putty</td>\n<td>ssh连接</td>\n</tr>\n<tr>\n<td>Winscp</td>\n<td>文件传输</td>\n</tr>\n<tr>\n<td>Notepad++</td>\n<td>编辑器</td>\n</tr>\n<tr>\n<td>Mentohusttool</td>\n<td>抓包</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://github.com/Caffreyfans/Public-Source/releases/download/1.0/hiwifi-1S.zip\"><strong>软件包下载连接</strong></a><br>所需要的软件全部打包到压缩文件里，解压安装即可使用。软件只能在 <code>windows 64位</code> 系统上安装，如果你是其他类型的系统，请自行下载同名软件。软件下载好之后请安装到电脑上，以备使用，这些软件都是我从官方下载打包的，如果不放心请到官方下载同名软件。</p>\n<h2 id=\"申请极路由开发者权限\"><a href=\"#申请极路由开发者权限\" class=\"headerlink\" title=\"申请极路由开发者权限\"></a>申请极路由开发者权限</h2><p>当我们拿到路由器并且上电之后，我们首先需要做的就是申请开发者权限。因为这个操作需要官方那边给你授权，这个授权过程会需要几天。申请开发者权限的主要目的是让极路由打开 <code>ssh</code> 服务。当我们打开了路由器的 <code>ssh</code> 服务就可以通过 <code>Putty</code> 远程登陆到路由器操作了。</p>\n<ol>\n<li><p>首先让路由器联网，联网方式可以用无线中继的方式或者用别人连好网的路由器牵根线到自己的路由器<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/3.png\" alt=\"已连接网络图\"> </p>\n</li>\n<li><p>点开智能插件，选择插件市场<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/1.png\" alt=\"已连接网络图\"> </p>\n</li>\n<li><p>在全部插件里面选择开发者模式，点击安装<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/2.png\" alt=\"已连接网络图\"> </p>\n</li>\n</ol>\n<h2 id=\"抓包与修改包文件\"><a href=\"#抓包与修改包文件\" class=\"headerlink\" title=\"抓包与修改包文件\"></a>抓包与修改包文件</h2><p>我们需要用到 <code>Mentohusttool</code> 抓包，然后用 <code>Notepad++</code> 修改包文件,把自己联通的网线连接到自己的电脑上</p>\n<ol>\n<li><p>打开 <code>MentoHUSTTool-RP.exe</code> 后选择开始，弹出来的文件选择框里，从你的 <code>成都信息工程大学校园网认证客户端</code> 的安装包文件里选中 <code>8021.exe</code> 这个应用程序，然后进入抓包就绪态(客户端默认安装位置为 <code>C:\\Program Files\\Ruijie Networks\\Ruijie Supplicant</code> ,自定义位置请自行找到)<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/5.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>然后在 <code>成都信息工程大学校园网认证客户端</code> 里填好自己的账号密码，点击连接抓包程序会自己抓到包<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/4.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>将抓到的包命名成 <code>1</code> 保存在桌面上<br>这里需要注意这个 <code>1.mpf</code> 文件名不能修改成其他的，因为后面的脚本里设置的就是这个名字，修改成其他的会出错。<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/7.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>将得到的 <code>1.mpf</code> 文件用 <code>Notepad++</code> 打开，在 <code>Notepad++</code> 里选择插件管理<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/6.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>在插件管理器里找到 <code>HEX-Editor</code> 点击 <code>Install</code> 安装，安装成功后重启 <code>Notepad++</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/9.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>在插件里选择 <code>Hex-Editor</code> 找到 <code>View in HEX</code> 选项并点击，之后你会看到打开文件内容有所变化<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/10.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>键盘上按下 <code>Ctrl + H</code> 准备进行查找替换，在 <code>Data type</code> 里选择 <code>ANSI String</code> ,在 <code>Find what</code> 里填上 <code>RPLK</code> , <code>Replace with</code> 里填上 <code>HUST</code>, 然后点击 <code>Replace ALL</code>。修改好之后保存文件,然后就可以关闭前面打开过的程序了<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/11.png\" alt=\"Notepad++\"></p>\n</li>\n</ol>\n<h2 id=\"上传文件并执行-Shell-命令\"><a href=\"#上传文件并执行-Shell-命令\" class=\"headerlink\" title=\"上传文件并执行 Shell 命令\"></a>上传文件并执行 <em><strong>Shell</strong></em> 命令</h2><p>用一根网线连接的你的电脑,或者连接路由器的 <code>WiFi</code> ,待你路由器打开了 <code>开发者模式</code> 后就可以执行这步操作了</p>\n<ol>\n<li>打开 <code>Winscp</code> ,在文件协议里选择 <code>SCP</code> ,主机名填上 <code>hiwifi.com</code> ,端口号填上 <code>1022</code> ,用户名填上 <code>root</code> ,密码填上你路由器登录密码(默认为 <code>admin</code> )</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/12.png\" alt=\"Winscp\"></p>\n<ol start=\"2\">\n<li><p>然后直接将你桌面上修改好的 <code>1.mpf</code> 文件直接拖到路由器的 <code>/root</code> 文件夹下，待文件传送好了就可以关闭 <code>Winscp</code> 了<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/13.png\" alt=\"Winscp\"></p>\n</li>\n<li><p>打开 <code>Putty</code> , <code>Host Name</code> 里面填上 <code>hiwifi.com</code> , <code>Port</code> 里面填上 <code>1022</code> ,然后点击 <code>Open</code> 选项，然后在弹出的新窗口的 <code>login as</code> 里填上 <code>root</code> 之后按下键盘的 <code>回车键</code>,然后输入你路由器的登录,密码跟 <code>Winscp</code> 里填的是一样的，填密码的时候回没有回显，填好密码之后按下 <code>回车键</code> ,成功登录到路由器后台</p>\n</li>\n<li><p>执行 <code>shell</code> 命令,将下列命令复制并粘贴到刚刚打开的路由器命令行里(在putty里点击鼠标右键粘贴),然后按下回车,等脚本执行完了就可以关闭 <code>Putty</code> 了</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> /tmp <span class=\"token operator\">&amp;&amp;</span><span class=\"token function\">curl</span> -k -o shadow.sh https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/scripts/shadow.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sh</span> shadow.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">rm</span> shadow.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/15.png\" alt=\"Putty\"></p>\n</li>\n</ol>\n<h2 id=\"复制MAC与开启锐捷认证\"><a href=\"#复制MAC与开启锐捷认证\" class=\"headerlink\" title=\"复制MAC与开启锐捷认证\"></a>复制MAC与开启锐捷认证</h2><p>执行完这步就能成功让路由器联网了</p>\n<ol>\n<li><p>在电脑上按下 <code>Win + r</code> ,然后在里面输入 <code>cmd</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/21.png\" alt=\"CMD\"></p>\n</li>\n<li><p>输入 <code>ipconfig -all</code> 查询电脑的 <code>MAC</code> 地址<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/22.png\" alt=\"MAC\"></p>\n</li>\n<li><p>在路由器管理界面的首页中点击 <code>MAC地址克隆</code>,在里面选择 <code>手动输入</code> ,填上刚才获得的 <code>MAC</code> 地址，其中 <code>-</code> 用 <code>:</code> 代替,然后点击保存<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/23.png\" alt=\"MAC\"></p>\n</li>\n<li><p>在路由器的 <code>互联网</code> 里打开 <code>锐捷认证</code> ,填上图示信息,点击 <code>8021x.exe</code> 后面的选择文件并在 <code>成都信息工程大学校园网认证客户端</code> 的安装文件中选取同名文件上传, <code>SuConfig.dat</code> 、<code>W32N55.dll</code> 执行相同操作,然后点击 <code>提交</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/17.png\" alt=\"锐捷认证\"></p>\n</li>\n<li><p>点击 <code>查看日志</code> 当出现如图信息表明认证成功！<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/18.png\" alt=\"锐捷认证\"></p>\n</li>\n</ol>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><ol>\n<li><p>路由器管理界面有个 <code>安全上网</code> 这其实是 <code>SS</code> 客户端只要你填上你的节点信息,并开启就可以让路由器下的所有设备实现科学上网<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/20.png\" alt=\"安全上网\"></p>\n</li>\n<li><p>成功开启 <code>SS</code> 之后<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/19.png\" alt=\"安全上网\"></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"为什么一般路由器不能用于校园联通网络认证？\"><a href=\"#为什么一般路由器不能用于校园联通网络认证？\" class=\"headerlink\" title=\"为什么一般路由器不能用于校园联通网络认证？\"></a>为什么一般路由器不能用于校园联通网络认证？</h1><p>我们家里常用的路由器一般只支持 <a href=\"https://baike.baidu.com/item/PPPOE/139247?fr=aladdin\">PPPoE协议</a> , 而我们校园的联通网用的是锐捷认证的方式，这种拨号方式比较特殊所以一般路由器并不支持。<a href=\"https://baike.baidu.com/item/mentohust\">mentohust</a> 是由华中科技大学首先是在Linux系统下开发出来，而后扩展到支持Windows、Linux、Mac OS下的锐捷认证的程序（附带支持赛尔认证），兼容Windows、Linux和MacOS所有主流版本，完美代替锐捷认证。<br>现在市面上的智能路由器的官方固件里一般都集成了这种认证方式，一些路由三方固件也支持这种认证方式，比如 <code>openwrt</code> , <code>ddwrt</code> , <code>Pandora</code> , <code>梅林</code> 这些。路由器里面装的就是 <code>Linux</code> 系统，就利用 <code>mentohust</code> 来实现锐捷认证。所以校园联通网还是可以使用路由器的。这里我讲述一种我自己使用的方式，用 <em><strong>极路由1S</strong></em> 来上网。至于再刷三方固件的来运行 <code>mentohust</code> 的方式也是可以的，只不过这里不做描述。</p>","more":"<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><h2 id=\"准备材料\"><a href=\"#准备材料\" class=\"headerlink\" title=\"准备材料\"></a>准备材料</h2><blockquote>\n<ul>\n<li>硬件部分<br>淘宝上或者咸鱼，转转上去买一个 <em><strong>极路由1S</strong></em> 买新的一般在100左右，二手的50左右。建议大家买二手，因为路由器不容易坏，一般不用担心无法正常使用这个问题。</li>\n<li>软件部分 </li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>软件名</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Putty</td>\n<td>ssh连接</td>\n</tr>\n<tr>\n<td>Winscp</td>\n<td>文件传输</td>\n</tr>\n<tr>\n<td>Notepad++</td>\n<td>编辑器</td>\n</tr>\n<tr>\n<td>Mentohusttool</td>\n<td>抓包</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://github.com/Caffreyfans/Public-Source/releases/download/1.0/hiwifi-1S.zip\"><strong>软件包下载连接</strong></a><br>所需要的软件全部打包到压缩文件里，解压安装即可使用。软件只能在 <code>windows 64位</code> 系统上安装，如果你是其他类型的系统，请自行下载同名软件。软件下载好之后请安装到电脑上，以备使用，这些软件都是我从官方下载打包的，如果不放心请到官方下载同名软件。</p>\n<h2 id=\"申请极路由开发者权限\"><a href=\"#申请极路由开发者权限\" class=\"headerlink\" title=\"申请极路由开发者权限\"></a>申请极路由开发者权限</h2><p>当我们拿到路由器并且上电之后，我们首先需要做的就是申请开发者权限。因为这个操作需要官方那边给你授权，这个授权过程会需要几天。申请开发者权限的主要目的是让极路由打开 <code>ssh</code> 服务。当我们打开了路由器的 <code>ssh</code> 服务就可以通过 <code>Putty</code> 远程登陆到路由器操作了。</p>\n<ol>\n<li><p>首先让路由器联网，联网方式可以用无线中继的方式或者用别人连好网的路由器牵根线到自己的路由器<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/3.png\" alt=\"已连接网络图\"> </p>\n</li>\n<li><p>点开智能插件，选择插件市场<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/1.png\" alt=\"已连接网络图\"> </p>\n</li>\n<li><p>在全部插件里面选择开发者模式，点击安装<img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/2.png\" alt=\"已连接网络图\"> </p>\n</li>\n</ol>\n<h2 id=\"抓包与修改包文件\"><a href=\"#抓包与修改包文件\" class=\"headerlink\" title=\"抓包与修改包文件\"></a>抓包与修改包文件</h2><p>我们需要用到 <code>Mentohusttool</code> 抓包，然后用 <code>Notepad++</code> 修改包文件,把自己联通的网线连接到自己的电脑上</p>\n<ol>\n<li><p>打开 <code>MentoHUSTTool-RP.exe</code> 后选择开始，弹出来的文件选择框里，从你的 <code>成都信息工程大学校园网认证客户端</code> 的安装包文件里选中 <code>8021.exe</code> 这个应用程序，然后进入抓包就绪态(客户端默认安装位置为 <code>C:\\Program Files\\Ruijie Networks\\Ruijie Supplicant</code> ,自定义位置请自行找到)<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/5.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>然后在 <code>成都信息工程大学校园网认证客户端</code> 里填好自己的账号密码，点击连接抓包程序会自己抓到包<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/4.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>将抓到的包命名成 <code>1</code> 保存在桌面上<br>这里需要注意这个 <code>1.mpf</code> 文件名不能修改成其他的，因为后面的脚本里设置的就是这个名字，修改成其他的会出错。<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/7.png\" alt=\"MentoHUSTool-RP.exe\"></p>\n</li>\n<li><p>将得到的 <code>1.mpf</code> 文件用 <code>Notepad++</code> 打开，在 <code>Notepad++</code> 里选择插件管理<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/6.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>在插件管理器里找到 <code>HEX-Editor</code> 点击 <code>Install</code> 安装，安装成功后重启 <code>Notepad++</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/9.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>在插件里选择 <code>Hex-Editor</code> 找到 <code>View in HEX</code> 选项并点击，之后你会看到打开文件内容有所变化<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/10.png\" alt=\"Notepad\"></p>\n</li>\n<li><p>键盘上按下 <code>Ctrl + H</code> 准备进行查找替换，在 <code>Data type</code> 里选择 <code>ANSI String</code> ,在 <code>Find what</code> 里填上 <code>RPLK</code> , <code>Replace with</code> 里填上 <code>HUST</code>, 然后点击 <code>Replace ALL</code>。修改好之后保存文件,然后就可以关闭前面打开过的程序了<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/11.png\" alt=\"Notepad++\"></p>\n</li>\n</ol>\n<h2 id=\"上传文件并执行-Shell-命令\"><a href=\"#上传文件并执行-Shell-命令\" class=\"headerlink\" title=\"上传文件并执行 Shell 命令\"></a>上传文件并执行 <em><strong>Shell</strong></em> 命令</h2><p>用一根网线连接的你的电脑,或者连接路由器的 <code>WiFi</code> ,待你路由器打开了 <code>开发者模式</code> 后就可以执行这步操作了</p>\n<ol>\n<li>打开 <code>Winscp</code> ,在文件协议里选择 <code>SCP</code> ,主机名填上 <code>hiwifi.com</code> ,端口号填上 <code>1022</code> ,用户名填上 <code>root</code> ,密码填上你路由器登录密码(默认为 <code>admin</code> )</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/12.png\" alt=\"Winscp\"></p>\n<ol start=\"2\">\n<li><p>然后直接将你桌面上修改好的 <code>1.mpf</code> 文件直接拖到路由器的 <code>/root</code> 文件夹下，待文件传送好了就可以关闭 <code>Winscp</code> 了<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/13.png\" alt=\"Winscp\"></p>\n</li>\n<li><p>打开 <code>Putty</code> , <code>Host Name</code> 里面填上 <code>hiwifi.com</code> , <code>Port</code> 里面填上 <code>1022</code> ,然后点击 <code>Open</code> 选项，然后在弹出的新窗口的 <code>login as</code> 里填上 <code>root</code> 之后按下键盘的 <code>回车键</code>,然后输入你路由器的登录,密码跟 <code>Winscp</code> 里填的是一样的，填密码的时候回没有回显，填好密码之后按下 <code>回车键</code> ,成功登录到路由器后台</p>\n</li>\n<li><p>执行 <code>shell</code> 命令,将下列命令复制并粘贴到刚刚打开的路由器命令行里(在putty里点击鼠标右键粘贴),然后按下回车,等脚本执行完了就可以关闭 <code>Putty</code> 了</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token builtin class-name\">cd</span> /tmp <span class=\"token operator\">&amp;&amp;</span><span class=\"token function\">curl</span> -k -o shadow.sh https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/scripts/shadow.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sh</span> shadow.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">rm</span> shadow.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/15.png\" alt=\"Putty\"></p>\n</li>\n</ol>\n<h2 id=\"复制MAC与开启锐捷认证\"><a href=\"#复制MAC与开启锐捷认证\" class=\"headerlink\" title=\"复制MAC与开启锐捷认证\"></a>复制MAC与开启锐捷认证</h2><p>执行完这步就能成功让路由器联网了</p>\n<ol>\n<li><p>在电脑上按下 <code>Win + r</code> ,然后在里面输入 <code>cmd</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/21.png\" alt=\"CMD\"></p>\n</li>\n<li><p>输入 <code>ipconfig -all</code> 查询电脑的 <code>MAC</code> 地址<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/22.png\" alt=\"MAC\"></p>\n</li>\n<li><p>在路由器管理界面的首页中点击 <code>MAC地址克隆</code>,在里面选择 <code>手动输入</code> ,填上刚才获得的 <code>MAC</code> 地址，其中 <code>-</code> 用 <code>:</code> 代替,然后点击保存<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/23.png\" alt=\"MAC\"></p>\n</li>\n<li><p>在路由器的 <code>互联网</code> 里打开 <code>锐捷认证</code> ,填上图示信息,点击 <code>8021x.exe</code> 后面的选择文件并在 <code>成都信息工程大学校园网认证客户端</code> 的安装文件中选取同名文件上传, <code>SuConfig.dat</code> 、<code>W32N55.dll</code> 执行相同操作,然后点击 <code>提交</code><br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/17.png\" alt=\"锐捷认证\"></p>\n</li>\n<li><p>点击 <code>查看日志</code> 当出现如图信息表明认证成功！<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/18.png\" alt=\"锐捷认证\"></p>\n</li>\n</ol>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><ol>\n<li><p>路由器管理界面有个 <code>安全上网</code> 这其实是 <code>SS</code> 客户端只要你填上你的节点信息,并开启就可以让路由器下的所有设备实现科学上网<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/20.png\" alt=\"安全上网\"></p>\n</li>\n<li><p>成功开启 <code>SS</code> 之后<br><img src=\"https://raw.githubusercontent.com/Caffreyfans/Public-Source/master/pictures/router%20pictures/19.png\" alt=\"安全上网\"></p>\n</li>\n</ol>"},{"title":"软件测试复习概要","date":"2019-01-04T16:00:00.000Z","_content":"\n- [x] 软件测试常用的概念，常用的分类，测试的目的，方法等\n- [x] 软件测试静态测试的概念，技术，分类，执行过程，涉及的活动，测试的对象等\n- [x] 软件测试的模型分类，个各模型的特点，适用场景，规划的阶段及其关系，表达的图形等\n- [x] 面向对象的软件测试概念，与软件开发以及普通测试的关系等\n- [x] 集成测试、系统测试的概念，划分的阶段，先后执行的顺序，输入、输出成果物等\n- [x] 黑盒测试、白盒测试的概念，常用的方法，测试用例的设计过程，以及执行的过程如何实施等\n- [x] 等价类划分、边界值测试、三明治集成测试等概念、用例设计、实施过程\n- [x] 因果图法的概念，用例设计，执行步骤等\n- [x] 基本路径测试法概念，用例设计过程，实施执行过程等（控制流图画法、环形复杂度计算、基本路径获取、用例设计及执行等）\n- [x] 单元测试的概念，主要任务，使用的方法等\n- [x] 软件测试与调试的区别与联系，软件缺陷的概念及其相关知识\n\n<!-- ttoc -->\n\n<!--more-->\n## 1. 软件测试\n### 1.1 软件测试概念\n1. IEEE 在1983年将软件测试定义为“使用人工或者自动化手段运行或测定某个系统的过程，其目的在于检验他是否满足规定的需求或者是弄清预期结果与实际结果之间的差别“，该定义明确地提出了软件测试以检验是否为目标。\n2. Myers则认为软件测试“是为了发现错误而执行的程序过程”，明确提出了“寻找错误”是测试目的。\n3. 从软件质量保证的角度看，软件测试是一种重要的软件质量保证活动，其动机是通过一些经济、高效的方法，捕捉软件中的错误，从而达到保证软件内在质量的目的。\n\n### 1.2. 软件测试目的\n* 软件测试是为了发现错误而执行程序的过程\n* 测试是为了证明程序有错，而不是证明程序无错\n* 一个好的测试用例在于他能发现至今未发现的错误\n* 一个成功的测试是发现了至今未发现的错误的测试\n\n### 1.3. 软件测试技术分类\n|分类方法||\n|-|-|\n|从是否需要执行被测软件的角度|静态测试、动态测试|\n|从软件测试用例实际方法|黑盒测试、白盒测试|\n|按照软件测试的策略和过程|单元测试、集成测试、确认测试、系统测试、验收测试|\n\n## 2 静态测试\n### 2.1. 静态测试概念\n那些不利用计算机运行被测程序，而是通过其他手段达到测试目的的方法称作静态测试。换句话说，就是计算机并不真正运行被测试的程序，如在项目开发中存在着大量的规格说明，而说明规格是无法用计算机来运行的，所以对于这些软件的规格说明的测试就属于静态测试。\n\n### 2.2. 静态测试主要方法\n- 主要方法：**代码检查、走查、桌面检查、同行评分**\n  - **代码检查**: 所谓代码检查，是以组为单位阅读代码，他是一系列规则和错误检查技术的集合。对代码检查的大多数讨论都集中在规程、所要填写的表格等。这里对整个规程进行简短的概述。\n     - 为代码检查分发材料、安排进程\n     - 在代码检查中起主要作用\n     - 记录发现的所有错误\n     - 确保所有错误能够及时得到修正\n  - **代码走查**：代码走查与代码检查很相似，都是以小组我单位进行代码阅读，是一系列规程和错误检查技术的集合。代码走查的过程与代码检查大体相同，代码走查也是采用持续一至两个小时的不间断会议的形式。但是稍微所有不同，采用的错误检查技术也不一样。\n    代码走查小组有3~5人组成，其中一个人扮演类似代码检查过程中“协调人员”的角色，一个人担任秘书（负责记录所有查出的错误），还有一个人担任测试人员。建议在代码走查小组这最好包括如下人员：\n    （1）一位经验丰富的程序员；\n    （2）一位程序设计语言专家；\n    （3）一位初级程序员（可以给出新颖、不带偏见的观点）；\n    （4）将要负责程序维护的人员\n    （5）一位其他项目的人员\n    （6）一位来自该软件编程小组的程序员\n\n  - **桌面检查**: 可以把桌面检查看作是由个人进行的代码检查或代码走查，即一个人阅读程序，对照错误列表检查程序，使用测试数据对程序进行推演。对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因就是这个过程本身不受到任何约束。另外一个重要原因就是程序员常常不能够有效地测试自己编写的程序。因此最好由其他人而非该程序的编写人员进行桌面检查（例如可以让程序员之间相互交换各自编写的程序，避免自己对自己编写的程序进行桌面检查）。但是使用桌面检查的方法进行软件测试所得到的效果无法同代码走查或代码检查相比。代码检查和代码走查小组由多人组成，能够产生相互促进的效应。如果小组会议能够营造一种良性竞争的气氛，那么工作人员就能够乐于通过发现问题来展示自己的能力。而在桌面检查中，是无法做到这一点的。简而言之，桌面检查胜过没有检查，但测试效果远远不能同代码检查和代码走查相比。\n  - **同行评分**：虽然这种人工评审方法的目的是为了程序员提供一个自我评价的手段，与程序测试并无关系（其目标不是为了发现错误）。但是因为他与代码阅读的思想有关，是一种依据程序整体质量、可维护性、可扩展性、易用行和清晰性对匿名程序进行评价的技术。因此，有必要对其进行简单的了解。大致过程如下：首先挑选一位程序员担任评分过程的管理员，管理员再挑选出大约6~20名具备相似背景的参与者（例如，不同把Java应用程序员与汇编语言系统程序员编为一组）。每个参与者都提供两者由自己编写的程序以供评审，其中的一个程序是能代表参与者自身能力的最好作品，而另一个就是参与者认为质量较差的作品。\n\n## 3. 软件测试与调试的区别与联系\n白盒测试与调试的最终目的都是为了让被测应用(AUT)可以正常安全地运行，都是保证软件质量过程的一个环节。那么，白盒测试与调试有哪些不同呢？\n\n从承担的任务来看，白盒测试同其他类型测试一样，他的任务是发现所开发的项目中的缺陷；但是，调试不属于测试，其任务是纠正软件中的缺陷。\n\n从最终的结果来看，白盒测试有预知的结果，不可预知的知识程序是否通过测试，并且成功测试的结果是发现错误的症状，从而引起调试的进行；而调试的结果是消除项目中的错误。\n\n从执行的过程来看，软件测试只是发现程序中有错误的迹象，没有错误定位，也不需要找到出错原因；软件调试是根据测试报告的记录，在软件测试后纠正错误的工作，包括确定错误位置和修改错误。测试是一个错误发现、改正错误、重新测试的过程；而调试是一个推理过程。\n\n从准备工作来看，测试从已知的调试开始，使用预先定义的程序；调试是以不可知的内部条件开始，做统一性调试。\n\n从执行的计划性来看，测试是有计划的并要进行测试设计；而调试则不受时间约束。\n\n从测试的执行人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。\n\n测试的执行是有规程的，而调试的执行往往要求程序员进行必要推理以至知觉的“飞跃”。\n\n从执行的人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。\n\n从所使用的工具来看，大多数白盒测试的执行和设计可由工具支持，而调试程序员能利用的工具主要是调试器。\n\n## 4. 软件缺陷的概念\n1. 软件没有实现产品的说明书所描述的功能。\n2. 软件实现了产品说明书描述不应有的功能。\n3. 软件执行了产品说明书没讲的操作。\n4. 软件没有实现产品说明书没讲但应该实现的功能。\n5. 从软件测试员的角度来看，软件难以理解、不易使用、运行缓慢，或者最终用户认为不对。\n\n\n## 5. 单元测试\n### 5.1. 单元测试定义\n单元测试是在软件开发过程中要进行的最低级别的测试活动，或者说是针对软件设计的最小单位—程序模块，进行正确性检查的测试工作。其目的在于发现每个程序模块内部可能存在的差错。在单元测试活动中，软件的独立单元在与程序的其他部分相隔离的情况下进行测试。\n\n### 5.2. 单元测试主要任务\n主要工作分为两个步骤：人工静态检查和动态执行跟踪。前者主要是保证代码算法的逻辑正确性（尽量通过人工检查发现代码的逻辑错误）、清晰性、规范性、一致性、算法高效性，并尽可能地发现程序程序中没有发现的错误。后者就是通过设计测试用例，执行待测程序来跟踪比较实际结果与预期结果来发现错误。\n    \n(1) 正确性是指代码逻辑必须正确，能够实现预期的功能\n(2) 清晰性是指代码必须简明、易懂，注释准确没有歧义；\n(3) 规范性是指代码必须符合企业或部门所定义的共同规范，包括命名规则，代码风格\n(4) 一致性是指代码必须在命名上（如相同功能的变量尽量采用相同的标示符）、风格上都保持统一；\n(5) 高效性是指代码不但要满足以上性质，而且需要尽可能降低代码的执行时间。\n\n### 5.3. 单元测试使用方法\n基于代码的白盒测试\n\n## 6. 集成测试\n### 6.1 集成测试定义\n根据实际情况对成语模块采用适当的集成测试策略组装起来，对系统接口以及集成后的功能进行正确性检验的测试工作。\n\n### 6.2 集成测试策略\n#### 6.2.1 三明治集成\n\n(1) 目的：综合利用自顶向下和自底向上两种集成测试策略的优点\n(2) 定义：三明治集成是一种混合增值式测试策略，综合了自顶向下和自顶向上两种集成方法的优点，因此也属于基于功能分解测试。\n    \n### 6.3 集成测试过程\n![](/img/download.svg)\n\n## 7. 系统测试\n### 7.1. 系统测试的定义\n将已经集成好的软件系统，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。\n\n#### 7.2. 集成测试过程\n![](/img/download.svg)\n\n## 8. 软件测试模型\n### 8.1. V模型\n用户需求                                      验收测试  \n  需求分析和系统设计                确认测试和系统测试 \n             概要设计          集成测试\n                详细设计   单元测试\n                       编码\n                       \n经典的V模型阶段可以分为\n* 单元测试\n* 集成测试\n* 系统测试\n\n**模型特点**：V模型的价值主要在于他非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间的对应关系:\n\n* 单元测试的主要目的是根据详细设计说明书来验证和确认每个单元模块是否符合预期的要求，发现编码过程中可能存在的各种错误。\n* 集成测试主要目的是根据概要设计来验证和确认各个模块是否已正确集成到一起，主要是检查各单元与其他模块之间的接口上可能存在的错误。\n* 系统测试主要目的是根据需求定义，验证和确认系统作为一个整体是否能够正常有效地运行，例如，判断系统是否达到了用户预期的性能。\n\n### 8.2. W模型\nW模型中测试与开发对应关系如下：\n开发：需求分析、概要设计、　　详细设计、　　编码、　　软件集成、系统集成、部署\n　　　　　↑　　　　↑　　　　　　　↑　　　　　↑　　　　　　↑　　　　↑　　　↑\n\n测试：需求评审、概要设计评审、详细设计评审、单元测试、集成测试、系统测试、验收测试\n\nW模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临着困惑。\n\n### 8.3. H模型\n在H模型中，软件测试的过程活动完全独立，形成了一个完全独立的流程，贯穿于整个产品的周期，与其他流程并发进行，某个测试点准备就绪后就可以从测试准备阶段进行到测试执行阶段；软件测试可以根据被测产品的不同分层进行。\n\nH模型揭示了：\n    （1）软件测试不仅仅指测试的执行，还包括很多其他活动。\n    （2）软件测试是一个独立的流程，贯穿产品的整个开发周期，与其他流程并发进行。\n    （3）软件测试要尽早准备，尽早执行。\n    （4）软件测试根据被测物的不同是分层次的，不同层次的测试活动可以是按照某个次序先后进行的，但也可能是反复的。\n    \n## 9. 面向对象测试\n### 9.1.1 面向对象测试基本概念\n面向软件测试技术是新兴的软件测试技术，是专门针对使用面向对象技术开发的软件而提出的一种测试技术。其目的是为了解决传统的软件测试技术，面对面向对象技术开发的软件多少显得有些力不从心的现象。面向对象开发技术和传统的开发技术相比，新增了多态、继承、封装等特点。这些新特点使得开发出来的程序，具有更好的结构更规范的编程风格, 极大地优化了数据使用的安全性, 提高了代码的重用率。由此可见，它们是面向对象开发技术产生巨大吸引力的重要因素。然而，另一方面也影响了软件测试的方法和内容；增加了软件测试的难度；带来了传统软件设计技术所不存在的错误；或者使得传统软件测试中的重点不再显得突出；或者使原来测试经验认为和实践证明的次要方面成为了主要问题。\n\n## 10. 黑白盒测试\n\n### 10.1. 黑盒测试概念\n\n黑盒测试也称作功能测试和行为测试，主要是根据功能需求来测试程序是否按照预期工作。黑盒测试的目的是尽量发现代码所表现的外部行为的错误，主要有以下几类：\n\n    （1）功能不正确或不完整；\n    （2）接口错误；\n    （3）接口所使用的数据结构错误；\n    （4）行为或性能错误；\n    （5）初始化和终止错误。\n    \n### 10.2. 黑盒测试用例设计\n常用的黑盒测试用例设计方法主要有以下几中：等价类划分法、边界值分析法、因果图法、决策表法和错误推测法等方法。\n\n#### 10.2.1. 等价类划分法\n等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。\n\n等价类划分法：是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表的数据作为测试用例。\n\n等价类：指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，它们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其他数据。这样，对于表特征该类的数据输入将能代表这个子集合的输入。因此，可以合理地假定：测试某等价类的代表值等效于对于这类其他值的测试。\n\n“保险公司绩保费费率的程序”例题见《软件测试技术》(第二版) **P91**。\n\n#### 10.2.2. 边界值分析法\n边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为等价类划分方法的补充，在这个情况下，其测试用例来自等价类的边界。\n\n边界值分析使用与等价类划分方法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。\n\n例题：\n$$有二元函数 f(x,y), 其中x\\in[1,12],y\\in[1,31];则采用边界值分析法设计的测试用例是:$$\n\n                {<1,15>;<2,15>;<11,15>;<11,15>;<12,15>;<6,15>;<6,1>;<6,2>;<6,30>;<6,31>}\n    \n推论：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生 4n+1 个测试用例.\n            \n#### 10.2.3. 因果图法\n一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。因果图法就是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。\n\n采用因果图法设计测试用例的步骤：\n\n    （1）列出模块的原因（输入条件）和效果（动作），且给每个原因和效果一个标识符；\n    （2）列出原因——效果图；\n    （3）由于语法或环境的限制，有些原因和结果的组合情况是不可能出现的。为表明这些特定情况，在因果图上使用特殊的符号标明约束条件；\n    （4）把因果图转换成判定表；\n    （5）把判定表的每一列写成一个测试用例。\n\n“因果图法” 例题见《软件测试技术》(第二版) **P100**。\n\n#### 10.2.4. 决策表法\n在所有的黑盒测试中，机遇决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。\n\n构造决策表的 4 个步骤：\n    \n    （1）确定规则的个数，有 n 个条件的决策表有 2^n 个规则（每个条件取真、假值）；\n    （2）列出所有的条件桩和动作桩\n    （3）填入动作项，得到初始决策表；\n    （4）简化决策表，合并相似规则。\n    \n若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。合并后的条件项用符号——表示，说明执行的动作与该条件的取值无关，称为无关条件。\n\n\"三角形问题决策表\" 例题见《软件测试技术》（第二版）**P102**\n\n#### 10.2.5. 错误推测法\n错误推测法的概念：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。\n\n错误推测的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。\n\n### 10.3. 白盒测试概念\n白盒测试就是一种用于检查代码是否按照预期工作的验证技术，又称结构测试、逻辑驱动测试或基于程序的测试。白盒测试的主要特点就是正对被测程序的源代码，测试者可能完全不考虑程序的功能。\n\n### 10.4. 白盒测试用例设计\n常用的白盒测试用例设计方法主要有以下几中：逻辑覆盖测试、边界值测试、基本路径测试、循环语句测试、程序插桩测试、数据流测试、变异测试。\n\n#### 10.4.1 逻辑覆盖测试\n\n|类型|定义|\n|:-|:-|\n|语句覆盖|程序中的每个可执行语句至少执行一次|\n|判定覆盖|程序中每个判定的取真分支和取假分支的情况至少经历一次，即判断的真假值均曾被满足|\n|条件覆盖|要使每个判断中每个条件的可能取值至少满足一次|\n|判定-条件覆盖|使得判断中每个条件的所有可能至少出现一次，并且每个判断判定结果也至少出现一次|\n|路径覆盖|测试用例覆盖程序中所有可能的路径|\n\n```c\nIF((A > 1) AND (B = 0) THEN\n    X=X/A\nIF((A = 2) OR (X > 1) THEN\n    X=X+1\n```\n\n```flow\nsta=>start: Start\ncond1=>condition: (A>1) AND (B=0)\ncond2=>condition: (A=2) OR (X>1)\nio1=>operation: X=X/A\nio2=>operation: X=X+1\n\ne=>end: End\n\nsta->cond1(yes)->io1->cond2(yes)->io2->e\nsta->cond1(no,left)->cond2(no,left)->e\n```\n\n#### 10.4.2. 边界值分析\n等价类划分和边界值分析为软件测试提供了一种设计白盒测试用例的策略。\n\n#### 10.4.3. 基本路径测试\n\n#### 10.4.4 循环语句测试\n\n#### 10.4.5 插桩测试\n\n#### 10.4.6 数据流测试\n\n#### 10.4.7 变异测试\n","source":"_posts/软件测试复习.md","raw":"---\ntitle: 软件测试复习概要\ndate: 2019-01-05\ncategories: 学习资料\n\n---\n\n- [x] 软件测试常用的概念，常用的分类，测试的目的，方法等\n- [x] 软件测试静态测试的概念，技术，分类，执行过程，涉及的活动，测试的对象等\n- [x] 软件测试的模型分类，个各模型的特点，适用场景，规划的阶段及其关系，表达的图形等\n- [x] 面向对象的软件测试概念，与软件开发以及普通测试的关系等\n- [x] 集成测试、系统测试的概念，划分的阶段，先后执行的顺序，输入、输出成果物等\n- [x] 黑盒测试、白盒测试的概念，常用的方法，测试用例的设计过程，以及执行的过程如何实施等\n- [x] 等价类划分、边界值测试、三明治集成测试等概念、用例设计、实施过程\n- [x] 因果图法的概念，用例设计，执行步骤等\n- [x] 基本路径测试法概念，用例设计过程，实施执行过程等（控制流图画法、环形复杂度计算、基本路径获取、用例设计及执行等）\n- [x] 单元测试的概念，主要任务，使用的方法等\n- [x] 软件测试与调试的区别与联系，软件缺陷的概念及其相关知识\n\n<!-- ttoc -->\n\n<!--more-->\n## 1. 软件测试\n### 1.1 软件测试概念\n1. IEEE 在1983年将软件测试定义为“使用人工或者自动化手段运行或测定某个系统的过程，其目的在于检验他是否满足规定的需求或者是弄清预期结果与实际结果之间的差别“，该定义明确地提出了软件测试以检验是否为目标。\n2. Myers则认为软件测试“是为了发现错误而执行的程序过程”，明确提出了“寻找错误”是测试目的。\n3. 从软件质量保证的角度看，软件测试是一种重要的软件质量保证活动，其动机是通过一些经济、高效的方法，捕捉软件中的错误，从而达到保证软件内在质量的目的。\n\n### 1.2. 软件测试目的\n* 软件测试是为了发现错误而执行程序的过程\n* 测试是为了证明程序有错，而不是证明程序无错\n* 一个好的测试用例在于他能发现至今未发现的错误\n* 一个成功的测试是发现了至今未发现的错误的测试\n\n### 1.3. 软件测试技术分类\n|分类方法||\n|-|-|\n|从是否需要执行被测软件的角度|静态测试、动态测试|\n|从软件测试用例实际方法|黑盒测试、白盒测试|\n|按照软件测试的策略和过程|单元测试、集成测试、确认测试、系统测试、验收测试|\n\n## 2 静态测试\n### 2.1. 静态测试概念\n那些不利用计算机运行被测程序，而是通过其他手段达到测试目的的方法称作静态测试。换句话说，就是计算机并不真正运行被测试的程序，如在项目开发中存在着大量的规格说明，而说明规格是无法用计算机来运行的，所以对于这些软件的规格说明的测试就属于静态测试。\n\n### 2.2. 静态测试主要方法\n- 主要方法：**代码检查、走查、桌面检查、同行评分**\n  - **代码检查**: 所谓代码检查，是以组为单位阅读代码，他是一系列规则和错误检查技术的集合。对代码检查的大多数讨论都集中在规程、所要填写的表格等。这里对整个规程进行简短的概述。\n     - 为代码检查分发材料、安排进程\n     - 在代码检查中起主要作用\n     - 记录发现的所有错误\n     - 确保所有错误能够及时得到修正\n  - **代码走查**：代码走查与代码检查很相似，都是以小组我单位进行代码阅读，是一系列规程和错误检查技术的集合。代码走查的过程与代码检查大体相同，代码走查也是采用持续一至两个小时的不间断会议的形式。但是稍微所有不同，采用的错误检查技术也不一样。\n    代码走查小组有3~5人组成，其中一个人扮演类似代码检查过程中“协调人员”的角色，一个人担任秘书（负责记录所有查出的错误），还有一个人担任测试人员。建议在代码走查小组这最好包括如下人员：\n    （1）一位经验丰富的程序员；\n    （2）一位程序设计语言专家；\n    （3）一位初级程序员（可以给出新颖、不带偏见的观点）；\n    （4）将要负责程序维护的人员\n    （5）一位其他项目的人员\n    （6）一位来自该软件编程小组的程序员\n\n  - **桌面检查**: 可以把桌面检查看作是由个人进行的代码检查或代码走查，即一个人阅读程序，对照错误列表检查程序，使用测试数据对程序进行推演。对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因就是这个过程本身不受到任何约束。另外一个重要原因就是程序员常常不能够有效地测试自己编写的程序。因此最好由其他人而非该程序的编写人员进行桌面检查（例如可以让程序员之间相互交换各自编写的程序，避免自己对自己编写的程序进行桌面检查）。但是使用桌面检查的方法进行软件测试所得到的效果无法同代码走查或代码检查相比。代码检查和代码走查小组由多人组成，能够产生相互促进的效应。如果小组会议能够营造一种良性竞争的气氛，那么工作人员就能够乐于通过发现问题来展示自己的能力。而在桌面检查中，是无法做到这一点的。简而言之，桌面检查胜过没有检查，但测试效果远远不能同代码检查和代码走查相比。\n  - **同行评分**：虽然这种人工评审方法的目的是为了程序员提供一个自我评价的手段，与程序测试并无关系（其目标不是为了发现错误）。但是因为他与代码阅读的思想有关，是一种依据程序整体质量、可维护性、可扩展性、易用行和清晰性对匿名程序进行评价的技术。因此，有必要对其进行简单的了解。大致过程如下：首先挑选一位程序员担任评分过程的管理员，管理员再挑选出大约6~20名具备相似背景的参与者（例如，不同把Java应用程序员与汇编语言系统程序员编为一组）。每个参与者都提供两者由自己编写的程序以供评审，其中的一个程序是能代表参与者自身能力的最好作品，而另一个就是参与者认为质量较差的作品。\n\n## 3. 软件测试与调试的区别与联系\n白盒测试与调试的最终目的都是为了让被测应用(AUT)可以正常安全地运行，都是保证软件质量过程的一个环节。那么，白盒测试与调试有哪些不同呢？\n\n从承担的任务来看，白盒测试同其他类型测试一样，他的任务是发现所开发的项目中的缺陷；但是，调试不属于测试，其任务是纠正软件中的缺陷。\n\n从最终的结果来看，白盒测试有预知的结果，不可预知的知识程序是否通过测试，并且成功测试的结果是发现错误的症状，从而引起调试的进行；而调试的结果是消除项目中的错误。\n\n从执行的过程来看，软件测试只是发现程序中有错误的迹象，没有错误定位，也不需要找到出错原因；软件调试是根据测试报告的记录，在软件测试后纠正错误的工作，包括确定错误位置和修改错误。测试是一个错误发现、改正错误、重新测试的过程；而调试是一个推理过程。\n\n从准备工作来看，测试从已知的调试开始，使用预先定义的程序；调试是以不可知的内部条件开始，做统一性调试。\n\n从执行的计划性来看，测试是有计划的并要进行测试设计；而调试则不受时间约束。\n\n从测试的执行人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。\n\n测试的执行是有规程的，而调试的执行往往要求程序员进行必要推理以至知觉的“飞跃”。\n\n从执行的人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。\n\n从所使用的工具来看，大多数白盒测试的执行和设计可由工具支持，而调试程序员能利用的工具主要是调试器。\n\n## 4. 软件缺陷的概念\n1. 软件没有实现产品的说明书所描述的功能。\n2. 软件实现了产品说明书描述不应有的功能。\n3. 软件执行了产品说明书没讲的操作。\n4. 软件没有实现产品说明书没讲但应该实现的功能。\n5. 从软件测试员的角度来看，软件难以理解、不易使用、运行缓慢，或者最终用户认为不对。\n\n\n## 5. 单元测试\n### 5.1. 单元测试定义\n单元测试是在软件开发过程中要进行的最低级别的测试活动，或者说是针对软件设计的最小单位—程序模块，进行正确性检查的测试工作。其目的在于发现每个程序模块内部可能存在的差错。在单元测试活动中，软件的独立单元在与程序的其他部分相隔离的情况下进行测试。\n\n### 5.2. 单元测试主要任务\n主要工作分为两个步骤：人工静态检查和动态执行跟踪。前者主要是保证代码算法的逻辑正确性（尽量通过人工检查发现代码的逻辑错误）、清晰性、规范性、一致性、算法高效性，并尽可能地发现程序程序中没有发现的错误。后者就是通过设计测试用例，执行待测程序来跟踪比较实际结果与预期结果来发现错误。\n    \n(1) 正确性是指代码逻辑必须正确，能够实现预期的功能\n(2) 清晰性是指代码必须简明、易懂，注释准确没有歧义；\n(3) 规范性是指代码必须符合企业或部门所定义的共同规范，包括命名规则，代码风格\n(4) 一致性是指代码必须在命名上（如相同功能的变量尽量采用相同的标示符）、风格上都保持统一；\n(5) 高效性是指代码不但要满足以上性质，而且需要尽可能降低代码的执行时间。\n\n### 5.3. 单元测试使用方法\n基于代码的白盒测试\n\n## 6. 集成测试\n### 6.1 集成测试定义\n根据实际情况对成语模块采用适当的集成测试策略组装起来，对系统接口以及集成后的功能进行正确性检验的测试工作。\n\n### 6.2 集成测试策略\n#### 6.2.1 三明治集成\n\n(1) 目的：综合利用自顶向下和自底向上两种集成测试策略的优点\n(2) 定义：三明治集成是一种混合增值式测试策略，综合了自顶向下和自顶向上两种集成方法的优点，因此也属于基于功能分解测试。\n    \n### 6.3 集成测试过程\n![](/img/download.svg)\n\n## 7. 系统测试\n### 7.1. 系统测试的定义\n将已经集成好的软件系统，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。\n\n#### 7.2. 集成测试过程\n![](/img/download.svg)\n\n## 8. 软件测试模型\n### 8.1. V模型\n用户需求                                      验收测试  \n  需求分析和系统设计                确认测试和系统测试 \n             概要设计          集成测试\n                详细设计   单元测试\n                       编码\n                       \n经典的V模型阶段可以分为\n* 单元测试\n* 集成测试\n* 系统测试\n\n**模型特点**：V模型的价值主要在于他非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间的对应关系:\n\n* 单元测试的主要目的是根据详细设计说明书来验证和确认每个单元模块是否符合预期的要求，发现编码过程中可能存在的各种错误。\n* 集成测试主要目的是根据概要设计来验证和确认各个模块是否已正确集成到一起，主要是检查各单元与其他模块之间的接口上可能存在的错误。\n* 系统测试主要目的是根据需求定义，验证和确认系统作为一个整体是否能够正常有效地运行，例如，判断系统是否达到了用户预期的性能。\n\n### 8.2. W模型\nW模型中测试与开发对应关系如下：\n开发：需求分析、概要设计、　　详细设计、　　编码、　　软件集成、系统集成、部署\n　　　　　↑　　　　↑　　　　　　　↑　　　　　↑　　　　　　↑　　　　↑　　　↑\n\n测试：需求评审、概要设计评审、详细设计评审、单元测试、集成测试、系统测试、验收测试\n\nW模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临着困惑。\n\n### 8.3. H模型\n在H模型中，软件测试的过程活动完全独立，形成了一个完全独立的流程，贯穿于整个产品的周期，与其他流程并发进行，某个测试点准备就绪后就可以从测试准备阶段进行到测试执行阶段；软件测试可以根据被测产品的不同分层进行。\n\nH模型揭示了：\n    （1）软件测试不仅仅指测试的执行，还包括很多其他活动。\n    （2）软件测试是一个独立的流程，贯穿产品的整个开发周期，与其他流程并发进行。\n    （3）软件测试要尽早准备，尽早执行。\n    （4）软件测试根据被测物的不同是分层次的，不同层次的测试活动可以是按照某个次序先后进行的，但也可能是反复的。\n    \n## 9. 面向对象测试\n### 9.1.1 面向对象测试基本概念\n面向软件测试技术是新兴的软件测试技术，是专门针对使用面向对象技术开发的软件而提出的一种测试技术。其目的是为了解决传统的软件测试技术，面对面向对象技术开发的软件多少显得有些力不从心的现象。面向对象开发技术和传统的开发技术相比，新增了多态、继承、封装等特点。这些新特点使得开发出来的程序，具有更好的结构更规范的编程风格, 极大地优化了数据使用的安全性, 提高了代码的重用率。由此可见，它们是面向对象开发技术产生巨大吸引力的重要因素。然而，另一方面也影响了软件测试的方法和内容；增加了软件测试的难度；带来了传统软件设计技术所不存在的错误；或者使得传统软件测试中的重点不再显得突出；或者使原来测试经验认为和实践证明的次要方面成为了主要问题。\n\n## 10. 黑白盒测试\n\n### 10.1. 黑盒测试概念\n\n黑盒测试也称作功能测试和行为测试，主要是根据功能需求来测试程序是否按照预期工作。黑盒测试的目的是尽量发现代码所表现的外部行为的错误，主要有以下几类：\n\n    （1）功能不正确或不完整；\n    （2）接口错误；\n    （3）接口所使用的数据结构错误；\n    （4）行为或性能错误；\n    （5）初始化和终止错误。\n    \n### 10.2. 黑盒测试用例设计\n常用的黑盒测试用例设计方法主要有以下几中：等价类划分法、边界值分析法、因果图法、决策表法和错误推测法等方法。\n\n#### 10.2.1. 等价类划分法\n等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。\n\n等价类划分法：是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表的数据作为测试用例。\n\n等价类：指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，它们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其他数据。这样，对于表特征该类的数据输入将能代表这个子集合的输入。因此，可以合理地假定：测试某等价类的代表值等效于对于这类其他值的测试。\n\n“保险公司绩保费费率的程序”例题见《软件测试技术》(第二版) **P91**。\n\n#### 10.2.2. 边界值分析法\n边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为等价类划分方法的补充，在这个情况下，其测试用例来自等价类的边界。\n\n边界值分析使用与等价类划分方法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。\n\n例题：\n$$有二元函数 f(x,y), 其中x\\in[1,12],y\\in[1,31];则采用边界值分析法设计的测试用例是:$$\n\n                {<1,15>;<2,15>;<11,15>;<11,15>;<12,15>;<6,15>;<6,1>;<6,2>;<6,30>;<6,31>}\n    \n推论：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生 4n+1 个测试用例.\n            \n#### 10.2.3. 因果图法\n一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。因果图法就是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。\n\n采用因果图法设计测试用例的步骤：\n\n    （1）列出模块的原因（输入条件）和效果（动作），且给每个原因和效果一个标识符；\n    （2）列出原因——效果图；\n    （3）由于语法或环境的限制，有些原因和结果的组合情况是不可能出现的。为表明这些特定情况，在因果图上使用特殊的符号标明约束条件；\n    （4）把因果图转换成判定表；\n    （5）把判定表的每一列写成一个测试用例。\n\n“因果图法” 例题见《软件测试技术》(第二版) **P100**。\n\n#### 10.2.4. 决策表法\n在所有的黑盒测试中，机遇决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。\n\n构造决策表的 4 个步骤：\n    \n    （1）确定规则的个数，有 n 个条件的决策表有 2^n 个规则（每个条件取真、假值）；\n    （2）列出所有的条件桩和动作桩\n    （3）填入动作项，得到初始决策表；\n    （4）简化决策表，合并相似规则。\n    \n若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。合并后的条件项用符号——表示，说明执行的动作与该条件的取值无关，称为无关条件。\n\n\"三角形问题决策表\" 例题见《软件测试技术》（第二版）**P102**\n\n#### 10.2.5. 错误推测法\n错误推测法的概念：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。\n\n错误推测的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。\n\n### 10.3. 白盒测试概念\n白盒测试就是一种用于检查代码是否按照预期工作的验证技术，又称结构测试、逻辑驱动测试或基于程序的测试。白盒测试的主要特点就是正对被测程序的源代码，测试者可能完全不考虑程序的功能。\n\n### 10.4. 白盒测试用例设计\n常用的白盒测试用例设计方法主要有以下几中：逻辑覆盖测试、边界值测试、基本路径测试、循环语句测试、程序插桩测试、数据流测试、变异测试。\n\n#### 10.4.1 逻辑覆盖测试\n\n|类型|定义|\n|:-|:-|\n|语句覆盖|程序中的每个可执行语句至少执行一次|\n|判定覆盖|程序中每个判定的取真分支和取假分支的情况至少经历一次，即判断的真假值均曾被满足|\n|条件覆盖|要使每个判断中每个条件的可能取值至少满足一次|\n|判定-条件覆盖|使得判断中每个条件的所有可能至少出现一次，并且每个判断判定结果也至少出现一次|\n|路径覆盖|测试用例覆盖程序中所有可能的路径|\n\n```c\nIF((A > 1) AND (B = 0) THEN\n    X=X/A\nIF((A = 2) OR (X > 1) THEN\n    X=X+1\n```\n\n```flow\nsta=>start: Start\ncond1=>condition: (A>1) AND (B=0)\ncond2=>condition: (A=2) OR (X>1)\nio1=>operation: X=X/A\nio2=>operation: X=X+1\n\ne=>end: End\n\nsta->cond1(yes)->io1->cond2(yes)->io2->e\nsta->cond1(no,left)->cond2(no,left)->e\n```\n\n#### 10.4.2. 边界值分析\n等价类划分和边界值分析为软件测试提供了一种设计白盒测试用例的策略。\n\n#### 10.4.3. 基本路径测试\n\n#### 10.4.4 循环语句测试\n\n#### 10.4.5 插桩测试\n\n#### 10.4.6 数据流测试\n\n#### 10.4.7 变异测试\n","slug":"软件测试复习","published":1,"updated":"2021-03-10T15:12:33.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm3l2trr000xa5jx5toefgh1","content":"<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试常用的概念，常用的分类，测试的目的，方法等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试静态测试的概念，技术，分类，执行过程，涉及的活动，测试的对象等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试的模型分类，个各模型的特点，适用场景，规划的阶段及其关系，表达的图形等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 面向对象的软件测试概念，与软件开发以及普通测试的关系等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 集成测试、系统测试的概念，划分的阶段，先后执行的顺序，输入、输出成果物等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 黑盒测试、白盒测试的概念，常用的方法，测试用例的设计过程，以及执行的过程如何实施等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 等价类划分、边界值测试、三明治集成测试等概念、用例设计、实施过程</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 因果图法的概念，用例设计，执行步骤等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 基本路径测试法概念，用例设计过程，实施执行过程等（控制流图画法、环形复杂度计算、基本路径获取、用例设计及执行等）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 单元测试的概念，主要任务，使用的方法等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试与调试的区别与联系，软件缺陷的概念及其相关知识</li>\n</ul>\n<!-- ttoc -->\n\n<span id=\"more\"></span>\n<h2 id=\"1-软件测试\"><a href=\"#1-软件测试\" class=\"headerlink\" title=\"1. 软件测试\"></a>1. 软件测试</h2><h3 id=\"1-1-软件测试概念\"><a href=\"#1-1-软件测试概念\" class=\"headerlink\" title=\"1.1 软件测试概念\"></a>1.1 软件测试概念</h3><ol>\n<li>IEEE 在1983年将软件测试定义为“使用人工或者自动化手段运行或测定某个系统的过程，其目的在于检验他是否满足规定的需求或者是弄清预期结果与实际结果之间的差别“，该定义明确地提出了软件测试以检验是否为目标。</li>\n<li>Myers则认为软件测试“是为了发现错误而执行的程序过程”，明确提出了“寻找错误”是测试目的。</li>\n<li>从软件质量保证的角度看，软件测试是一种重要的软件质量保证活动，其动机是通过一些经济、高效的方法，捕捉软件中的错误，从而达到保证软件内在质量的目的。</li>\n</ol>\n<h3 id=\"1-2-软件测试目的\"><a href=\"#1-2-软件测试目的\" class=\"headerlink\" title=\"1.2. 软件测试目的\"></a>1.2. 软件测试目的</h3><ul>\n<li>软件测试是为了发现错误而执行程序的过程</li>\n<li>测试是为了证明程序有错，而不是证明程序无错</li>\n<li>一个好的测试用例在于他能发现至今未发现的错误</li>\n<li>一个成功的测试是发现了至今未发现的错误的测试</li>\n</ul>\n<h3 id=\"1-3-软件测试技术分类\"><a href=\"#1-3-软件测试技术分类\" class=\"headerlink\" title=\"1.3. 软件测试技术分类\"></a>1.3. 软件测试技术分类</h3><table>\n<thead>\n<tr>\n<th>分类方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>从是否需要执行被测软件的角度</td>\n<td>静态测试、动态测试</td>\n</tr>\n<tr>\n<td>从软件测试用例实际方法</td>\n<td>黑盒测试、白盒测试</td>\n</tr>\n<tr>\n<td>按照软件测试的策略和过程</td>\n<td>单元测试、集成测试、确认测试、系统测试、验收测试</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-静态测试\"><a href=\"#2-静态测试\" class=\"headerlink\" title=\"2 静态测试\"></a>2 静态测试</h2><h3 id=\"2-1-静态测试概念\"><a href=\"#2-1-静态测试概念\" class=\"headerlink\" title=\"2.1. 静态测试概念\"></a>2.1. 静态测试概念</h3><p>那些不利用计算机运行被测程序，而是通过其他手段达到测试目的的方法称作静态测试。换句话说，就是计算机并不真正运行被测试的程序，如在项目开发中存在着大量的规格说明，而说明规格是无法用计算机来运行的，所以对于这些软件的规格说明的测试就属于静态测试。</p>\n<h3 id=\"2-2-静态测试主要方法\"><a href=\"#2-2-静态测试主要方法\" class=\"headerlink\" title=\"2.2. 静态测试主要方法\"></a>2.2. 静态测试主要方法</h3><ul>\n<li><p>主要方法：<strong>代码检查、走查、桌面检查、同行评分</strong></p>\n<ul>\n<li><p><strong>代码检查</strong>: 所谓代码检查，是以组为单位阅读代码，他是一系列规则和错误检查技术的集合。对代码检查的大多数讨论都集中在规程、所要填写的表格等。这里对整个规程进行简短的概述。</p>\n<ul>\n<li>为代码检查分发材料、安排进程</li>\n<li>在代码检查中起主要作用</li>\n<li>记录发现的所有错误</li>\n<li>确保所有错误能够及时得到修正</li>\n</ul>\n</li>\n<li><p><strong>代码走查</strong>：代码走查与代码检查很相似，都是以小组我单位进行代码阅读，是一系列规程和错误检查技术的集合。代码走查的过程与代码检查大体相同，代码走查也是采用持续一至两个小时的不间断会议的形式。但是稍微所有不同，采用的错误检查技术也不一样。<br>代码走查小组有3~5人组成，其中一个人扮演类似代码检查过程中“协调人员”的角色，一个人担任秘书（负责记录所有查出的错误），还有一个人担任测试人员。建议在代码走查小组这最好包括如下人员：<br>（1）一位经验丰富的程序员；<br>（2）一位程序设计语言专家；<br>（3）一位初级程序员（可以给出新颖、不带偏见的观点）；<br>（4）将要负责程序维护的人员<br>（5）一位其他项目的人员<br>（6）一位来自该软件编程小组的程序员</p>\n</li>\n<li><p><strong>桌面检查</strong>: 可以把桌面检查看作是由个人进行的代码检查或代码走查，即一个人阅读程序，对照错误列表检查程序，使用测试数据对程序进行推演。对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因就是这个过程本身不受到任何约束。另外一个重要原因就是程序员常常不能够有效地测试自己编写的程序。因此最好由其他人而非该程序的编写人员进行桌面检查（例如可以让程序员之间相互交换各自编写的程序，避免自己对自己编写的程序进行桌面检查）。但是使用桌面检查的方法进行软件测试所得到的效果无法同代码走查或代码检查相比。代码检查和代码走查小组由多人组成，能够产生相互促进的效应。如果小组会议能够营造一种良性竞争的气氛，那么工作人员就能够乐于通过发现问题来展示自己的能力。而在桌面检查中，是无法做到这一点的。简而言之，桌面检查胜过没有检查，但测试效果远远不能同代码检查和代码走查相比。</p>\n</li>\n<li><p><strong>同行评分</strong>：虽然这种人工评审方法的目的是为了程序员提供一个自我评价的手段，与程序测试并无关系（其目标不是为了发现错误）。但是因为他与代码阅读的思想有关，是一种依据程序整体质量、可维护性、可扩展性、易用行和清晰性对匿名程序进行评价的技术。因此，有必要对其进行简单的了解。大致过程如下：首先挑选一位程序员担任评分过程的管理员，管理员再挑选出大约6~20名具备相似背景的参与者（例如，不同把Java应用程序员与汇编语言系统程序员编为一组）。每个参与者都提供两者由自己编写的程序以供评审，其中的一个程序是能代表参与者自身能力的最好作品，而另一个就是参与者认为质量较差的作品。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-软件测试与调试的区别与联系\"><a href=\"#3-软件测试与调试的区别与联系\" class=\"headerlink\" title=\"3. 软件测试与调试的区别与联系\"></a>3. 软件测试与调试的区别与联系</h2><p>白盒测试与调试的最终目的都是为了让被测应用(AUT)可以正常安全地运行，都是保证软件质量过程的一个环节。那么，白盒测试与调试有哪些不同呢？</p>\n<p>从承担的任务来看，白盒测试同其他类型测试一样，他的任务是发现所开发的项目中的缺陷；但是，调试不属于测试，其任务是纠正软件中的缺陷。</p>\n<p>从最终的结果来看，白盒测试有预知的结果，不可预知的知识程序是否通过测试，并且成功测试的结果是发现错误的症状，从而引起调试的进行；而调试的结果是消除项目中的错误。</p>\n<p>从执行的过程来看，软件测试只是发现程序中有错误的迹象，没有错误定位，也不需要找到出错原因；软件调试是根据测试报告的记录，在软件测试后纠正错误的工作，包括确定错误位置和修改错误。测试是一个错误发现、改正错误、重新测试的过程；而调试是一个推理过程。</p>\n<p>从准备工作来看，测试从已知的调试开始，使用预先定义的程序；调试是以不可知的内部条件开始，做统一性调试。</p>\n<p>从执行的计划性来看，测试是有计划的并要进行测试设计；而调试则不受时间约束。</p>\n<p>从测试的执行人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。</p>\n<p>测试的执行是有规程的，而调试的执行往往要求程序员进行必要推理以至知觉的“飞跃”。</p>\n<p>从执行的人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。</p>\n<p>从所使用的工具来看，大多数白盒测试的执行和设计可由工具支持，而调试程序员能利用的工具主要是调试器。</p>\n<h2 id=\"4-软件缺陷的概念\"><a href=\"#4-软件缺陷的概念\" class=\"headerlink\" title=\"4. 软件缺陷的概念\"></a>4. 软件缺陷的概念</h2><ol>\n<li>软件没有实现产品的说明书所描述的功能。</li>\n<li>软件实现了产品说明书描述不应有的功能。</li>\n<li>软件执行了产品说明书没讲的操作。</li>\n<li>软件没有实现产品说明书没讲但应该实现的功能。</li>\n<li>从软件测试员的角度来看，软件难以理解、不易使用、运行缓慢，或者最终用户认为不对。</li>\n</ol>\n<h2 id=\"5-单元测试\"><a href=\"#5-单元测试\" class=\"headerlink\" title=\"5. 单元测试\"></a>5. 单元测试</h2><h3 id=\"5-1-单元测试定义\"><a href=\"#5-1-单元测试定义\" class=\"headerlink\" title=\"5.1. 单元测试定义\"></a>5.1. 单元测试定义</h3><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，或者说是针对软件设计的最小单位—程序模块，进行正确性检查的测试工作。其目的在于发现每个程序模块内部可能存在的差错。在单元测试活动中，软件的独立单元在与程序的其他部分相隔离的情况下进行测试。</p>\n<h3 id=\"5-2-单元测试主要任务\"><a href=\"#5-2-单元测试主要任务\" class=\"headerlink\" title=\"5.2. 单元测试主要任务\"></a>5.2. 单元测试主要任务</h3><p>主要工作分为两个步骤：人工静态检查和动态执行跟踪。前者主要是保证代码算法的逻辑正确性（尽量通过人工检查发现代码的逻辑错误）、清晰性、规范性、一致性、算法高效性，并尽可能地发现程序程序中没有发现的错误。后者就是通过设计测试用例，执行待测程序来跟踪比较实际结果与预期结果来发现错误。</p>\n<p>(1) 正确性是指代码逻辑必须正确，能够实现预期的功能<br>(2) 清晰性是指代码必须简明、易懂，注释准确没有歧义；<br>(3) 规范性是指代码必须符合企业或部门所定义的共同规范，包括命名规则，代码风格<br>(4) 一致性是指代码必须在命名上（如相同功能的变量尽量采用相同的标示符）、风格上都保持统一；<br>(5) 高效性是指代码不但要满足以上性质，而且需要尽可能降低代码的执行时间。</p>\n<h3 id=\"5-3-单元测试使用方法\"><a href=\"#5-3-单元测试使用方法\" class=\"headerlink\" title=\"5.3. 单元测试使用方法\"></a>5.3. 单元测试使用方法</h3><p>基于代码的白盒测试</p>\n<h2 id=\"6-集成测试\"><a href=\"#6-集成测试\" class=\"headerlink\" title=\"6. 集成测试\"></a>6. 集成测试</h2><h3 id=\"6-1-集成测试定义\"><a href=\"#6-1-集成测试定义\" class=\"headerlink\" title=\"6.1 集成测试定义\"></a>6.1 集成测试定义</h3><p>根据实际情况对成语模块采用适当的集成测试策略组装起来，对系统接口以及集成后的功能进行正确性检验的测试工作。</p>\n<h3 id=\"6-2-集成测试策略\"><a href=\"#6-2-集成测试策略\" class=\"headerlink\" title=\"6.2 集成测试策略\"></a>6.2 集成测试策略</h3><h4 id=\"6-2-1-三明治集成\"><a href=\"#6-2-1-三明治集成\" class=\"headerlink\" title=\"6.2.1 三明治集成\"></a>6.2.1 三明治集成</h4><p>(1) 目的：综合利用自顶向下和自底向上两种集成测试策略的优点<br>(2) 定义：三明治集成是一种混合增值式测试策略，综合了自顶向下和自顶向上两种集成方法的优点，因此也属于基于功能分解测试。</p>\n<h3 id=\"6-3-集成测试过程\"><a href=\"#6-3-集成测试过程\" class=\"headerlink\" title=\"6.3 集成测试过程\"></a>6.3 集成测试过程</h3><p><img src=\"/img/download.svg\"></p>\n<h2 id=\"7-系统测试\"><a href=\"#7-系统测试\" class=\"headerlink\" title=\"7. 系统测试\"></a>7. 系统测试</h2><h3 id=\"7-1-系统测试的定义\"><a href=\"#7-1-系统测试的定义\" class=\"headerlink\" title=\"7.1. 系统测试的定义\"></a>7.1. 系统测试的定义</h3><p>将已经集成好的软件系统，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p>\n<h4 id=\"7-2-集成测试过程\"><a href=\"#7-2-集成测试过程\" class=\"headerlink\" title=\"7.2. 集成测试过程\"></a>7.2. 集成测试过程</h4><p><img src=\"/img/download.svg\"></p>\n<h2 id=\"8-软件测试模型\"><a href=\"#8-软件测试模型\" class=\"headerlink\" title=\"8. 软件测试模型\"></a>8. 软件测试模型</h2><h3 id=\"8-1-V模型\"><a href=\"#8-1-V模型\" class=\"headerlink\" title=\"8.1. V模型\"></a>8.1. V模型</h3><p>用户需求                                      验收测试<br>  需求分析和系统设计                确认测试和系统测试<br>             概要设计          集成测试<br>                详细设计   单元测试<br>                       编码</p>\n<p>经典的V模型阶段可以分为</p>\n<ul>\n<li>单元测试</li>\n<li>集成测试</li>\n<li>系统测试</li>\n</ul>\n<p><strong>模型特点</strong>：V模型的价值主要在于他非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间的对应关系:</p>\n<ul>\n<li>单元测试的主要目的是根据详细设计说明书来验证和确认每个单元模块是否符合预期的要求，发现编码过程中可能存在的各种错误。</li>\n<li>集成测试主要目的是根据概要设计来验证和确认各个模块是否已正确集成到一起，主要是检查各单元与其他模块之间的接口上可能存在的错误。</li>\n<li>系统测试主要目的是根据需求定义，验证和确认系统作为一个整体是否能够正常有效地运行，例如，判断系统是否达到了用户预期的性能。</li>\n</ul>\n<h3 id=\"8-2-W模型\"><a href=\"#8-2-W模型\" class=\"headerlink\" title=\"8.2. W模型\"></a>8.2. W模型</h3><p>W模型中测试与开发对应关系如下：<br>开发：需求分析、概要设计、　　详细设计、　　编码、　　软件集成、系统集成、部署<br>　　　　　↑　　　　↑　　　　　　　↑　　　　　↑　　　　　　↑　　　　↑　　　↑</p>\n<p>测试：需求评审、概要设计评审、详细设计评审、单元测试、集成测试、系统测试、验收测试</p>\n<p>W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临着困惑。</p>\n<h3 id=\"8-3-H模型\"><a href=\"#8-3-H模型\" class=\"headerlink\" title=\"8.3. H模型\"></a>8.3. H模型</h3><p>在H模型中，软件测试的过程活动完全独立，形成了一个完全独立的流程，贯穿于整个产品的周期，与其他流程并发进行，某个测试点准备就绪后就可以从测试准备阶段进行到测试执行阶段；软件测试可以根据被测产品的不同分层进行。</p>\n<p>H模型揭示了：<br>    （1）软件测试不仅仅指测试的执行，还包括很多其他活动。<br>    （2）软件测试是一个独立的流程，贯穿产品的整个开发周期，与其他流程并发进行。<br>    （3）软件测试要尽早准备，尽早执行。<br>    （4）软件测试根据被测物的不同是分层次的，不同层次的测试活动可以是按照某个次序先后进行的，但也可能是反复的。</p>\n<h2 id=\"9-面向对象测试\"><a href=\"#9-面向对象测试\" class=\"headerlink\" title=\"9. 面向对象测试\"></a>9. 面向对象测试</h2><h3 id=\"9-1-1-面向对象测试基本概念\"><a href=\"#9-1-1-面向对象测试基本概念\" class=\"headerlink\" title=\"9.1.1 面向对象测试基本概念\"></a>9.1.1 面向对象测试基本概念</h3><p>面向软件测试技术是新兴的软件测试技术，是专门针对使用面向对象技术开发的软件而提出的一种测试技术。其目的是为了解决传统的软件测试技术，面对面向对象技术开发的软件多少显得有些力不从心的现象。面向对象开发技术和传统的开发技术相比，新增了多态、继承、封装等特点。这些新特点使得开发出来的程序，具有更好的结构更规范的编程风格, 极大地优化了数据使用的安全性, 提高了代码的重用率。由此可见，它们是面向对象开发技术产生巨大吸引力的重要因素。然而，另一方面也影响了软件测试的方法和内容；增加了软件测试的难度；带来了传统软件设计技术所不存在的错误；或者使得传统软件测试中的重点不再显得突出；或者使原来测试经验认为和实践证明的次要方面成为了主要问题。</p>\n<h2 id=\"10-黑白盒测试\"><a href=\"#10-黑白盒测试\" class=\"headerlink\" title=\"10. 黑白盒测试\"></a>10. 黑白盒测试</h2><h3 id=\"10-1-黑盒测试概念\"><a href=\"#10-1-黑盒测试概念\" class=\"headerlink\" title=\"10.1. 黑盒测试概念\"></a>10.1. 黑盒测试概念</h3><p>黑盒测试也称作功能测试和行为测试，主要是根据功能需求来测试程序是否按照预期工作。黑盒测试的目的是尽量发现代码所表现的外部行为的错误，主要有以下几类：</p>\n<pre><code>（1）功能不正确或不完整；\n（2）接口错误；\n（3）接口所使用的数据结构错误；\n（4）行为或性能错误；\n（5）初始化和终止错误。\n</code></pre>\n<h3 id=\"10-2-黑盒测试用例设计\"><a href=\"#10-2-黑盒测试用例设计\" class=\"headerlink\" title=\"10.2. 黑盒测试用例设计\"></a>10.2. 黑盒测试用例设计</h3><p>常用的黑盒测试用例设计方法主要有以下几中：等价类划分法、边界值分析法、因果图法、决策表法和错误推测法等方法。</p>\n<h4 id=\"10-2-1-等价类划分法\"><a href=\"#10-2-1-等价类划分法\" class=\"headerlink\" title=\"10.2.1. 等价类划分法\"></a>10.2.1. 等价类划分法</h4><p>等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。</p>\n<p>等价类划分法：是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表的数据作为测试用例。</p>\n<p>等价类：指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，它们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其他数据。这样，对于表特征该类的数据输入将能代表这个子集合的输入。因此，可以合理地假定：测试某等价类的代表值等效于对于这类其他值的测试。</p>\n<p>“保险公司绩保费费率的程序”例题见《软件测试技术》(第二版) <strong>P91</strong>。</p>\n<h4 id=\"10-2-2-边界值分析法\"><a href=\"#10-2-2-边界值分析法\" class=\"headerlink\" title=\"10.2.2. 边界值分析法\"></a>10.2.2. 边界值分析法</h4><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为等价类划分方法的补充，在这个情况下，其测试用例来自等价类的边界。</p>\n<p>边界值分析使用与等价类划分方法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。</p>\n<p>例题：<br>$$有二元函数 f(x,y), 其中x\\in[1,12],y\\in[1,31];则采用边界值分析法设计的测试用例是:$$</p>\n<pre><code>            &#123;&lt;1,15&gt;;&lt;2,15&gt;;&lt;11,15&gt;;&lt;11,15&gt;;&lt;12,15&gt;;&lt;6,15&gt;;&lt;6,1&gt;;&lt;6,2&gt;;&lt;6,30&gt;;&lt;6,31&gt;&#125;\n</code></pre>\n<p>推论：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生 4n+1 个测试用例.</p>\n<h4 id=\"10-2-3-因果图法\"><a href=\"#10-2-3-因果图法\" class=\"headerlink\" title=\"10.2.3. 因果图法\"></a>10.2.3. 因果图法</h4><p>一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。因果图法就是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p>\n<p>采用因果图法设计测试用例的步骤：</p>\n<pre><code>（1）列出模块的原因（输入条件）和效果（动作），且给每个原因和效果一个标识符；\n（2）列出原因——效果图；\n（3）由于语法或环境的限制，有些原因和结果的组合情况是不可能出现的。为表明这些特定情况，在因果图上使用特殊的符号标明约束条件；\n（4）把因果图转换成判定表；\n（5）把判定表的每一列写成一个测试用例。\n</code></pre>\n<p>“因果图法” 例题见《软件测试技术》(第二版) <strong>P100</strong>。</p>\n<h4 id=\"10-2-4-决策表法\"><a href=\"#10-2-4-决策表法\" class=\"headerlink\" title=\"10.2.4. 决策表法\"></a>10.2.4. 决策表法</h4><p>在所有的黑盒测试中，机遇决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。</p>\n<p>构造决策表的 4 个步骤：</p>\n<pre><code>（1）确定规则的个数，有 n 个条件的决策表有 2^n 个规则（每个条件取真、假值）；\n（2）列出所有的条件桩和动作桩\n（3）填入动作项，得到初始决策表；\n（4）简化决策表，合并相似规则。\n</code></pre>\n<p>若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。合并后的条件项用符号——表示，说明执行的动作与该条件的取值无关，称为无关条件。</p>\n<p>“三角形问题决策表” 例题见《软件测试技术》（第二版）<strong>P102</strong></p>\n<h4 id=\"10-2-5-错误推测法\"><a href=\"#10-2-5-错误推测法\" class=\"headerlink\" title=\"10.2.5. 错误推测法\"></a>10.2.5. 错误推测法</h4><p>错误推测法的概念：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。</p>\n<p>错误推测的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</p>\n<h3 id=\"10-3-白盒测试概念\"><a href=\"#10-3-白盒测试概念\" class=\"headerlink\" title=\"10.3. 白盒测试概念\"></a>10.3. 白盒测试概念</h3><p>白盒测试就是一种用于检查代码是否按照预期工作的验证技术，又称结构测试、逻辑驱动测试或基于程序的测试。白盒测试的主要特点就是正对被测程序的源代码，测试者可能完全不考虑程序的功能。</p>\n<h3 id=\"10-4-白盒测试用例设计\"><a href=\"#10-4-白盒测试用例设计\" class=\"headerlink\" title=\"10.4. 白盒测试用例设计\"></a>10.4. 白盒测试用例设计</h3><p>常用的白盒测试用例设计方法主要有以下几中：逻辑覆盖测试、边界值测试、基本路径测试、循环语句测试、程序插桩测试、数据流测试、变异测试。</p>\n<h4 id=\"10-4-1-逻辑覆盖测试\"><a href=\"#10-4-1-逻辑覆盖测试\" class=\"headerlink\" title=\"10.4.1 逻辑覆盖测试\"></a>10.4.1 逻辑覆盖测试</h4><table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">语句覆盖</td>\n<td align=\"left\">程序中的每个可执行语句至少执行一次</td>\n</tr>\n<tr>\n<td align=\"left\">判定覆盖</td>\n<td align=\"left\">程序中每个判定的取真分支和取假分支的情况至少经历一次，即判断的真假值均曾被满足</td>\n</tr>\n<tr>\n<td align=\"left\">条件覆盖</td>\n<td align=\"left\">要使每个判断中每个条件的可能取值至少满足一次</td>\n</tr>\n<tr>\n<td align=\"left\">判定-条件覆盖</td>\n<td align=\"left\">使得判断中每个条件的所有可能至少出现一次，并且每个判断判定结果也至少出现一次</td>\n</tr>\n<tr>\n<td align=\"left\">路径覆盖</td>\n<td align=\"left\">测试用例覆盖程序中所有可能的路径</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">IF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>A <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token function\">AND</span> <span class=\"token punctuation\">(</span>B <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> THEN\n    X<span class=\"token operator\">=</span>X<span class=\"token operator\">/</span>A\n<span class=\"token function\">IF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>A <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token function\">OR</span> <span class=\"token punctuation\">(</span>X <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> THEN\n    X<span class=\"token operator\">=</span>X<span class=\"token operator\">+</span><span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-flow\" data-language=\"flow\"><code class=\"language-flow\">sta<span class=\"token operator\">=></span>start<span class=\"token operator\">:</span> Start\ncond1<span class=\"token operator\">=></span>condition<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">AND</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">B</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\ncond2<span class=\"token operator\">=></span>condition<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">OR</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nio1<span class=\"token operator\">=></span>operation<span class=\"token operator\">:</span> <span class=\"token constant\">X</span><span class=\"token operator\">=</span><span class=\"token constant\">X</span><span class=\"token operator\">/</span><span class=\"token constant\">A</span>\nio2<span class=\"token operator\">=></span>operation<span class=\"token operator\">:</span> <span class=\"token constant\">X</span><span class=\"token operator\">=</span><span class=\"token constant\">X</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n\ne<span class=\"token operator\">=></span>end<span class=\"token operator\">:</span> End\n\nsta<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond1</span><span class=\"token punctuation\">(</span>yes<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>io1<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond2</span><span class=\"token punctuation\">(</span>yes<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>io2<span class=\"token operator\">-</span><span class=\"token operator\">></span>e\nsta<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond1</span><span class=\"token punctuation\">(</span>no<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond2</span><span class=\"token punctuation\">(</span>no<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"10-4-2-边界值分析\"><a href=\"#10-4-2-边界值分析\" class=\"headerlink\" title=\"10.4.2. 边界值分析\"></a>10.4.2. 边界值分析</h4><p>等价类划分和边界值分析为软件测试提供了一种设计白盒测试用例的策略。</p>\n<h4 id=\"10-4-3-基本路径测试\"><a href=\"#10-4-3-基本路径测试\" class=\"headerlink\" title=\"10.4.3. 基本路径测试\"></a>10.4.3. 基本路径测试</h4><h4 id=\"10-4-4-循环语句测试\"><a href=\"#10-4-4-循环语句测试\" class=\"headerlink\" title=\"10.4.4 循环语句测试\"></a>10.4.4 循环语句测试</h4><h4 id=\"10-4-5-插桩测试\"><a href=\"#10-4-5-插桩测试\" class=\"headerlink\" title=\"10.4.5 插桩测试\"></a>10.4.5 插桩测试</h4><h4 id=\"10-4-6-数据流测试\"><a href=\"#10-4-6-数据流测试\" class=\"headerlink\" title=\"10.4.6 数据流测试\"></a>10.4.6 数据流测试</h4><h4 id=\"10-4-7-变异测试\"><a href=\"#10-4-7-变异测试\" class=\"headerlink\" title=\"10.4.7 变异测试\"></a>10.4.7 变异测试</h4>","site":{"data":{}},"excerpt":"<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试常用的概念，常用的分类，测试的目的，方法等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试静态测试的概念，技术，分类，执行过程，涉及的活动，测试的对象等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试的模型分类，个各模型的特点，适用场景，规划的阶段及其关系，表达的图形等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 面向对象的软件测试概念，与软件开发以及普通测试的关系等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 集成测试、系统测试的概念，划分的阶段，先后执行的顺序，输入、输出成果物等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 黑盒测试、白盒测试的概念，常用的方法，测试用例的设计过程，以及执行的过程如何实施等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 等价类划分、边界值测试、三明治集成测试等概念、用例设计、实施过程</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 因果图法的概念，用例设计，执行步骤等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 基本路径测试法概念，用例设计过程，实施执行过程等（控制流图画法、环形复杂度计算、基本路径获取、用例设计及执行等）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 单元测试的概念，主要任务，使用的方法等</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 软件测试与调试的区别与联系，软件缺陷的概念及其相关知识</li>\n</ul>\n<!-- ttoc -->","more":"<h2 id=\"1-软件测试\"><a href=\"#1-软件测试\" class=\"headerlink\" title=\"1. 软件测试\"></a>1. 软件测试</h2><h3 id=\"1-1-软件测试概念\"><a href=\"#1-1-软件测试概念\" class=\"headerlink\" title=\"1.1 软件测试概念\"></a>1.1 软件测试概念</h3><ol>\n<li>IEEE 在1983年将软件测试定义为“使用人工或者自动化手段运行或测定某个系统的过程，其目的在于检验他是否满足规定的需求或者是弄清预期结果与实际结果之间的差别“，该定义明确地提出了软件测试以检验是否为目标。</li>\n<li>Myers则认为软件测试“是为了发现错误而执行的程序过程”，明确提出了“寻找错误”是测试目的。</li>\n<li>从软件质量保证的角度看，软件测试是一种重要的软件质量保证活动，其动机是通过一些经济、高效的方法，捕捉软件中的错误，从而达到保证软件内在质量的目的。</li>\n</ol>\n<h3 id=\"1-2-软件测试目的\"><a href=\"#1-2-软件测试目的\" class=\"headerlink\" title=\"1.2. 软件测试目的\"></a>1.2. 软件测试目的</h3><ul>\n<li>软件测试是为了发现错误而执行程序的过程</li>\n<li>测试是为了证明程序有错，而不是证明程序无错</li>\n<li>一个好的测试用例在于他能发现至今未发现的错误</li>\n<li>一个成功的测试是发现了至今未发现的错误的测试</li>\n</ul>\n<h3 id=\"1-3-软件测试技术分类\"><a href=\"#1-3-软件测试技术分类\" class=\"headerlink\" title=\"1.3. 软件测试技术分类\"></a>1.3. 软件测试技术分类</h3><table>\n<thead>\n<tr>\n<th>分类方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>从是否需要执行被测软件的角度</td>\n<td>静态测试、动态测试</td>\n</tr>\n<tr>\n<td>从软件测试用例实际方法</td>\n<td>黑盒测试、白盒测试</td>\n</tr>\n<tr>\n<td>按照软件测试的策略和过程</td>\n<td>单元测试、集成测试、确认测试、系统测试、验收测试</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-静态测试\"><a href=\"#2-静态测试\" class=\"headerlink\" title=\"2 静态测试\"></a>2 静态测试</h2><h3 id=\"2-1-静态测试概念\"><a href=\"#2-1-静态测试概念\" class=\"headerlink\" title=\"2.1. 静态测试概念\"></a>2.1. 静态测试概念</h3><p>那些不利用计算机运行被测程序，而是通过其他手段达到测试目的的方法称作静态测试。换句话说，就是计算机并不真正运行被测试的程序，如在项目开发中存在着大量的规格说明，而说明规格是无法用计算机来运行的，所以对于这些软件的规格说明的测试就属于静态测试。</p>\n<h3 id=\"2-2-静态测试主要方法\"><a href=\"#2-2-静态测试主要方法\" class=\"headerlink\" title=\"2.2. 静态测试主要方法\"></a>2.2. 静态测试主要方法</h3><ul>\n<li><p>主要方法：<strong>代码检查、走查、桌面检查、同行评分</strong></p>\n<ul>\n<li><p><strong>代码检查</strong>: 所谓代码检查，是以组为单位阅读代码，他是一系列规则和错误检查技术的集合。对代码检查的大多数讨论都集中在规程、所要填写的表格等。这里对整个规程进行简短的概述。</p>\n<ul>\n<li>为代码检查分发材料、安排进程</li>\n<li>在代码检查中起主要作用</li>\n<li>记录发现的所有错误</li>\n<li>确保所有错误能够及时得到修正</li>\n</ul>\n</li>\n<li><p><strong>代码走查</strong>：代码走查与代码检查很相似，都是以小组我单位进行代码阅读，是一系列规程和错误检查技术的集合。代码走查的过程与代码检查大体相同，代码走查也是采用持续一至两个小时的不间断会议的形式。但是稍微所有不同，采用的错误检查技术也不一样。<br>代码走查小组有3~5人组成，其中一个人扮演类似代码检查过程中“协调人员”的角色，一个人担任秘书（负责记录所有查出的错误），还有一个人担任测试人员。建议在代码走查小组这最好包括如下人员：<br>（1）一位经验丰富的程序员；<br>（2）一位程序设计语言专家；<br>（3）一位初级程序员（可以给出新颖、不带偏见的观点）；<br>（4）将要负责程序维护的人员<br>（5）一位其他项目的人员<br>（6）一位来自该软件编程小组的程序员</p>\n</li>\n<li><p><strong>桌面检查</strong>: 可以把桌面检查看作是由个人进行的代码检查或代码走查，即一个人阅读程序，对照错误列表检查程序，使用测试数据对程序进行推演。对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因就是这个过程本身不受到任何约束。另外一个重要原因就是程序员常常不能够有效地测试自己编写的程序。因此最好由其他人而非该程序的编写人员进行桌面检查（例如可以让程序员之间相互交换各自编写的程序，避免自己对自己编写的程序进行桌面检查）。但是使用桌面检查的方法进行软件测试所得到的效果无法同代码走查或代码检查相比。代码检查和代码走查小组由多人组成，能够产生相互促进的效应。如果小组会议能够营造一种良性竞争的气氛，那么工作人员就能够乐于通过发现问题来展示自己的能力。而在桌面检查中，是无法做到这一点的。简而言之，桌面检查胜过没有检查，但测试效果远远不能同代码检查和代码走查相比。</p>\n</li>\n<li><p><strong>同行评分</strong>：虽然这种人工评审方法的目的是为了程序员提供一个自我评价的手段，与程序测试并无关系（其目标不是为了发现错误）。但是因为他与代码阅读的思想有关，是一种依据程序整体质量、可维护性、可扩展性、易用行和清晰性对匿名程序进行评价的技术。因此，有必要对其进行简单的了解。大致过程如下：首先挑选一位程序员担任评分过程的管理员，管理员再挑选出大约6~20名具备相似背景的参与者（例如，不同把Java应用程序员与汇编语言系统程序员编为一组）。每个参与者都提供两者由自己编写的程序以供评审，其中的一个程序是能代表参与者自身能力的最好作品，而另一个就是参与者认为质量较差的作品。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-软件测试与调试的区别与联系\"><a href=\"#3-软件测试与调试的区别与联系\" class=\"headerlink\" title=\"3. 软件测试与调试的区别与联系\"></a>3. 软件测试与调试的区别与联系</h2><p>白盒测试与调试的最终目的都是为了让被测应用(AUT)可以正常安全地运行，都是保证软件质量过程的一个环节。那么，白盒测试与调试有哪些不同呢？</p>\n<p>从承担的任务来看，白盒测试同其他类型测试一样，他的任务是发现所开发的项目中的缺陷；但是，调试不属于测试，其任务是纠正软件中的缺陷。</p>\n<p>从最终的结果来看，白盒测试有预知的结果，不可预知的知识程序是否通过测试，并且成功测试的结果是发现错误的症状，从而引起调试的进行；而调试的结果是消除项目中的错误。</p>\n<p>从执行的过程来看，软件测试只是发现程序中有错误的迹象，没有错误定位，也不需要找到出错原因；软件调试是根据测试报告的记录，在软件测试后纠正错误的工作，包括确定错误位置和修改错误。测试是一个错误发现、改正错误、重新测试的过程；而调试是一个推理过程。</p>\n<p>从准备工作来看，测试从已知的调试开始，使用预先定义的程序；调试是以不可知的内部条件开始，做统一性调试。</p>\n<p>从执行的计划性来看，测试是有计划的并要进行测试设计；而调试则不受时间约束。</p>\n<p>从测试的执行人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。</p>\n<p>测试的执行是有规程的，而调试的执行往往要求程序员进行必要推理以至知觉的“飞跃”。</p>\n<p>从执行的人员来看，测试经常是由独立的测试组在不了解软件设计的条件下完成的，而调试必须由程序员来完成。</p>\n<p>从所使用的工具来看，大多数白盒测试的执行和设计可由工具支持，而调试程序员能利用的工具主要是调试器。</p>\n<h2 id=\"4-软件缺陷的概念\"><a href=\"#4-软件缺陷的概念\" class=\"headerlink\" title=\"4. 软件缺陷的概念\"></a>4. 软件缺陷的概念</h2><ol>\n<li>软件没有实现产品的说明书所描述的功能。</li>\n<li>软件实现了产品说明书描述不应有的功能。</li>\n<li>软件执行了产品说明书没讲的操作。</li>\n<li>软件没有实现产品说明书没讲但应该实现的功能。</li>\n<li>从软件测试员的角度来看，软件难以理解、不易使用、运行缓慢，或者最终用户认为不对。</li>\n</ol>\n<h2 id=\"5-单元测试\"><a href=\"#5-单元测试\" class=\"headerlink\" title=\"5. 单元测试\"></a>5. 单元测试</h2><h3 id=\"5-1-单元测试定义\"><a href=\"#5-1-单元测试定义\" class=\"headerlink\" title=\"5.1. 单元测试定义\"></a>5.1. 单元测试定义</h3><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，或者说是针对软件设计的最小单位—程序模块，进行正确性检查的测试工作。其目的在于发现每个程序模块内部可能存在的差错。在单元测试活动中，软件的独立单元在与程序的其他部分相隔离的情况下进行测试。</p>\n<h3 id=\"5-2-单元测试主要任务\"><a href=\"#5-2-单元测试主要任务\" class=\"headerlink\" title=\"5.2. 单元测试主要任务\"></a>5.2. 单元测试主要任务</h3><p>主要工作分为两个步骤：人工静态检查和动态执行跟踪。前者主要是保证代码算法的逻辑正确性（尽量通过人工检查发现代码的逻辑错误）、清晰性、规范性、一致性、算法高效性，并尽可能地发现程序程序中没有发现的错误。后者就是通过设计测试用例，执行待测程序来跟踪比较实际结果与预期结果来发现错误。</p>\n<p>(1) 正确性是指代码逻辑必须正确，能够实现预期的功能<br>(2) 清晰性是指代码必须简明、易懂，注释准确没有歧义；<br>(3) 规范性是指代码必须符合企业或部门所定义的共同规范，包括命名规则，代码风格<br>(4) 一致性是指代码必须在命名上（如相同功能的变量尽量采用相同的标示符）、风格上都保持统一；<br>(5) 高效性是指代码不但要满足以上性质，而且需要尽可能降低代码的执行时间。</p>\n<h3 id=\"5-3-单元测试使用方法\"><a href=\"#5-3-单元测试使用方法\" class=\"headerlink\" title=\"5.3. 单元测试使用方法\"></a>5.3. 单元测试使用方法</h3><p>基于代码的白盒测试</p>\n<h2 id=\"6-集成测试\"><a href=\"#6-集成测试\" class=\"headerlink\" title=\"6. 集成测试\"></a>6. 集成测试</h2><h3 id=\"6-1-集成测试定义\"><a href=\"#6-1-集成测试定义\" class=\"headerlink\" title=\"6.1 集成测试定义\"></a>6.1 集成测试定义</h3><p>根据实际情况对成语模块采用适当的集成测试策略组装起来，对系统接口以及集成后的功能进行正确性检验的测试工作。</p>\n<h3 id=\"6-2-集成测试策略\"><a href=\"#6-2-集成测试策略\" class=\"headerlink\" title=\"6.2 集成测试策略\"></a>6.2 集成测试策略</h3><h4 id=\"6-2-1-三明治集成\"><a href=\"#6-2-1-三明治集成\" class=\"headerlink\" title=\"6.2.1 三明治集成\"></a>6.2.1 三明治集成</h4><p>(1) 目的：综合利用自顶向下和自底向上两种集成测试策略的优点<br>(2) 定义：三明治集成是一种混合增值式测试策略，综合了自顶向下和自顶向上两种集成方法的优点，因此也属于基于功能分解测试。</p>\n<h3 id=\"6-3-集成测试过程\"><a href=\"#6-3-集成测试过程\" class=\"headerlink\" title=\"6.3 集成测试过程\"></a>6.3 集成测试过程</h3><p><img src=\"/img/download.svg\"></p>\n<h2 id=\"7-系统测试\"><a href=\"#7-系统测试\" class=\"headerlink\" title=\"7. 系统测试\"></a>7. 系统测试</h2><h3 id=\"7-1-系统测试的定义\"><a href=\"#7-1-系统测试的定义\" class=\"headerlink\" title=\"7.1. 系统测试的定义\"></a>7.1. 系统测试的定义</h3><p>将已经集成好的软件系统，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p>\n<h4 id=\"7-2-集成测试过程\"><a href=\"#7-2-集成测试过程\" class=\"headerlink\" title=\"7.2. 集成测试过程\"></a>7.2. 集成测试过程</h4><p><img src=\"/img/download.svg\"></p>\n<h2 id=\"8-软件测试模型\"><a href=\"#8-软件测试模型\" class=\"headerlink\" title=\"8. 软件测试模型\"></a>8. 软件测试模型</h2><h3 id=\"8-1-V模型\"><a href=\"#8-1-V模型\" class=\"headerlink\" title=\"8.1. V模型\"></a>8.1. V模型</h3><p>用户需求                                      验收测试<br>  需求分析和系统设计                确认测试和系统测试<br>             概要设计          集成测试<br>                详细设计   单元测试<br>                       编码</p>\n<p>经典的V模型阶段可以分为</p>\n<ul>\n<li>单元测试</li>\n<li>集成测试</li>\n<li>系统测试</li>\n</ul>\n<p><strong>模型特点</strong>：V模型的价值主要在于他非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间的对应关系:</p>\n<ul>\n<li>单元测试的主要目的是根据详细设计说明书来验证和确认每个单元模块是否符合预期的要求，发现编码过程中可能存在的各种错误。</li>\n<li>集成测试主要目的是根据概要设计来验证和确认各个模块是否已正确集成到一起，主要是检查各单元与其他模块之间的接口上可能存在的错误。</li>\n<li>系统测试主要目的是根据需求定义，验证和确认系统作为一个整体是否能够正常有效地运行，例如，判断系统是否达到了用户预期的性能。</li>\n</ul>\n<h3 id=\"8-2-W模型\"><a href=\"#8-2-W模型\" class=\"headerlink\" title=\"8.2. W模型\"></a>8.2. W模型</h3><p>W模型中测试与开发对应关系如下：<br>开发：需求分析、概要设计、　　详细设计、　　编码、　　软件集成、系统集成、部署<br>　　　　　↑　　　　↑　　　　　　　↑　　　　　↑　　　　　　↑　　　　↑　　　↑</p>\n<p>测试：需求评审、概要设计评审、详细设计评审、单元测试、集成测试、系统测试、验收测试</p>\n<p>W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临着困惑。</p>\n<h3 id=\"8-3-H模型\"><a href=\"#8-3-H模型\" class=\"headerlink\" title=\"8.3. H模型\"></a>8.3. H模型</h3><p>在H模型中，软件测试的过程活动完全独立，形成了一个完全独立的流程，贯穿于整个产品的周期，与其他流程并发进行，某个测试点准备就绪后就可以从测试准备阶段进行到测试执行阶段；软件测试可以根据被测产品的不同分层进行。</p>\n<p>H模型揭示了：<br>    （1）软件测试不仅仅指测试的执行，还包括很多其他活动。<br>    （2）软件测试是一个独立的流程，贯穿产品的整个开发周期，与其他流程并发进行。<br>    （3）软件测试要尽早准备，尽早执行。<br>    （4）软件测试根据被测物的不同是分层次的，不同层次的测试活动可以是按照某个次序先后进行的，但也可能是反复的。</p>\n<h2 id=\"9-面向对象测试\"><a href=\"#9-面向对象测试\" class=\"headerlink\" title=\"9. 面向对象测试\"></a>9. 面向对象测试</h2><h3 id=\"9-1-1-面向对象测试基本概念\"><a href=\"#9-1-1-面向对象测试基本概念\" class=\"headerlink\" title=\"9.1.1 面向对象测试基本概念\"></a>9.1.1 面向对象测试基本概念</h3><p>面向软件测试技术是新兴的软件测试技术，是专门针对使用面向对象技术开发的软件而提出的一种测试技术。其目的是为了解决传统的软件测试技术，面对面向对象技术开发的软件多少显得有些力不从心的现象。面向对象开发技术和传统的开发技术相比，新增了多态、继承、封装等特点。这些新特点使得开发出来的程序，具有更好的结构更规范的编程风格, 极大地优化了数据使用的安全性, 提高了代码的重用率。由此可见，它们是面向对象开发技术产生巨大吸引力的重要因素。然而，另一方面也影响了软件测试的方法和内容；增加了软件测试的难度；带来了传统软件设计技术所不存在的错误；或者使得传统软件测试中的重点不再显得突出；或者使原来测试经验认为和实践证明的次要方面成为了主要问题。</p>\n<h2 id=\"10-黑白盒测试\"><a href=\"#10-黑白盒测试\" class=\"headerlink\" title=\"10. 黑白盒测试\"></a>10. 黑白盒测试</h2><h3 id=\"10-1-黑盒测试概念\"><a href=\"#10-1-黑盒测试概念\" class=\"headerlink\" title=\"10.1. 黑盒测试概念\"></a>10.1. 黑盒测试概念</h3><p>黑盒测试也称作功能测试和行为测试，主要是根据功能需求来测试程序是否按照预期工作。黑盒测试的目的是尽量发现代码所表现的外部行为的错误，主要有以下几类：</p>\n<pre><code>（1）功能不正确或不完整；\n（2）接口错误；\n（3）接口所使用的数据结构错误；\n（4）行为或性能错误；\n（5）初始化和终止错误。\n</code></pre>\n<h3 id=\"10-2-黑盒测试用例设计\"><a href=\"#10-2-黑盒测试用例设计\" class=\"headerlink\" title=\"10.2. 黑盒测试用例设计\"></a>10.2. 黑盒测试用例设计</h3><p>常用的黑盒测试用例设计方法主要有以下几中：等价类划分法、边界值分析法、因果图法、决策表法和错误推测法等方法。</p>\n<h4 id=\"10-2-1-等价类划分法\"><a href=\"#10-2-1-等价类划分法\" class=\"headerlink\" title=\"10.2.1. 等价类划分法\"></a>10.2.1. 等价类划分法</h4><p>等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。</p>\n<p>等价类划分法：是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表的数据作为测试用例。</p>\n<p>等价类：指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，它们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其他数据。这样，对于表特征该类的数据输入将能代表这个子集合的输入。因此，可以合理地假定：测试某等价类的代表值等效于对于这类其他值的测试。</p>\n<p>“保险公司绩保费费率的程序”例题见《软件测试技术》(第二版) <strong>P91</strong>。</p>\n<h4 id=\"10-2-2-边界值分析法\"><a href=\"#10-2-2-边界值分析法\" class=\"headerlink\" title=\"10.2.2. 边界值分析法\"></a>10.2.2. 边界值分析法</h4><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为等价类划分方法的补充，在这个情况下，其测试用例来自等价类的边界。</p>\n<p>边界值分析使用与等价类划分方法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。</p>\n<p>例题：<br>$$有二元函数 f(x,y), 其中x\\in[1,12],y\\in[1,31];则采用边界值分析法设计的测试用例是:$$</p>\n<pre><code>            &#123;&lt;1,15&gt;;&lt;2,15&gt;;&lt;11,15&gt;;&lt;11,15&gt;;&lt;12,15&gt;;&lt;6,15&gt;;&lt;6,1&gt;;&lt;6,2&gt;;&lt;6,30&gt;;&lt;6,31&gt;&#125;\n</code></pre>\n<p>推论：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生 4n+1 个测试用例.</p>\n<h4 id=\"10-2-3-因果图法\"><a href=\"#10-2-3-因果图法\" class=\"headerlink\" title=\"10.2.3. 因果图法\"></a>10.2.3. 因果图法</h4><p>一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。因果图法就是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p>\n<p>采用因果图法设计测试用例的步骤：</p>\n<pre><code>（1）列出模块的原因（输入条件）和效果（动作），且给每个原因和效果一个标识符；\n（2）列出原因——效果图；\n（3）由于语法或环境的限制，有些原因和结果的组合情况是不可能出现的。为表明这些特定情况，在因果图上使用特殊的符号标明约束条件；\n（4）把因果图转换成判定表；\n（5）把判定表的每一列写成一个测试用例。\n</code></pre>\n<p>“因果图法” 例题见《软件测试技术》(第二版) <strong>P100</strong>。</p>\n<h4 id=\"10-2-4-决策表法\"><a href=\"#10-2-4-决策表法\" class=\"headerlink\" title=\"10.2.4. 决策表法\"></a>10.2.4. 决策表法</h4><p>在所有的黑盒测试中，机遇决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。</p>\n<p>构造决策表的 4 个步骤：</p>\n<pre><code>（1）确定规则的个数，有 n 个条件的决策表有 2^n 个规则（每个条件取真、假值）；\n（2）列出所有的条件桩和动作桩\n（3）填入动作项，得到初始决策表；\n（4）简化决策表，合并相似规则。\n</code></pre>\n<p>若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。合并后的条件项用符号——表示，说明执行的动作与该条件的取值无关，称为无关条件。</p>\n<p>“三角形问题决策表” 例题见《软件测试技术》（第二版）<strong>P102</strong></p>\n<h4 id=\"10-2-5-错误推测法\"><a href=\"#10-2-5-错误推测法\" class=\"headerlink\" title=\"10.2.5. 错误推测法\"></a>10.2.5. 错误推测法</h4><p>错误推测法的概念：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。</p>\n<p>错误推测的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</p>\n<h3 id=\"10-3-白盒测试概念\"><a href=\"#10-3-白盒测试概念\" class=\"headerlink\" title=\"10.3. 白盒测试概念\"></a>10.3. 白盒测试概念</h3><p>白盒测试就是一种用于检查代码是否按照预期工作的验证技术，又称结构测试、逻辑驱动测试或基于程序的测试。白盒测试的主要特点就是正对被测程序的源代码，测试者可能完全不考虑程序的功能。</p>\n<h3 id=\"10-4-白盒测试用例设计\"><a href=\"#10-4-白盒测试用例设计\" class=\"headerlink\" title=\"10.4. 白盒测试用例设计\"></a>10.4. 白盒测试用例设计</h3><p>常用的白盒测试用例设计方法主要有以下几中：逻辑覆盖测试、边界值测试、基本路径测试、循环语句测试、程序插桩测试、数据流测试、变异测试。</p>\n<h4 id=\"10-4-1-逻辑覆盖测试\"><a href=\"#10-4-1-逻辑覆盖测试\" class=\"headerlink\" title=\"10.4.1 逻辑覆盖测试\"></a>10.4.1 逻辑覆盖测试</h4><table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">语句覆盖</td>\n<td align=\"left\">程序中的每个可执行语句至少执行一次</td>\n</tr>\n<tr>\n<td align=\"left\">判定覆盖</td>\n<td align=\"left\">程序中每个判定的取真分支和取假分支的情况至少经历一次，即判断的真假值均曾被满足</td>\n</tr>\n<tr>\n<td align=\"left\">条件覆盖</td>\n<td align=\"left\">要使每个判断中每个条件的可能取值至少满足一次</td>\n</tr>\n<tr>\n<td align=\"left\">判定-条件覆盖</td>\n<td align=\"left\">使得判断中每个条件的所有可能至少出现一次，并且每个判断判定结果也至少出现一次</td>\n</tr>\n<tr>\n<td align=\"left\">路径覆盖</td>\n<td align=\"left\">测试用例覆盖程序中所有可能的路径</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">IF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>A <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token function\">AND</span> <span class=\"token punctuation\">(</span>B <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> THEN\n    X<span class=\"token operator\">=</span>X<span class=\"token operator\">/</span>A\n<span class=\"token function\">IF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>A <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token function\">OR</span> <span class=\"token punctuation\">(</span>X <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> THEN\n    X<span class=\"token operator\">=</span>X<span class=\"token operator\">+</span><span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-flow\" data-language=\"flow\"><code class=\"language-flow\">sta<span class=\"token operator\">=></span>start<span class=\"token operator\">:</span> Start\ncond1<span class=\"token operator\">=></span>condition<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">AND</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">B</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\ncond2<span class=\"token operator\">=></span>condition<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">OR</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nio1<span class=\"token operator\">=></span>operation<span class=\"token operator\">:</span> <span class=\"token constant\">X</span><span class=\"token operator\">=</span><span class=\"token constant\">X</span><span class=\"token operator\">/</span><span class=\"token constant\">A</span>\nio2<span class=\"token operator\">=></span>operation<span class=\"token operator\">:</span> <span class=\"token constant\">X</span><span class=\"token operator\">=</span><span class=\"token constant\">X</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n\ne<span class=\"token operator\">=></span>end<span class=\"token operator\">:</span> End\n\nsta<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond1</span><span class=\"token punctuation\">(</span>yes<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>io1<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond2</span><span class=\"token punctuation\">(</span>yes<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>io2<span class=\"token operator\">-</span><span class=\"token operator\">></span>e\nsta<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond1</span><span class=\"token punctuation\">(</span>no<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">cond2</span><span class=\"token punctuation\">(</span>no<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"10-4-2-边界值分析\"><a href=\"#10-4-2-边界值分析\" class=\"headerlink\" title=\"10.4.2. 边界值分析\"></a>10.4.2. 边界值分析</h4><p>等价类划分和边界值分析为软件测试提供了一种设计白盒测试用例的策略。</p>\n<h4 id=\"10-4-3-基本路径测试\"><a href=\"#10-4-3-基本路径测试\" class=\"headerlink\" title=\"10.4.3. 基本路径测试\"></a>10.4.3. 基本路径测试</h4><h4 id=\"10-4-4-循环语句测试\"><a href=\"#10-4-4-循环语句测试\" class=\"headerlink\" title=\"10.4.4 循环语句测试\"></a>10.4.4 循环语句测试</h4><h4 id=\"10-4-5-插桩测试\"><a href=\"#10-4-5-插桩测试\" class=\"headerlink\" title=\"10.4.5 插桩测试\"></a>10.4.5 插桩测试</h4><h4 id=\"10-4-6-数据流测试\"><a href=\"#10-4-6-数据流测试\" class=\"headerlink\" title=\"10.4.6 数据流测试\"></a>10.4.6 数据流测试</h4><h4 id=\"10-4-7-变异测试\"><a href=\"#10-4-7-变异测试\" class=\"headerlink\" title=\"10.4.7 变异测试\"></a>10.4.7 变异测试</h4>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckm3l2tqw0001a5jx3e9n8mix","category_id":"ckm3l2tr30004a5jxfdrx75om","_id":"ckm3l2trc000ca5jxfrpnef2o"},{"post_id":"ckm3l2tra000aa5jx4ubbdd0s","category_id":"ckm3l2tr30004a5jxfdrx75om","_id":"ckm3l2trh000ga5jx43t9b7fa"},{"post_id":"ckm3l2tr10003a5jx67ut4e9h","category_id":"ckm3l2tr90009a5jxgmfl90zt","_id":"ckm3l2trk000ja5jxguo93zy5"},{"post_id":"ckm3l2trb000ba5jx780edljg","category_id":"ckm3l2tr90009a5jxgmfl90zt","_id":"ckm3l2trl000la5jxdvec9pal"},{"post_id":"ckm3l2tr50006a5jx2mgcf20e","category_id":"ckm3l2tr90009a5jxgmfl90zt","_id":"ckm3l2trm000na5jxccruexhi"},{"post_id":"ckm3l2tr70007a5jxdc57421f","category_id":"ckm3l2trh000ha5jxftf3dnko","_id":"ckm3l2trn000oa5jxau685968"},{"post_id":"ckm3l2tr80008a5jxb34bcphl","category_id":"ckm3l2trl000ma5jx06n6gqur","_id":"ckm3l2tro000ra5jx0be2cic2"},{"post_id":"ckm3l2tre000ea5jx5qwub0f0","category_id":"ckm3l2trn000qa5jx1u370iza","_id":"ckm3l2trp000ta5jxfsrh8ogz"},{"post_id":"ckm3l2trg000fa5jx1bm1h51g","category_id":"ckm3l2tro000sa5jxfm0e6udv","_id":"ckm3l2trp000va5jxhkan4a95"},{"post_id":"ckm3l2tri000ia5jx04ogg2dn","category_id":"ckm3l2trp000ua5jx586egxjw","_id":"ckm3l2trp000wa5jx22ikcgmf"},{"post_id":"ckm3l2trr000xa5jx5toefgh1","category_id":"ckm3l2trs000ya5jxb3u10ezt","_id":"ckm3l2trt000za5jx8o1489wz"}],"PostTag":[{"post_id":"ckm3l2trg000fa5jx1bm1h51g","tag_id":"ckm3l2trk000ka5jx8aviczn6","_id":"ckm3l2trn000pa5jxhngd6skh"}],"Tag":[{"name":"UEFI - BOOT","_id":"ckm3l2trk000ka5jx8aviczn6"}]}}